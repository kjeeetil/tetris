<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self' https://pyscript.net https://cdn.jsdelivr.net https://cdn.tailwindcss.com data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://pyscript.net https://cdn.jsdelivr.net https://cdn.tailwindcss.com; style-src 'self' 'unsafe-inline' https://pyscript.net https://fonts.googleapis.com; connect-src 'self' https://pyscript.net https://cdn.jsdelivr.net https://cdn.tailwindcss.com https://fonts.googleapis.com https://fonts.gstatic.com data: blob:; font-src 'self' https://fonts.gstatic.com; img-src 'self' data:;"
    />
    <title>Tetris</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet"
    />
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              ink: '#161629',
              iris: '#5E4AE3',
              plum: '#C09FE4',
              citron: '#F4F779',
              fern: '#2F6B49',
              spruce: '#0C3B2E',
              rosewood: '#8C2F39',
              mint: '#8DE1AD',
              shell: '#F9F5FF',
            },
            fontFamily: {
              display: ['"Instrument Serif"', 'serif'],
              body: ['"Instrument Serif"', 'serif'],
            },
            boxShadow: {
              glow: '0 30px 60px rgba(32, 19, 72, 0.4)',
            },
          },
        },
      };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      :root {
        color-scheme: dark;
      }
      body {
        position: relative;
        margin: 0;
        min-height: 100vh;
        font-family: "Instrument Serif", serif;
        text-align: center;
        color: #f9f5ff;
        background:
          radial-gradient(120% 120% at 16% 20%, rgba(244, 247, 121, 0.18) 0%, transparent 56%),
          radial-gradient(130% 110% at 84% 12%, rgba(94, 74, 227, 0.28) 0%, transparent 62%),
          radial-gradient(120% 120% at 82% 82%, rgba(141, 225, 173, 0.24) 0%, transparent 68%),
          linear-gradient(135deg, #161629 0%, #241b4b 48%, #0f3b2e 100%);
        overflow-x: hidden;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        background: linear-gradient(135deg, rgba(192, 159, 228, 0.16), rgba(22, 22, 41, 0.62));
        opacity: 0.85;
        mix-blend-mode: screen;
        z-index: -2;
      }
      .aura-shape {
        position: absolute;
        border-radius: 48px;
        filter: drop-shadow(0 30px 60px rgba(17, 17, 31, 0.36));
        z-index: -1;
      }
      .aura-shape--1 {
        top: -96px;
        left: -56px;
        width: 280px;
        height: 320px;
        background: linear-gradient(135deg, rgba(94, 74, 227, 0.82), rgba(192, 159, 228, 0.55));
      }
      .aura-shape--2 {
        top: 180px;
        right: 8%;
        width: 220px;
        height: 220px;
        border-radius: 50%;
        border: 6px solid rgba(244, 247, 121, 0.55);
        background: transparent;
      }
      .aura-shape--3 {
        bottom: -140px;
        left: 12%;
        width: 190px;
        height: 320px;
        background: linear-gradient(180deg, rgba(15, 59, 46, 0.8), rgba(141, 225, 173, 0.45));
        transform: rotate(-12deg);
      }
      .aura-shape--4 {
        bottom: -170px;
        right: -96px;
        width: 360px;
        height: 280px;
        background: linear-gradient(135deg, rgba(140, 47, 57, 0.78), rgba(94, 74, 227, 0.5));
        transform: rotate(18deg);
        border-radius: 60px;
      }
      canvas {
        display: block;
        margin: 0 auto;
        border-radius: 32px;
        border: 2px solid rgba(255, 255, 255, 0.18);
        background: #1c1b32;
      }
      #preview,
      #score-plot {
        display: block;
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(12, 59, 46, 0.08);
      }
      #network-viz {
        border-radius: 32px;
        border: 1px solid rgba(255, 255, 255, 0.22);
        background: rgba(12, 59, 46, 0.12);
      }
      #network-viz svg {
        width: 100%;
        height: 100%;
        border-radius: 30px;
      }
      #network-viz text {
        font-size: 10px;
        fill: rgba(249, 245, 255, 0.82);
        pointer-events: none;
      }
      #diagnostics {
        border-radius: 28px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(12, 59, 46, 0.12);
        box-shadow: inset 0 0 0 1px rgba(249, 245, 255, 0.05);
        overflow-y: auto;
        font-family: "Instrument Serif", serif;
      }
      .glass-panel {
        border-radius: 28px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: linear-gradient(135deg, rgba(249, 245, 255, 0.18), rgba(94, 74, 227, 0.08));
        box-shadow: 0 20px 45px rgba(10, 10, 26, 0.35);
      }
      .noscript-alert {
        background: linear-gradient(135deg, rgba(140, 47, 57, 0.24), rgba(249, 245, 255, 0.12));
        border-color: rgba(140, 47, 57, 0.45);
        color: #8c2f39;
        text-shadow: 0 1px 12px rgba(249, 245, 255, 0.35);
      }
      .icon-btn {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 62px;
        height: 62px;
        border-radius: 22px;
        border: none;
        background: linear-gradient(135deg, #f4f779, #8de1ad);
        color: #1b1839;
        font-size: 26px;
        font-weight: 600;
        letter-spacing: 0.04em;
        box-shadow: 0 14px 30px rgba(17, 17, 31, 0.35), inset 0 2px 0 rgba(255, 255, 255, 0.6);
        cursor: pointer;
        transition: transform 0.18s ease, box-shadow 0.2s ease;
      }
      .icon-btn::before {
        content: "";
        position: absolute;
        inset: 4px;
        border-radius: 18px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.52), rgba(255, 255, 255, 0));
        opacity: 0.85;
        pointer-events: none;
      }
      .icon-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 18px 36px rgba(17, 17, 31, 0.38);
      }
      .icon-btn:active {
        transform: translateY(1px) scale(0.97);
        box-shadow: 0 8px 18px rgba(17, 17, 31, 0.4) inset;
      }
      .icon-btn--violet {
        background: linear-gradient(135deg, #5e4ae3, #c09fe4);
        color: #f9f5ff;
      }
      .icon-btn--emerald {
        background: linear-gradient(135deg, #8de1ad, #2f6b49);
        color: #0f3b2e;
      }
      .icon-btn--wide {
        width: auto;
        min-width: 150px;
        padding: 0 1.8rem;
        font-size: 18px;
      }
      select,
      input[type='range'] {
        font-family: "Instrument Serif", serif;
      }
      select {
        background: rgba(249, 245, 255, 0.14);
        border: 1px solid rgba(255, 255, 255, 0.24);
        border-radius: 18px;
        color: #f9f5ff;
        padding: 0.6rem 1rem;
      }
      select:focus {
        outline: none;
        border-color: rgba(244, 247, 121, 0.7);
        box-shadow: 0 0 0 3px rgba(244, 247, 121, 0.25);
      }
      input[type='range'] {
        width: 240px;
        accent-color: #f4f779;
      }
      canvas:focus {
        outline: none;
      }
      @media (max-width: 768px) {
        canvas {
          width: min(88vw, 320px);
          height: auto;
        }
        .icon-btn {
          width: 56px;
          height: 56px;
          font-size: 22px;
        }
        .icon-btn--wide {
          min-width: 140px;
          padding: 0 1.5rem;
        }
      }
      /* No external runtimes required; pure JS renderer */
    </style>
  </head>
  <body class="relative min-h-screen overflow-x-hidden font-body antialiased text-shell">
    <div class="aura-shape aura-shape--1"></div>
    <div class="aura-shape aura-shape--2"></div>
    <div class="aura-shape aura-shape--3"></div>
    <div class="aura-shape aura-shape--4"></div>
    <main class="relative z-10 flex flex-col items-center px-6 py-12 md:py-16 gap-12">
      <header class="max-w-3xl text-center">
        <p class="text-xs uppercase tracking-[0.45em] text-plum/70">AUTO ARCADE</p>
        <h1 class="mt-5 text-4xl md:text-6xl font-display text-citron drop-shadow-[0_18px_40px_rgba(94,74,227,0.35)]">
          Tetris Reinforcement Learning Lab
        </h1>
      </header>
      <noscript>
        <div class="glass-panel noscript-alert px-6 py-4 text-base rounded-3xl">
          JavaScript is disabled. Enable it to play.
        </div>
      </noscript>
      <div class="game relative flex w-full max-w-5xl flex-col items-center gap-8">
        <canvas id="canvas" width="300" height="600" tabindex="0" class="shadow-glow"></canvas>
        <div class="hud grid w-full max-w-4xl grid-cols-1 gap-4 mx-auto sm:grid-cols-3">
          <div class="panel glass-panel px-6 py-6 text-left">
            <span class="panel-title block text-[0.65rem] uppercase tracking-[0.45em] text-plum/80">Next</span>
            <canvas id="preview" width="160" height="160" class="mx-auto mt-4"></canvas>
          </div>
          <div class="panel glass-panel px-6 py-6 text-left sm:col-span-2">
            <span class="panel-title block text-[0.65rem] uppercase tracking-[0.45em] text-plum/80">Training Progress</span>
            <canvas
              id="score-plot"
              width="420"
              height="220"
              class="mx-auto mt-4 h-[220px] w-full max-w-[420px]"
            ></canvas>
          </div>
          <div class="glass-panel px-6 py-6 text-center sm:col-span-3 flex flex-col items-center gap-3">
            <div id="level" class="text-xs uppercase tracking-[0.45em] text-plum/70">Level: 0</div>
            <div
              id="score"
              class="text-4xl font-display text-citron drop-shadow-[0_14px_35px_rgba(244,247,121,0.35)]"
            >
              Score: 0
            </div>
          </div>
        </div>
      </div>
      <section class="flex w-full max-w-3xl flex-col items-center gap-5">
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <button id="toggle" class="icon-btn" title="Play/Pause" aria-label="Play/Pause">▶</button>
          <button id="reset" class="icon-btn icon-btn--emerald" title="Reset" aria-label="Reset">⟲</button>
        </div>
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <button
            id="train"
            class="icon-btn icon-btn--violet"
            title="Start/Stop Training"
            aria-label="Start/Stop Training"
          >
            AI
          </button>
          <button
            id="train-reset"
            class="icon-btn icon-btn--emerald"
            title="Reset Training"
            aria-label="Reset Training"
          >
            ♻️
          </button>
        </div>
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <label for="model-select" class="text-xs uppercase tracking-[0.35em] text-plum/70">Model:</label>
          <select id="model-select" class="bg-transparent text-base font-display">
            <option value="linear" selected>Linear (ES)</option>
            <option value="mlp">MLP (tf.js)</option>
          </select>
          <button
            id="render-toggle"
            class="icon-btn icon-btn--violet icon-btn--wide"
            title="Show/Hide Game During Training"
            aria-label="Show or Hide Game"
          >
            Hide Game
          </button>
        </div>
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <label for="speed" id="speed-label" class="text-xs uppercase tracking-[0.35em] text-plum/70">
            Speed: <span id="speed-display" class="text-citron">1x</span>
          </label>
          <input id="speed" type="range" min="1" max="50" value="1" class="w-60 md:w-72 accent-citron" />
        </div>
      </section>
      <section class="mt-6 w-full max-w-5xl space-y-6">
        <div id="train-status" class="text-center text-xs uppercase tracking-[0.45em] text-mint/70"></div>
        <div id="weights-display" class="text-center text-sm text-plum/70"></div>
        <div id="network-viz" aria-label="Network weight visualization" class="glass-panel mx-auto h-[260px] w-full overflow-hidden p-6"></div>
        <div
          id="diagnostics"
          aria-live="polite"
          class="glass-panel mx-auto h-[240px] w-full max-w-5xl overflow-y-auto p-6 text-left text-sm leading-relaxed text-shell/80"
        ></div>
      </section>
      <section class="w-full max-w-5xl">
        <div class="glass-panel mx-auto mt-8 w-full space-y-6 rounded-3xl px-6 py-8 text-left">
          <div>
            <span class="text-xs uppercase tracking-[0.45em] text-plum/70">Feature Engineering</span>
            <h2 class="mt-2 text-2xl font-display text-citron">Model Inputs Explained</h2>
            <p class="mt-3 text-sm leading-relaxed text-plum/80">
              Each candidate placement is simulated and summarized by handcrafted features before being scored by the linear or
              MLP policy. These descriptors capture board safety, line clears, and surface texture so the agent can balance
              clearing lines with maintaining a stable stack.
            </p>
          </div>
          <dl class="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt class="font-semibold text-shell">Lines</dt>
              <dd class="text-sm text-plum/80">Normalized count of cleared lines after the drop (lines ÷ 4).</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Lines²</dt>
              <dd class="text-sm text-plum/80">Square of cleared lines scaled by 16, rewarding multi-line clears.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Single Clear</dt>
              <dd class="text-sm text-plum/80">Indicator that exactly one row was removed by the placement.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Double Clear</dt>
              <dd class="text-sm text-plum/80">Indicator for clearing exactly two lines at once.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Triple Clear</dt>
              <dd class="text-sm text-plum/80">Indicator for clearing exactly three simultaneous lines.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Tetris</dt>
              <dd class="text-sm text-plum/80">Indicator capturing a four-line clear produced by the move.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Holes</dt>
              <dd class="text-sm text-plum/80">Fraction of empty cells trapped beneath blocks within each column.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Bumpiness</dt>
              <dd class="text-sm text-plum/80">Normalized sum of height differences between adjacent columns.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Max Height</dt>
              <dd class="text-sm text-plum/80">Tallest column height scaled by the board height.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Well Sum</dt>
              <dd class="text-sm text-plum/80">Total depth of wells (columns lower than both neighbors) normalized by board area.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Edge Wells</dt>
              <dd class="text-sm text-plum/80">Deepest left or right edge indentation relative to its lone neighbor.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Contact</dt>
              <dd class="text-sm text-plum/80">Normalized surface area where blocks touch neighbors or the floor.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Row Transitions</dt>
              <dd class="text-sm text-plum/80">Horizontal filled-to-empty transitions counted across each row.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Col Transitions</dt>
              <dd class="text-sm text-plum/80">Vertical filled-to-empty transitions counted down each column.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Aggregate Height</dt>
              <dd class="text-sm text-plum/80">Sum of all column heights normalized by the playable area.</dd>
            </div>
          </dl>
        </div>
      </section>
    </main>
    <script>
      // --- Minimal Tetris in plain JavaScript (no PyScript) ---
      (function () {
        const canvas = document.getElementById('canvas');
        const preview = document.getElementById('preview');
        const diag = document.getElementById('diagnostics');
        const MAX_LOG_LINES = 200;
        const trainStatus = document.getElementById('train-status');
        const weightsEl = document.getElementById('weights-display');
        const networkVizEl = document.getElementById('network-viz');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const ctx = canvas.getContext('2d');
        const pctx = preview.getContext('2d');
        const CELL = 30, WIDTH = 10, HEIGHT = 20;
        const PREV_CELL = 28; // slightly smaller cell for preview
        const BOARD_BG = '#1b1839';
        const GRID_LINE = 'rgba(255, 255, 255, 0.08)';
        const PREVIEW_BG = '#1f1b3d';
        const PREVIEW_BORDER = 'rgba(255, 255, 255, 0.18)';
        const PREVIEW_GRID = 'rgba(255, 255, 255, 0.16)';
        // Performance tuning caps
        const MAX_AI_STEPS_PER_FRAME = 64;
        const speedSlider = document.getElementById('speed');
        const speedDisplay = document.getElementById('speed-display');
        let speedMult = 1;
        if (speedSlider) {
          speedSlider.addEventListener('input', () => {
            speedMult = Number(speedSlider.value);
            if (speedDisplay) speedDisplay.textContent = `${speedMult}x`;
            if (state.running) {
              clearTimeout(state.raf);
              scheduleNext();
            }
          });
        }

        const log = (t) => {
          if (!diag) return;
          const d = document.createElement('div');
          const now = new Date().toLocaleTimeString();
          d.textContent = `[${now}] ${t}`;
          diag.prepend(d);
          // Trim log to avoid unbounded DOM growth
          while (diag.childElementCount > MAX_LOG_LINES) {
            diag.removeChild(diag.lastChild);
          }
        };

        const Shapes = {
          I: [[0,0],[0,1],[0,2],[0,3]],
          O: [[0,0],[0,1],[1,0],[1,1]],
          T: [[0,0],[0,1],[0,2],[1,1]],
          S: [[0,1],[0,2],[1,0],[1,1]],
          Z: [[0,0],[0,1],[1,1],[1,2]],
          J: [[0,0],[1,0],[1,1],[1,2]],
          L: [[0,2],[1,0],[1,1],[1,2]],
        };

        const rotate = (state) => {
          const rot = state.map(([r,c]) => [c, -r]);
          let minR = Math.min(...rot.map(([r]) => r));
          let minC = Math.min(...rot.map(([,c]) => c));
          return rot.map(([r,c]) => [r - minR, c - minC]);
        };

        const genRotations = (s) => {
          const r = [s];
          for (let i=0;i<3;i++) r.push(s = rotate(s));
          return r;
        };

        const SHAPES = {};
        for (const k of Object.keys(Shapes)) SHAPES[k] = genRotations(Shapes[k]);

        const emptyGrid = () => Array.from({length: HEIGHT}, () => Array(WIDTH).fill(0));

        // Level speed table roughly matching classic NES Tetris
        const LEVEL_FRAMES = {
          0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6,
          10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2,
          20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1
        };
        const gravityForLevel = (lvl) => {
          const frames = LEVEL_FRAMES[Math.min(lvl,29)];
          return (frames/60)*1000; // convert frames to ms
        };

        class Piece {
          constructor(shape){ this.shape = shape; this.rot = 0; this.row = 0; this.col = Math.floor(WIDTH/2) - 2; }
          blocks(){ const s = SHAPES[this.shape][this.rot]; return s.map(([dr,dc]) => [this.row+dr, this.col+dc]); }
          move(dx,dy){ this.col += dx; this.row += dy; }
          rotate(dir=1){ const states = SHAPES[this.shape]; this.rot = (this.rot + (dir>=0?1:states.length-1)) % states.length; }
        }

        const canMove = (grid, piece, dx, dy) => {
          for(const [r,c] of piece.blocks()){
            const nr = r + dy, nc = c + dx;
            if (nr < 0 || nr >= HEIGHT || nc < 0 || nc >= WIDTH) return false;
            if (grid[nr][nc] !== 0) return false;
          }
          return true;
        };

        const lock = (grid, piece) => { for(const [r,c] of piece.blocks()) grid[r][c] = piece.shape; };

        const clearRows = (grid) => {
          let remaining = grid.filter(row => row.some(v => v===0));
          const cleared = HEIGHT - remaining.length;
          while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0));
          for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r];
          return cleared;
        };

        const SHAPE_COLORS = {
          I: '#4cc9f0',
          O: '#f2e963',
          T: '#7a5bff',
          S: '#7ae48b',
          Z: '#ff6f76',
          J: '#4a6cff',
          L: '#ff9f66',
        };

        const hexToRgb = (hex) => {
          if (!hex) return null;
          const normalized = hex.replace('#', '');
          const expand = normalized.length === 3
            ? normalized.split('').map((c) => c + c).join('')
            : normalized;
          if (expand.length !== 6) return null;
          const r = parseInt(expand.slice(0, 2), 16);
          const g = parseInt(expand.slice(2, 4), 16);
          const b = parseInt(expand.slice(4, 6), 16);
          if ([r, g, b].some((v) => Number.isNaN(v))) return null;
          return [r, g, b];
        };

        const rgbToHex = (rgb) => {
          if (!rgb) return null;
          return (
            '#'
            + rgb
                .map((v) => {
                  const clamped = Math.max(0, Math.min(255, Math.round(v)));
                  return clamped.toString(16).padStart(2, '0');
                })
                .join('')
          );
        };

        const mixColor = (hex, mixHex, weight = 0.5) => {
          const base = hexToRgb(hex);
          const mix = hexToRgb(mixHex);
          if (!base || !mix) return hex;
          const w = Math.max(0, Math.min(1, weight));
          const blended = base.map((v, idx) => v * (1 - w) + mix[idx] * w);
          return rgbToHex(blended) || hex;
        };

        const lightenHex = (hex, amount = 0.25) => mixColor(hex, '#ffffff', amount);
        const darkenHex = (hex, amount = 0.25) => mixColor(hex, '#000000', amount);

        const paintBlock = (context, color, x, y, size, options = {}) => {
          const { shadow = true, stroke = GRID_LINE } = options;
          const gradient = context.createLinearGradient(x, y, x + size, y + size);
          gradient.addColorStop(0, lightenHex(color, 0.35));
          gradient.addColorStop(0.5, color);
          gradient.addColorStop(1, darkenHex(color, 0.2));
          context.save();
          context.fillStyle = gradient;
          if (shadow) {
            context.shadowColor = lightenHex(color, 0.35);
            context.shadowBlur = 8;
          }
          context.fillRect(x, y, size, size);
          if (shadow) {
            context.shadowBlur = 0;
          }
          context.strokeStyle = stroke;
          context.strokeRect(x, y, size, size);
          context.restore();
        };

        function draw(grid, active){
          try {
            if(window.__train && window.__train.enabled && window.__train.visualizeBoard === false){
              return; // skip board rendering in training fast mode
            }
          } catch(_) {}
          ctx.fillStyle = BOARD_BG;
          ctx.fillRect(0,0,WIDTH*CELL,HEIGHT*CELL);
          ctx.lineWidth = 1.2;
          // locked
          for(let r=0;r<HEIGHT;r++){
            for(let c=0;c<WIDTH;c++){
              const val = grid[r][c];
              const x = c*CELL;
              const y = r*CELL;
              if(val){
                const color = SHAPE_COLORS[val] || '#6c7dd9';
                paintBlock(ctx, color, x, y, CELL, { shadow: false });
              } else {
                ctx.strokeStyle = GRID_LINE;
                ctx.strokeRect(x, y, CELL, CELL);
              }
            }
          }
          // active
          if(active){
            const color = SHAPE_COLORS[active.shape] || '#6c7dd9';
            for(const [r,c] of active.blocks()){
              paintBlock(ctx, color, c*CELL, r*CELL, CELL, { shadow: true });
            }
          }
        }

        function drawNext(shape){
          try {
            if(window.__train && window.__train.enabled && window.__train.visualizeBoard === false){
              return; // skip preview rendering in training fast mode
            }
          } catch(_) {}
          const W = preview.width, H = preview.height;
          pctx.fillStyle = PREVIEW_BG;
          pctx.fillRect(0,0,W,H);
          pctx.strokeStyle = PREVIEW_BORDER;
          pctx.strokeRect(0,0,W,H);
          if(!shape) return;
          const state = SHAPES[shape][0];
          let minR=Infinity, minC=Infinity, maxR=-Infinity, maxC=-Infinity;
          for(const [r,c] of state){ minR=Math.min(minR,r); minC=Math.min(minC,c); maxR=Math.max(maxR,r); maxC=Math.max(maxC,c); }
          const w = (maxC-minC+1)*PREV_CELL; const h = (maxR-minR+1)*PREV_CELL;
          const offX = Math.floor((W - w)/2); const offY = Math.floor((H - h)/2);
          for(const [r,c] of state){
            const x = offX + (c-minC)*PREV_CELL;
            const y = offY + (r-minR)*PREV_CELL;
            const color = SHAPE_COLORS[shape] || '#6c7dd9';
            paintBlock(pctx, color, x, y, PREV_CELL, { shadow: false, stroke: PREVIEW_GRID });
          }
        }

        // Record cleared line counts for training fitness (safe no-op if training is off)
        function recordClear(lines){
          try {
            const tr = window.__train;
            if(tr && tr.enabled){
              if(!tr.clearCounts) tr.clearCounts = {1:0,2:0,3:0,4:0};
              if(lines>=1 && lines<=4){ tr.clearCounts[lines] = (tr.clearCounts[lines]||0) + 1; }
            }
          } catch(_) { /* ignore */ }
        }

        function isHeadlessTrainingActive(){
          try {
            const tr = window.__train;
            return !!(tr && tr.enabled && tr.visualizeBoard === false);
          } catch (_) {
            return false;
          }
        }

        function updateScore(force){
          if(!force && isHeadlessTrainingActive()) return;
          if(scoreEl) scoreEl.textContent = `Score: ${state.score}`;
        }
        function updateLevel(force){
          if(!force && isHeadlessTrainingActive()) return;
          if(levelEl) levelEl.textContent = `Level: ${state.level}`;
        }

        const state = { grid: emptyGrid(), active: null, next: null, score: 0, level:0, pieces:0, running:false, paused:false, last:0, acc:0, gravity:gravityForLevel(0), raf:null, wdAcc:0, lastSig:'', renderEvery:1, renderCounter:0 };

        const shapes = Object.keys(SHAPES);
        function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=arr[i]; arr[i]=arr[j]; arr[j]=t; } return arr; }
        let bag = [];
        const drawFromBag = () => { if(bag.length===0){ bag = shuffle(shapes.slice()); } return bag.pop(); };

        const spawn = () => { const s = state.next || drawFromBag(); state.active = new Piece(s); state.next = drawFromBag(); drawNext(state.next); updateScore(); updateLevel(); };

        // Robust game-over trigger used by outer loop/inputs.
        // Delegates to window.__onGameOver if available; otherwise, performs a minimal safe reset.
        function triggerGameOver(){
          try {
            if (typeof window.__onGameOver === 'function') {
              return window.__onGameOver();
            }
          } catch (_) { /* fall through to fallback */ }
          // Fallback: minimal reset so the loop can continue gracefully
          try {
            log('Game over (fallback). Resetting.');
          } catch(_) {}
          Object.assign(state, { grid: emptyGrid(), active: null, next: null, score: 0, level: 0, pieces: 0 });
          state.gravity = gravityForLevel(0);
          updateLevel();
          updateScore();
          spawn();
        }

        const scheduleNext = () => {
          // Run the main loop at a steady ~60 FPS; speed multiplier is applied
          // inside the loop by scaling the effective delta time.
          let delay = 1000 / 60;
          try {
            const tr = window.__train;
            if (tr && tr.enabled && tr.visualizeBoard === false) {
              delay = 0;
            }
          } catch (_) {}
          state.raf = setTimeout(() => tick(performance.now()), delay);
        };

        function updateRenderDecimation(){
          // Default: draw every frame; this can be expanded later to skip frames
          state.renderEvery = 1;
          state.renderCounter = 0;
        }

        function tick(ts){
          try {
            if(!state.running){ return; }
            if(!state.last) state.last = ts;
            const dt = ts - state.last; state.last = ts;
            let effDt = dt * speedMult;
            try {
              const tr = window.__train;
              if(tr && tr.enabled && tr.visualizeBoard === false){
                effDt = dt;
              }
            } catch(_) {}
            // Watchdog: detect lack of progress for > 2s wall time and reset
            const curSig = state.active ? `${state.active.shape}:${state.active.rot}:${state.active.row}:${state.active.col}:${state.score}:${state.pieces}` : `none:${state.score}:${state.pieces}`;
            if(curSig === state.lastSig){ state.wdAcc += dt; } else { state.wdAcc = 0; state.lastSig = curSig; }
            if(state.wdAcc > 2000 && !state.paused){ log('Watchdog: no progress for 2s -> game over'); triggerGameOver(); state.wdAcc = 0; }
            // Fallback: ensure there is always an active piece when running
            if(!state.paused && !state.active){
              spawn();
              if(!canMove(state.grid, state.active, 0, 0)) { log('Tick: spawned into block -> game over'); triggerGameOver(); return; }
            }
            if(!state.paused && state.active){
              // Global guard: if the active piece cannot exist at its current
              // position (e.g., spawn collision), trigger game over/reset.
              if(!canMove(state.grid, state.active, 0, 0)){
                log('Tick: spawn blocked -> game over');
                triggerGameOver();
                return;
              }
              if(window.__train && window.__train.enabled){
                window.__aiStep(effDt);
              } else {
                state.acc += effDt;
                while(state.acc >= state.gravity){
                  state.acc -= state.gravity;
                  if(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                  else {
                    lock(state.grid, state.active);
                    state.pieces++;
                    if(state.pieces % 20 === 0){
                      state.level++;
                      state.gravity = gravityForLevel(state.level);
                      updateLevel();
                    }
                    const cleared = clearRows(state.grid);
                    if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                    // Top-out guard after lock/clear in manual mode
                    if(state.grid[0].some(v => v !== 0)) { triggerGameOver(); }
                else {
                  spawn();
                      if(!canMove(state.grid, state.active, 0, 0)){ triggerGameOver(); }
                  }
                  }
                }
              }
            }
          } catch (e) {
            try { log(`Tick error: ${e && e.message ? e.message : e}`); } catch(_) {}
            try { triggerGameOver(); } catch(_) {}
          } finally {
            try {
              if(state.renderEvery <= 1){
                draw(state.grid, state.active);
              } else {
                if(state.renderCounter <= 0){
                  draw(state.grid, state.active);
                  state.renderCounter = state.renderEvery - 1;
                } else {
                  state.renderCounter -= 1;
                }
              }
            } catch(_) {}
            scheduleNext();
          }
        }

        function start(){ if(state.running){ log('Already running'); return; } canvas.focus(); state.grid = emptyGrid(); state.score=0; state.level=0; state.pieces=0; state.gravity=gravityForLevel(0); updateScore(); updateLevel(); state.last=0; state.acc=0; state.wdAcc=0; state.lastSig=''; state.running=true; state.paused=false; updateRenderDecimation(); spawn(); draw(state.grid, state.active); scheduleNext(); log('Game started'); renderControls(); }
        function pause(){ if(!state.running){ log('Pause ignored: not running'); return; } state.paused=true; log('Paused'); }
        function resume(){ if(!state.running){ log('Resume ignored: not running'); return; } state.paused=false; log('Resumed'); }
        function stop(){ if(!state.running){ log('Stop ignored: not running'); return; } state.running=false; state.paused=false; if(state.raf) clearTimeout(state.raf); state.raf=null; log('Game stopped'); renderControls(); }

        // Toggle + reset controls
        const toggleBtn = document.getElementById('toggle');
        const resetBtn = document.getElementById('reset');
        function renderControls(){
          if(!toggleBtn) return;
          const showPauseIcon = state.running && !state.paused;
          toggleBtn.textContent = showPauseIcon ? '⏸' : '▶';
          toggleBtn.classList.toggle('icon-btn--emerald', showPauseIcon);
        }
        function togglePlayPause(){ if(!state.running){ start(); } else if(state.paused){ resume(); } else { pause(); } renderControls(); }
        function resetGame(){ if(state.running){ stop(); } start(); }

        // keyboard
        const BLOCK_KEYS = new Set(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','PageUp','PageDown','Home','End']);
        document.addEventListener('keydown', (e) => {
          if(!state.running) return;
          if (BLOCK_KEYS.has(e.key)) e.preventDefault();
          if(state.paused || !state.active || (window.__train && window.__train.enabled)) return;
          if(e.key==='ArrowLeft' && canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0);
          else if(e.key==='ArrowRight' && canMove(state.grid, state.active, 1, 0)) state.active.move(1,0);
          else if(e.key==='ArrowUp'){ state.active.rotate(); if(!canMove(state.grid, state.active, 0, 0)) state.active.rotate(-1); }
          else if(e.key==='ArrowDown' && canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
          else if(e.key===' '){
            while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
            lock(state.grid, state.active);
            state.pieces++;
            if(state.pieces % 20 === 0){
              state.level++;
              state.gravity = gravityForLevel(state.level);
              updateLevel();
            }
            const cleared = clearRows(state.grid);
            if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared);} 
            if(state.grid[0].some(v => v !== 0)) { triggerGameOver(); }
            else { spawn(); if(!canMove(state.grid, state.active, 0, 0)) triggerGameOver(); }
          }
          draw(state.grid, state.active);
        });

        // buttons
        toggleBtn.addEventListener('click', togglePlayPause);
        resetBtn.addEventListener('click', resetGame);

        log('Ready. Click Start to run.');
        renderControls();

        // ================= AI Training (placement-level with animation) =================
        // Expose minimal API on window to avoid invasive edits above
        (function(){
          // Features (scaled):
          const FEATURE_NAMES = [
            'Lines',
            'Lines²',
            'Single Clear',
            'Double Clear',
            'Triple Clear',
            'Tetris',
            'Holes',
            'Bumpiness',
            'Max Height',
            'Well Sum',
            'Edge Wells',
            'Contact',
            'Row Transitions',
            'Col Transitions',
            'Aggregate Height',
          ];
          const FEAT_DIM = FEATURE_NAMES.length;
          const AI_STEP_MS = 28; // ms between AI animation steps
          const LOOKAHEAD_LAMBDA = 0.7; // weight for next-piece lookahead score
          const LOOKAHEAD_BEAM = 6; // evaluate next-piece lookahead only for top-K first moves
          const SCORE_WEIGHT = 3.0; // emphasize final score in fitness

          // MLP architecture (when selected)
          const MLP_H1 = 8; // hidden units (small for speed)
          const MLP_PARAM_DIM = FEAT_DIM*MLP_H1 + MLP_H1 + MLP_H1*1 + 1; // W1 + b1 + W2 + b2

          // Numeric dtype for weight arrays
          const HAS_F16 = (typeof Float16Array !== 'undefined');
          const DEFAULT_DTYPE = HAS_F16 ? 'f16' : 'f32';
          function allocWeights(n, dtype){ return (dtype==='f16' && HAS_F16) ? new Float16Array(n) : new Float32Array(n); }
          // Safe default allocator before `train` exists (avoid TDZ issues)
          let newWeightArray = (n) => allocWeights(n, DEFAULT_DTYPE);

          // Initial weights for Linear model (intentionally poor to make the very first attempt worse)
          // Order: [lines, lines2, is1, is2, is3, is4, holes, bumpiness, maxH, wellSum, edgeWell, contact, rowTrans, colTrans, aggH]
          const INITIAL_MEAN_LINEAR_BASE = [0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.4, 0.2, 0.1, 0.1, 0.0, 0.0, 0.1, 0.1, 0.2];
          const INITIAL_STD_LINEAR_BASE  = new Array(FEAT_DIM).fill(0.4);
          const INITIAL_MEAN_MLP_BASE    = new Array(MLP_PARAM_DIM).fill(0.0);
          const INITIAL_STD_MLP_BASE     = new Array(MLP_PARAM_DIM).fill(0.2);

          function paramDim(){ return (train && train.modelType === 'mlp') ? MLP_PARAM_DIM : FEAT_DIM; }
          function makeTyped(vals){ const arr = newWeightArray(vals.length); for(let i=0;i<vals.length;i++) arr[i]=vals[i]; return arr; }
          function initialMean(model){ return model === 'mlp' ? makeTyped(INITIAL_MEAN_MLP_BASE) : makeTyped(INITIAL_MEAN_LINEAR_BASE); }
          function initialStd(model){ return model === 'mlp' ? makeTyped(INITIAL_STD_MLP_BASE) : makeTyped(INITIAL_STD_LINEAR_BASE); }

          function sliceSegment(arr, start, end){
            if(!arr) return null;
            if(typeof arr.subarray === 'function'){
              return arr.subarray(start, end);
            }
            return arr.slice(start, end);
          }

          function inferLayerSizesFromWeights(weights, override){
            const inputDim = FEATURE_NAMES.length;
            if(Array.isArray(override) && override.length >= 2){
              return override.slice();
            }
            if(!weights || !weights.length){
              return [inputDim, 1];
            }
            const total = weights.length;
            const cache = new Map();

            function dfs(offset, prev){
              if(offset === total){
                return [];
              }
              const key = `${offset}|${prev}`;
              if(cache.has(key)) return cache.get(key);
              const remaining = total - offset;

              if(remaining % prev === 0){
                const outSize = remaining / prev;
                const seq = [outSize];
                cache.set(key, seq);
                return seq;
              }

              const maxNext = Math.floor(remaining / (prev + 1));
              for(let next = maxNext; next >= 1; next--){
                const need = prev * next + next;
                if(need > remaining) continue;
                const rest = dfs(offset + need, next);
                if(rest){
                  const seq = [next, ...rest];
                  cache.set(key, seq);
                  return seq;
                }
              }
              cache.set(key, null);
              return null;
            }

            const seq = dfs(0, inputDim);
            if(seq){
              return [inputDim, ...seq];
            }
            if(total === inputDim){
              return [inputDim, 1];
            }
            if(total === inputDim + 1){
              return [inputDim, 1];
            }
            return [inputDim, 1];
          }

          function sliceWeightMatrices(weights, layerSizes){
            const slices = [];
            if(!weights || !layerSizes || layerSizes.length < 2) return slices;
            let offset = 0;
            const totalLen = weights.length || 0;
            for(let layer = 1; layer < layerSizes.length; layer++){
              const prev = layerSizes[layer - 1];
              const curr = layerSizes[layer];
              const weightCount = prev * curr;
              const matrix = sliceSegment(weights, offset, offset + weightCount);
              offset += weightCount;
              let bias = null;
              if(offset + curr <= totalLen){
                bias = sliceSegment(weights, offset, offset + curr);
                offset += curr;
              }
              slices.push({ weights: matrix, bias });
            }
            return slices;
          }

          function renderNetworkD3(weights, overrideLayerSizes){
            if(!networkVizEl || typeof d3 === 'undefined'){
              return;
            }
            const width = networkVizEl.clientWidth || 320;
            const height = networkVizEl.clientHeight || 220;
            const marginX = 52;
            const marginY = 28;

            let svg = d3.select(networkVizEl).select('svg');
            if(svg.empty()){
              svg = d3.select(networkVizEl)
                .append('svg')
                .attr('role', 'img')
                .attr('aria-label', 'Visualization of model weights')
                .attr('preserveAspectRatio', 'xMidYMid meet');
            }
            svg
              .attr('width', width)
              .attr('height', height)
              .attr('viewBox', `0 0 ${width} ${height}`);
            svg.selectAll('*').remove();

            if(!weights || !weights.length){
              svg.append('text')
                .attr('x', width / 2)
                .attr('y', height / 2)
                .attr('text-anchor', 'middle')
                .attr('fill', '#888')
                .text('Weights unavailable');
              return;
            }

            const layerSizes = inferLayerSizesFromWeights(weights, overrideLayerSizes);
            const slices = sliceWeightMatrices(weights, layerSizes);
            const totalLayers = layerSizes.length;
            const innerWidth = Math.max(width - 2 * marginX, 10);
            const innerHeight = Math.max(height - 2 * marginY, 10);

            const nodes = [];
            const nodeLookup = new Map();
            for(let layerIdx = 0; layerIdx < totalLayers; layerIdx++){
              const layerSize = layerSizes[layerIdx];
              const x = totalLayers === 1 ? width / 2 : marginX + (innerWidth * layerIdx) / Math.max(1, totalLayers - 1);
              const step = layerSize > 1 ? innerHeight / (layerSize - 1) : 0;
              const biasSlice = layerIdx > 0 && slices[layerIdx - 1] ? slices[layerIdx - 1].bias : null;
              for(let i = 0; i < layerSize; i++){
                const y = layerSize > 1 ? marginY + step * i : height / 2;
                const id = `${layerIdx}-${i}`;
                const label = layerIdx === 0
                  ? (FEATURE_NAMES[i] || `x${i + 1}`)
                  : (layerIdx === totalLayers - 1
                    ? (layerSize === 1 ? 'Output' : `y${i + 1}`)
                    : `h${layerIdx}-${i + 1}`);
                const biasVal = (biasSlice && biasSlice.length > i) ? biasSlice[i] : null;
                const node = { id, layer: layerIdx, index: i, x, y, label, bias: biasVal };
                nodes.push(node);
                nodeLookup.set(id, node);
              }
            }

            const edges = [];
            for(let layerIdx = 1; layerIdx < layerSizes.length; layerIdx++){
              const prev = layerSizes[layerIdx - 1];
              const curr = layerSizes[layerIdx];
              const slice = slices[layerIdx - 1];
              const matrix = slice && slice.weights ? slice.weights : null;
              for(let i = 0; i < prev; i++){
                for(let j = 0; j < curr; j++){
                  const wIdx = matrix ? (i * curr + j) : null;
                  const weightValue = (matrix && wIdx !== null && wIdx < matrix.length) ? matrix[wIdx] : 0;
                  edges.push({
                    source: nodeLookup.get(`${layerIdx - 1}-${i}`),
                    target: nodeLookup.get(`${layerIdx}-${j}`),
                    weight: weightValue,
                  });
                }
              }
            }

            const maxAbs = edges.length ? d3.max(edges, (d) => Math.abs(d.weight)) : 0;
            const denom = (maxAbs && Number.isFinite(maxAbs) && maxAbs > 0) ? maxAbs : 1;

            const edgeGroup = svg.append('g').attr('class', 'edges');
            const edgeSel = edgeGroup.selectAll('line')
              .data(edges)
              .enter()
              .append('line')
              .attr('x1', (d) => d.source ? d.source.x : 0)
              .attr('y1', (d) => d.source ? d.source.y : 0)
              .attr('x2', (d) => d.target ? d.target.x : 0)
              .attr('y2', (d) => d.target ? d.target.y : 0)
              .attr('stroke', (d) => (d.weight >= 0 ? '#2b8cbe' : '#d7301f'))
              .attr('stroke-width', (d) => {
                const norm = Math.min(1, Math.abs(d.weight) / denom);
                return 0.6 + norm * 3.4;
              })
              .attr('stroke-opacity', (d) => {
                const norm = Math.min(1, Math.abs(d.weight) / denom);
                return 0.2 + norm * 0.8;
              });
            edgeSel.append('title').text((d) => `w=${d.weight.toFixed(3)}`);

            const nodeGroup = svg.append('g').attr('class', 'nodes');
            const nodeSel = nodeGroup.selectAll('g')
              .data(nodes)
              .enter()
              .append('g')
              .attr('transform', (d) => `translate(${d.x}, ${d.y})`);

            nodeSel.append('circle')
              .attr('r', 10)
              .attr('fill', '#fff')
              .attr('stroke', '#555')
              .attr('stroke-width', 1.2);

            nodeSel.append('text')
              .attr('text-anchor', (d) => {
                if(d.layer === 0) return 'end';
                if(d.layer === totalLayers - 1) return 'start';
                return 'middle';
              })
              .attr('x', (d) => {
                if(d.layer === 0) return -14;
                if(d.layer === totalLayers - 1) return 14;
                return 0;
              })
              .attr('dy', 4)
              .text((d) => d.label);

            nodeSel.append('title').text((d) => {
              if(d.layer === 0){
                return d.label;
              }
              if(typeof d.bias === 'number' && Number.isFinite(d.bias)){
                return `${d.label} (bias ${d.bias.toFixed(3)})`;
              }
              return d.label;
            });
          }

          const train = {
            enabled: false,
            gen: 0,
            popSize: 16,
            eliteFrac: 0.25,
            modelType: 'linear',
            dtype: DEFAULT_DTYPE,
            mean: initialMean('linear'),
            std: initialStd('linear'),
            minStd: 0.05,
            maxStd: 3.0,
            candWeights: [],
            candScores: [],
            candIndex: -1,
            phase: 'eval',
            reevalRuns: 3,
            reevalDone: 0,
            reevalAccum: 0,
            reevalTarget: -1,
            // Visualization + speed controls for training
            visualizeBoard: true,      // if false: skip board/preview rendering
            fastStepsPerFrame: 2048,   // cap for AI steps per frame when visualizeBoard=false
            currentWeightsOverride: null,
            ai: { plan: null, acc: 0 },
            clearCounts: {1:0,2:0,3:0,4:0},
            gameScores: [],
            gameModelTypes: [],
            bestFitness: -Infinity,
            bestEverFitness: -Infinity,
            bestEverWeights: null,
            genNoImprove: 0,
            // exploration config
            heavyTailFrac: 0.25,
            heavyTailScale: 3.0,
            plateauGens: 8,
            stdBoost: 1.8,
            maxPlotPoints: 4000,
          };
          window.__train = train;
          // After `train` exists, honor train.dtype for future allocations
          newWeightArray = (n) => allocWeights(n, (train && train.dtype) ? train.dtype : DEFAULT_DTYPE);

          function formatWeights(arr){ const MAX_SHOW = 24; const vals = Array.from(arr).slice(0, MAX_SHOW).map(v=>Number.isFinite(v)?v.toFixed(2):String(v)); const suffix = arr.length>MAX_SHOW? ' …' : ''; return vals.join(', ') + suffix; }
          function updateTrainStatus(){
            if(trainStatus){
              if(train.enabled){
                trainStatus.textContent = `Gen ${train.gen+1}, Candidate ${train.candIndex+1}/${train.popSize} — Model: ${train.modelType.toUpperCase()}`;
              } else {
                trainStatus.textContent = `Training stopped — Model: ${train.modelType.toUpperCase()}`;
              }
            }
            let currentWeights = null;
            if(train.currentWeightsOverride){
              currentWeights = train.currentWeightsOverride;
            } else if(train.enabled && train.candIndex >= 0 && train.candIndex < train.candWeights.length){
              currentWeights = train.candWeights[train.candIndex];
            } else if(train.mean){
              currentWeights = train.mean;
            }
            if(weightsEl){
              weightsEl.textContent = currentWeights ? `Weights: ${formatWeights(currentWeights)}` : '';
            }
            try {
              renderNetworkD3(currentWeights);
            } catch (_) {
              /* ignore render failures */
            }
          }

          function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
          function samplePopulation(){
            const dim = paramDim();
            train.candWeights = [];
            const heavyPairs = Math.floor((train.heavyTailFrac * train.popSize)/2);
            const half = Math.floor(train.popSize/2);
            const baseNoises = new Array(half);
            for(let j=0;j<half;j++){
              const eps = new Float32Array(dim);
              for(let d=0; d<dim; d++) eps[d] = randn();
              baseNoises[j] = eps;
            }
            for(let i=0;i<train.popSize;i++){
              const pair = (i<half) ? i : (i-half);
              const sign = (i<half) ? 1.0 : -1.0;
              const w = newWeightArray(dim);
              const pairScale = (pair < heavyPairs) ? train.heavyTailScale : 1.0;
              for(let d=0; d<dim; d++){
                const stdv = (train.std[d] || train.minStd) * pairScale;
                w[d] = train.mean[d] + sign * stdv * baseNoises[pair][d];
              }
              train.candWeights.push(w);
            }
            // Ensure the very first attempt (gen 0, cand 0) uses the mean weights (intentionally poor)
            if(train.gen === 0 && train.candWeights.length > 0){
              const dim0 = train.mean.length; const m = newWeightArray(dim0); for(let d=0; d<dim0; d++) m[d]=train.mean[d];
              train.candWeights[0] = m;
            }
            train.candScores = new Array(train.popSize).fill(0);
            train.candIndex = 0;
            train.clearCounts = {1:0,2:0,3:0,4:0};
          }

          function startTraining(){
            if(!state.running){ start(); }
            train.enabled = true; train.gen = 0; train.ai.plan = null; train.ai.acc = 0; samplePopulation();
            train.gameScores = [];
            train.phase = 'eval'; train.currentWeightsOverride = null; train.reevalDone = 0; train.reevalAccum = 0; train.reevalTarget = -1;
            updateTrainStatus();
            const btn = document.getElementById('train');
            if(btn){
              btn.textContent = '⏹';
              btn.classList.remove('icon-btn--violet');
              btn.classList.add('icon-btn--emerald');
            }
            log('Training started');
          }
          function stopTraining(){
            train.enabled = false;
            train.ai.plan = null;
            const btn = document.getElementById('train');
            if(btn){
              btn.textContent = 'AI';
              btn.classList.remove('icon-btn--emerald');
              btn.classList.add('icon-btn--violet');
            }
            log('Training stopped');
            updateTrainStatus();
          }
          function resetTraining(){
            stopTraining();
            // Reset mean/std based on selected model
            train.mean = initialMean(train.modelType);
            train.std = initialStd(train.modelType);
            train.gen = 0;
            train.candWeights = [];
            train.candScores = [];
            train.candIndex = -1;
            train.ai.plan = null;
            train.ai.acc = 0;
            train.clearCounts = {1:0,2:0,3:0,4:0};
            train.gameScores = [];
            train.phase = 'eval'; train.currentWeightsOverride = null; train.reevalDone = 0; train.reevalAccum = 0; train.reevalTarget = -1; train.bestFitness = -Infinity; train.bestEverFitness = -Infinity; train.bestEverWeights = null;
            updateScorePlot();
            updateTrainStatus();
            log('Training parameters reset');
          }
          window.startTraining = startTraining; window.stopTraining = stopTraining; window.resetTraining = resetTraining;

          function onGameOver(){
            log('Game over. Resetting.');
            if(train.enabled){
              // Shaped fitness: prefer multi-line clears and discourage singles
              const c = train.clearCounts || {1:0,2:0,3:0,4:0};
              const c1 = c[1] || 0, c2 = c[2] || 0, c3 = c[3] || 0, c4 = c[4] || 0;
              const fitness = SCORE_WEIGHT*state.score + 100*(4*c4 + 2*c3 + 1*c2) - 100*c1;
              if(train.candIndex >= 0) train.candScores[train.candIndex] = fitness;
              // Append raw score for progress plot and mark model type
              train.gameScores.push(state.score);
              train.gameModelTypes.push(train.modelType);
              // Cap data arrays to bound memory
              const cap = train.maxPlotPoints;
              if (train.gameScores.length > cap) {
                train.gameScores.splice(0, train.gameScores.length - cap);
                train.gameModelTypes.splice(0, train.gameModelTypes.length - cap);
              }
              updateScorePlot();
              // Re-evaluation phase handling
              if(train.phase === 'reeval'){
                train.reevalAccum += fitness; train.reevalDone += 1;
                if(train.reevalDone < train.reevalRuns){
                  Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                  state.gravity = gravityForLevel(0);
                  updateLevel(); updateScore();
                  spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                  updateTrainStatus();
                  return;
                } else {
                  const avgFit = train.reevalAccum / train.reevalRuns;
                  if(train.reevalTarget >= 0) train.candScores[train.reevalTarget] = avgFit;
                  train.currentWeightsOverride = null; train.phase = 'eval';
                  // Complete generation update after re-eval with rank-weighted elites
                  const idx = [...train.candScores.keys()].sort((a,b)=>train.candScores[b]-train.candScores[a]);
                  const eliteCount = Math.max(1, Math.floor(train.eliteFrac * train.popSize));
                  const elites = idx.slice(0, eliteCount);
                  const dim = paramDim();
                  const wsum = eliteCount*(eliteCount+1)/2;
                  const eliteMean = newWeightArray(dim);
                  for(let r=0;r<elites.length;r++){
                    const ei = elites[r]; const wCand = train.candWeights[ei]; const wRank = (eliteCount - r)/wsum;
                    for(let d=0; d<dim; d++) eliteMean[d] += wRank * wCand[d];
                  }
                  const mu = 0.3; const bestW = train.candWeights[idx[0]];
                  const newMean = newWeightArray(dim);
                  for(let d=0; d<dim; d++) newMean[d] = (1-mu)*eliteMean[d] + mu*bestW[d];
                  const newStd = newWeightArray(dim);
                  for(let r=0;r<elites.length;r++){
                    const ei = elites[r]; const wCand = train.candWeights[ei]; const wRank = (eliteCount - r)/wsum;
                    for(let d=0; d<dim; d++){ const diff=wCand[d]-eliteMean[d]; newStd[d]+= wRank*diff*diff; }
                  }
                  for(let d=0; d<dim; d++) newStd[d] = Math.max(train.minStd, Math.min(train.maxStd, Math.sqrt(newStd[d])));
                  const bestThisGen = train.candScores[idx[0]];
                  if(bestThisGen > (train.bestEverFitness ?? -Infinity)){
                    train.bestEverFitness = bestThisGen; train.bestEverWeights = new Float64Array(train.candWeights[idx[0]]);
                  }
                  if(bestThisGen > train.bestFitness){ for(let d=0; d<newStd.length; d++) newStd[d] = Math.max(train.minStd, newStd[d] * 0.85); train.bestFitness = bestThisGen; train.genNoImprove = 0; }
                  else { train.genNoImprove += 1; if(train.genNoImprove >= train.plateauGens){ for(let d=0; d<newStd.length; d++) newStd[d] = Math.min(train.maxStd, newStd[d] * train.stdBoost); train.genNoImprove = 0; log('Plateau detected: boosted exploration std'); } }
                  train.mean = newMean; train.std = newStd; train.gen += 1; log(`Gen ${train.gen} complete. Best fitness: ${bestThisGen}`);
                  samplePopulation();
                  // Elitist carryover
                  if(train.candWeights.length>0){ const copy0 = newWeightArray(bestW.length); for(let d=0; d<bestW.length; d++) copy0[d]=bestW[d]; train.candWeights[0] = copy0; }
                  if(train.bestEverWeights && train.candWeights.length>1){ const be = train.bestEverWeights; const copy1=newWeightArray(be.length); for(let d=0; d<be.length; d++) copy1[d]=be[d]; train.candWeights[1] = copy1; }
                  Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                  state.gravity = gravityForLevel(0);
                  updateLevel(); updateScore();
                  spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                  updateScorePlot();
                  log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                  updateTrainStatus();
                  return;
                }
              }
              if(train.candIndex + 1 < train.popSize){
                train.candIndex += 1;
                Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                state.gravity = gravityForLevel(0);
                updateLevel(); updateScore();
                spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                updateTrainStatus();
              } else {
              // Start re-evaluation of best-of-gen before updating population
              const idx = [...train.candScores.keys()].sort((a,b)=>train.candScores[b]-train.candScores[a]);
              const bestIdx = idx[0];
              train.phase = 'reeval'; train.reevalTarget = bestIdx; train.reevalDone = 0; train.reevalAccum = 0; train.currentWeightsOverride = new Float64Array(train.candWeights[bestIdx]);
              Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
              state.gravity = gravityForLevel(0);
              updateLevel(); updateScore();
              spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
              updateTrainStatus();
              return;
              }
            } else {
              Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
              state.gravity = gravityForLevel(0);
              updateLevel(); updateScore();
              spawn();
            }
          }
          window.__onGameOver = onGameOver;

          function uniqueRotIdx(shape){ const states = SHAPES[shape]; const seen = new Set(); const out=[]; for(let i=0;i<states.length;i++){ const key = JSON.stringify(states[i].slice().sort()); if(!seen.has(key)){ seen.add(key); out.push(i); } } return out; }
          function stateWidth(state){ let maxC=0; for(const [,c] of state) if(c>maxC) maxC=c; return maxC+1; }
          function copyGrid(g){ return g.map(r=>r.slice()); }
          function dropRowSim(grid, piece){ if(!canMove(grid,piece,0,0)) return null; while(canMove(grid,piece,0,1)) piece.move(0,1); return piece.row; }

          // Approximate delay between horizontal moves in ms, used to estimate
          // how many sideways shifts are possible before a gravity drop.
          const HORIZONTAL_MOVE_INTERVAL_MS = 100;

          // Return true if a piece can reach (rot, col) from spawn under gravity.
          function pathClear(grid, shape, rot, col, level){
            // Start from spawn
            const spawnCol = Math.floor(WIDTH/2) - 2;
            const piece = new Piece(shape);
            piece.row = 0; piece.col = spawnCol; piece.rot = 0;

            // Try rotate-at-spawn step-by-step
            const statesLen = SHAPES[shape].length;
            const rotSteps = (rot - piece.rot + statesLen) % statesLen;
            for(let i=0; i<rotSteps; i++){
              piece.rotate();
              if(!canMove(grid, piece, 0, 0)) return false;
            }

            // Compute the final resting row from the target column/rotation
            const target = new Piece(shape);
            target.row = 0; target.col = col; target.rot = rot;
            const finalRow = dropRowSim(grid, target);
            if(finalRow === null) return false;

            // If already in the right column, ensure vertical path is clear
            if(col === piece.col){
              while(piece.row < finalRow){
                if(!canMove(grid, piece, 0, 1)) return false;
                piece.move(0, 1);
              }
              return true;
            }

            // Level 29: treat as instant drop (no horizontal movement)
            if(level >= 29) return false;

            // Estimate how many horizontal moves fit per gravity tick
            const gravity = gravityForLevel(level);
            const movesPerRow = Math.max(1, Math.floor(gravity / HORIZONTAL_MOVE_INTERVAL_MS));

            // Translate toward target column under gravity
            while(piece.col !== col){
              // Gravity first
              if(!canMove(grid, piece, 0, 1)) return false;
              piece.move(0, 1);

              const dir = (col > piece.col) ? 1 : -1;
              const steps = Math.min(movesPerRow, Math.abs(col - piece.col));
              for(let s=0; s<steps; s++){
                if(!canMove(grid, piece, dir, 0)) return false;
                piece.move(dir, 0);
              }
            }

            // Finish dropping to the final row
            while(piece.row < finalRow){
              if(!canMove(grid, piece, 0, 1)) return false;
              piece.move(0, 1);
            }
            return true;
          }

          function enumeratePlacements(grid, shape){
            const actions=[]; const rotIdx=uniqueRotIdx(shape);
            for(const rot of rotIdx){
              const width=stateWidth(SHAPES[shape][rot]);
              for(let col=0; col<=WIDTH-width; col++){
                const p=new Piece(shape); p.rot=rot; p.row=0; p.col=col;
                const fr=dropRowSim(grid,p);
                if(fr!==null && pathClear(grid, shape, rot, col, state.level)) actions.push({rot,col});
              }
            }
            return actions;
          }
          function lockSim(grid, piece){ for(const [r,c] of piece.blocks()) grid[r][c]=1; }
          function clearRowsSim(grid){ let remaining = grid.filter(row => row.some(v => v===0)); const cleared = HEIGHT - remaining.length; while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0)); for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r]; return cleared; }
          function columnHeights(grid){ const h=Array(WIDTH).fill(0); for(let c=0;c<WIDTH;c++){ let r=0; while(r<HEIGHT && grid[r][c]===0) r++; h[c]=HEIGHT-r; } return h; }
          function countHoles(grid){ let holes=0; for(let c=0;c<WIDTH;c++){ let seen=false; for(let r=0;r<HEIGHT;r++){ const v=grid[r][c]; if(v){ seen=true; } else if(seen){ holes++; } } } return holes; }
          function bumpiness(heights){ let b=0; for(let c=0;c<WIDTH-1;c++) b+=Math.abs(heights[c]-heights[c+1]); return b; }
          function wellMetrics(heights){ let wellSum=0; let edgeWell=0; for(let c=0;c<WIDTH;c++){ let left = (c>0)?heights[c-1]:Infinity; let right = (c<WIDTH-1)?heights[c+1]:Infinity; let minNbr = Math.min(left,right); let depth = minNbr - heights[c]; if(depth>0) wellSum += depth; if(c===0) edgeWell = Math.max(edgeWell, right - heights[0]); if(c===WIDTH-1) edgeWell = Math.max(edgeWell, left - heights[WIDTH-1]); } return {wellSum, edgeWell: Math.max(0, edgeWell)}; }
          function contactArea(g){ let contact=0; for(let r=0;r<HEIGHT;r++){ for(let c=0;c<WIDTH;c++){ if(!g[r][c]) continue; // bottom
                if(r===HEIGHT-1 || g[r+1][c]) contact++; // left
                if(c>0 && g[r][c-1]) contact++; // right
                if(c<WIDTH-1 && g[r][c+1]) contact++; } } return contact; }
          function rowTransitions(g){ let t=0; for(let r=0;r<HEIGHT;r++){ let prev=0; for(let c=0;c<WIDTH;c++){ const cur = g[r][c]?1:0; if(cur!==prev) t++; prev=cur; } if(prev!==0) t++; } return t; }
          function colTransitions(g){ let t=0; for(let c=0;c<WIDTH;c++){ let prev=0; for(let r=0;r<HEIGHT;r++){ const cur = g[r][c]?1:0; if(cur!==prev) t++; prev=cur; } if(prev!==0) t++; } return t; }
          function simulateAfterPlacement(grid, shape, rot, col){ const g=copyGrid(grid); const p=new Piece(shape); p.rot=rot; p.row=0; p.col=col; const fr=dropRowSim(g,p); if(fr===null) return null; p.row=fr; lockSim(g,p); const lines=clearRowsSim(g); return {grid:g, lines}; }
          function featuresFromGrid(g, lines){ const h=columnHeights(g); const Holes=countHoles(g); const Bump=bumpiness(h); const maxH=Math.max(...h); const {wellSum, edgeWell}=wellMetrics(h); const Contact=contactArea(g); const rT=rowTransitions(g); const cT=colTransitions(g); const aggH=h.reduce((a,b)=>a+b,0);
            // Scaling
            const sLines = lines/4; const sLines2=(lines*lines)/16; const sHoles=Holes/(WIDTH*HEIGHT); const sBump=Bump/((WIDTH-1)*HEIGHT); const sMaxH=maxH/HEIGHT; const sWell=wellSum/(WIDTH*HEIGHT); const sEdge=edgeWell/HEIGHT; const sContact=Contact/(WIDTH*HEIGHT*2); const sRT=rT/(WIDTH*HEIGHT); const sCT=cT/(WIDTH*HEIGHT); const sAgg=aggH/(WIDTH*HEIGHT);
            const is1=lines===1?1:0, is2=lines===2?1:0, is3=lines===3?1:0, is4=lines===4?1:0;
            return [sLines, sLines2, is1, is2, is3, is4, sHoles, sBump, sMaxH, sWell, sEdge, sContact, sRT, sCT, sAgg]; }
          function featuresForPlacement(grid, shape, rot, col){ const sim=simulateAfterPlacement(grid, shape, rot, col); if(!sim) return null; const feats = featuresFromGrid(sim.grid, sim.lines); return { feats, lines: sim.lines, grid: sim.grid } }
          function dot(weights, feats){ let s=0; for(let d=0; d<FEAT_DIM; d++) s+=weights[d]*feats[d]; return s; }
          function scorePlacement(weights, grid, shape, act){ const ff=featuresForPlacement(grid, shape, act.rot, act.col); if(!ff) return -Infinity; return dot(weights, ff.feats); }
          function choosePlacement(weights, grid, shape){ const acts=enumeratePlacements(grid, shape); if(acts.length===0) return null; let best=acts[0], bestS=-Infinity; for(const a of acts){ const s=scorePlacement(weights, grid, shape, a); if(s>bestS){ bestS=s; best=a; } } return best; }
          function mlpScore(weights, feats){
            // weights layout: [W1 (FEAT_DIM*H1), b1 (H1), W2 (H1), b2 (1)]
            const H = MLP_H1;
            const W1 = weights.subarray(0, FEAT_DIM*H);
            const b1 = weights.subarray(FEAT_DIM*H, FEAT_DIM*H + H);
            const W2 = weights.subarray(FEAT_DIM*H + H, FEAT_DIM*H + H + H);
            const b2 = weights[FEAT_DIM*H + H + H];
            // Manual forward (faster than tf.js per-placement)
            const h = new Float64Array(H);
            for(let j=0;j<H;j++){
              let sum = b1[j];
              for(let i=0;i<FEAT_DIM;i++) sum += feats[i] * W1[i*H + j];
              h[j] = sum > 0 ? sum : 0;
            }
            let y = b2;
            for(let j=0;j<H;j++) y += h[j] * W2[j];
            return y;
          }
          function scoreFeats(weights, feats){ return (train.modelType === 'mlp') ? mlpScore(weights, feats) : dot(weights, feats); }
          function choosePlacement2(weights, grid, curShape, nextShape){ const acts=enumeratePlacements(grid, curShape); if(acts.length===0) return null; let best=acts[0], bestS=-Infinity; const sims=[]; // precompute first-ply sims and scores
            for(const a of acts){ const sim=simulateAfterPlacement(grid, curShape, a.rot, a.col); if(!sim) continue; const baseFeats = featuresFromGrid(sim.grid, sim.lines); const s1 = scoreFeats(weights, baseFeats); sims.push({a, sim, s1}); }
            if(sims.length===0) return null;
            // Beam: consider lookahead only for top-K first-ply moves
            sims.sort((u,v)=>v.s1 - u.s1);
            const K = Math.min(LOOKAHEAD_BEAM, sims.length);
            const acts2Cache = new WeakMap();
            for(let i=0;i<sims.length;i++){
              let s = sims[i].s1;
              if(nextShape && i < K){ let acts2 = acts2Cache.get(sims[i].sim.grid); if(!acts2){ acts2 = enumeratePlacements(sims[i].sim.grid, nextShape); acts2Cache.set(sims[i].sim.grid, acts2); } if(acts2.length>0){ let best2=-Infinity; for(const a2 of acts2){ const ff2=featuresForPlacement(sims[i].sim.grid, nextShape, a2.rot, a2.col); if(!ff2) continue; const s2=scoreFeats(weights, ff2.feats); if(s2>best2) best2=s2; } if(isFinite(best2)) s += LOOKAHEAD_LAMBDA*best2; }
              }
              if(s>bestS){ bestS=s; best=sims[i].a; }
            }
            return best; }

          function planForCurrentPiece(){ if(!state.active) return null; const w = train.currentWeightsOverride || train.candWeights[train.candIndex] || train.mean; const a=choosePlacement2(w, state.grid, state.active.shape, state.next); if(!a){ return null; } const len=SHAPES[state.active.shape].length; const cur=state.active.rot % len; const needRot=(a.rot - cur + len) % len; return { targetRot:a.rot, targetCol:a.col, rotLeft:needRot, stage:'rotate' }; }

          // Scatter plot of raw score per game (all candidates)
          function updateScorePlot(){
            const canvas = document.getElementById('score-plot');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            ctx.clearRect(0,0,W,H);
            const padL=22, padB=16, padR=6, padT=6;
            // axes
            ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padL, H-padB); ctx.lineTo(W-padR, H-padB);
            ctx.moveTo(padL, H-padB); ctx.lineTo(padL, padT);
            ctx.stroke();
            const scores = (window.__train && window.__train.gameScores) ? window.__train.gameScores : [];
            const types  = (window.__train && window.__train.gameModelTypes) ? window.__train.gameModelTypes : [];
            if(!scores || scores.length===0) return;
            const maxY = Math.max(1000, Math.max(...scores));
            const xw = (W - padL - padR), yh = (H - padT - padB);
            ctx.fillStyle = '#666'; ctx.font = '10px sans-serif';
            ctx.fillText('0', 4, H-padB+10);
            ctx.fillText(String(maxY), 2, padT+8);
            const COLORS = { linear: '#1f77b4', mlp: '#ff7f0e' };
            for(let i=0;i<scores.length;i++){
              const x = padL + (scores.length<=1?0:(i/(scores.length-1)))*xw;
              const y = H - padB - (scores[i]/maxY)*yh;
              const t = types[i] || 'linear';
              ctx.fillStyle = COLORS[t] || '#1f77b4';
              ctx.fillRect(Math.round(x)-1, Math.round(y)-1, 3, 3);
            }
          }

          function runAiMicroStep(){
            if(!state.active){ return false; }

            // Watchdog: if the active piece hasn't changed state for a while, force a drop
            const sig = `${state.active.shape}:${state.active.rot}:${state.active.row}:${state.active.col}:${state.score}`;
            if(train.ai.lastSig === sig){ train.ai.staleMs = (train.ai.staleMs || 0) + AI_STEP_MS; } else { train.ai.staleMs = 0; train.ai.lastSig = sig; }
            if(train.ai.staleMs > 1000){
              log('AI: watchdog forced drop');
              while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
              lock(state.grid, state.active);
              state.pieces++;
              if(state.pieces % 20 === 0){ state.level++; state.gravity = gravityForLevel(state.level); updateLevel(); }
              const cleared = clearRows(state.grid);
              if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
              if(state.grid[0].some(v => v !== 0)) {
                onGameOver();
                train.ai.plan = null;
                train.ai.staleMs = 0;
                return false;
              }
              spawn();
              train.ai.plan = null;
              train.ai.staleMs = 0;
              if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
              return false;
            }

            if(!train.ai.plan){
              train.ai.plan = planForCurrentPiece();
              if(!train.ai.plan){
                // force drop to end episode
                while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                lock(state.grid, state.active);
                state.pieces++;
                if(state.pieces % 20 === 0){
                  state.level++;
                  state.gravity = gravityForLevel(state.level);
                  updateLevel();
                }
                const cleared = clearRows(state.grid);
                if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                if(state.grid[0].some(v => v !== 0)) {
                  log('AI: top-out after forced drop');
                  onGameOver();
                  return false;
                }
                spawn();
                if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
                return false;
              }
            }
            const plan = train.ai.plan; if(!plan) return true;
            if(plan.stage==='rotate'){
              if(plan.rotLeft>0){
                state.active.rotate();
                if(!canMove(state.grid, state.active, 0, 0)){
                  // Rotation blocked: abandon this plan to avoid stalling
                  state.active.rotate(-1);
                  train.ai.plan = null; log('AI: rotation blocked, abandoning plan');
                } else {
                  plan.rotLeft -= 1;
                }
                return true;
              }
              plan.stage='move'; return true;
            }
            if(plan.stage==='move'){
              if(state.active.col < plan.targetCol){ if(canMove(state.grid, state.active, 1, 0)) state.active.move(1,0); else plan.stage='drop'; return true; }
              if(state.active.col > plan.targetCol){ if(canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0); else plan.stage='drop'; return true; }
              plan.stage='drop'; return true;
            }
            if(plan.stage==='drop'){
              if(canMove(state.grid, state.active, 0, 1)){ state.active.move(0,1); return true; }
              lock(state.grid, state.active);
              state.pieces++;
              if(state.pieces % 20 === 0){
                state.level++;
                state.gravity = gravityForLevel(state.level);
                updateLevel();
              }
              const cleared = clearRows(state.grid);
              if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
              if(state.grid[0].some(v => v !== 0)) {
                log('AI: top-out after drop');
                onGameOver();
                train.ai.plan = null;
                return false;
              }
              spawn();
              train.ai.plan = null;
              if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
              return false;
            }
            return true;
          }

          function aiStep(dt){
            if(!state.active){ return; }
            if(!canMove(state.grid, state.active, 0, 0)) { log('AI: spawn blocked -> game over'); onGameOver(); return; }

            const fastMode = train && train.enabled && train.visualizeBoard === false;
            const __limit = fastMode ? train.fastStepsPerFrame : MAX_AI_STEPS_PER_FRAME;
            let __aiSteps = 0;

            if(fastMode){
              train.ai.acc = 0;
              while(__aiSteps < __limit){
                __aiSteps += 1;
                if(!runAiMicroStep()){
                  return;
                }
              }
              return;
            }

            train.ai.acc += dt;
            while (train.ai.acc >= AI_STEP_MS && __aiSteps < __limit) {
              train.ai.acc -= AI_STEP_MS;
              __aiSteps += 1;
              if(!runAiMicroStep()){
                return;
              }
            }
          }
          window.__aiStep = aiStep;

          // Hook up training buttons
          const trainBtn = document.getElementById('train');
          if(trainBtn){ trainBtn.addEventListener('click', () => { if(train.enabled) stopTraining(); else startTraining(); }); }
          const trainResetBtn = document.getElementById('train-reset');
          if(trainResetBtn){ trainResetBtn.addEventListener('click', resetTraining); }
          const renderToggleBtn = document.getElementById('render-toggle');
          function updateRenderToggleBtn(){
            if(!renderToggleBtn) return;
            const label = train.visualizeBoard ? 'Hide Game' : 'Show Game';
            renderToggleBtn.textContent = label;
            renderToggleBtn.setAttribute('aria-label', label);
            renderToggleBtn.title = train.visualizeBoard
              ? 'Hide Game During Training'
              : 'Show Game During Training';
          }
          if(renderToggleBtn){
            renderToggleBtn.addEventListener('click', () => {
              train.visualizeBoard = !train.visualizeBoard;
              updateRenderToggleBtn();
              // When re-enabling visualization, draw current state immediately
              if(train.visualizeBoard){
                try { draw(state.grid, state.active); drawNext(state.next); } catch(_) {}
                updateScore(true); updateLevel(true);
              }
            });
          }
          updateRenderToggleBtn();
          const modelSel = document.getElementById('model-select');
          function setModelType(mt){
            if(mt !== 'linear' && mt !== 'mlp') return;
            const wasRunning = train.enabled;
            if(wasRunning) stopTraining();
            train.modelType = mt;
            // Prefer f16 for MLP if available, else f32
            train.dtype = (mt==='mlp' && HAS_F16) ? 'f16' : 'f32';
            // Re-init mean/std to the appropriate initial values for this model
            train.mean = initialMean(mt);
            train.std  = initialStd(mt);
            updateTrainStatus();
            // Reset training state
            resetTraining();
            if(wasRunning) startTraining();
          }
          if(modelSel){ modelSel.addEventListener('change', (e) => setModelType(modelSel.value)); }
          updateTrainStatus();
        })();
      })();
    </script>
  </body>
</html>

