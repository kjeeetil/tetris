<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self' https://pyscript.net https://cdn.jsdelivr.net https://cdn.tailwindcss.com https://ga.jspm.io data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://pyscript.net https://cdn.jsdelivr.net https://cdn.tailwindcss.com https://ga.jspm.io; style-src 'self' 'unsafe-inline' https://pyscript.net https://fonts.googleapis.com; connect-src 'self' https://pyscript.net https://cdn.jsdelivr.net https://cdn.tailwindcss.com https://ga.jspm.io https://fonts.googleapis.com https://fonts.gstatic.com data: blob:; font-src 'self' https://fonts.gstatic.com; img-src 'self' data:;"
    />
    <title>Tetris</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet"
    />
    <script>
      window.tailwind = window.tailwind || {};
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              ink: '#161629',
              iris: '#5E4AE3',
              plum: '#C09FE4',
              citron: '#F4F779',
              fern: '#2F6B49',
              spruce: '#0C3B2E',
              rosewood: '#8C2F39',
              mint: '#8DE1AD',
              shell: '#F9F5FF',
            },
            fontFamily: {
              display: ['"Instrument Serif"', 'serif'],
              body: ['"Instrument Serif"', 'serif'],
            },
            boxShadow: {
              glow: '0 30px 60px rgba(32, 19, 72, 0.4)',
            },
          },
        },
      };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      :root {
        color-scheme: dark;
        --button-gradient: linear-gradient(135deg, #1f6f4d, #4fb272);
        --button-text-color: #f4fff6;
      }
      body {
        position: relative;
        margin: 0;
        min-height: 100vh;
        font-family: "Instrument Serif", serif;
        text-align: center;
        color: #f9f5ff;
        background:
          radial-gradient(120% 120% at 16% 20%, rgba(244, 247, 121, 0.18) 0%, transparent 56%),
          radial-gradient(130% 110% at 84% 12%, rgba(94, 74, 227, 0.28) 0%, transparent 62%),
          radial-gradient(120% 120% at 82% 82%, rgba(141, 225, 173, 0.24) 0%, transparent 68%),
          linear-gradient(135deg, #161629 0%, #241b4b 48%, #0f3b2e 100%);
        overflow-x: hidden;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        background: linear-gradient(135deg, rgba(192, 159, 228, 0.16), rgba(22, 22, 41, 0.62));
        opacity: 0.85;
        mix-blend-mode: screen;
        z-index: -2;
      }
      .aura-shape {
        position: absolute;
        border-radius: 48px;
        filter: drop-shadow(0 30px 60px rgba(17, 17, 31, 0.36));
        z-index: -1;
      }
      .aura-shape--1 {
        top: -96px;
        left: -56px;
        width: 280px;
        height: 320px;
        background: linear-gradient(135deg, rgba(94, 74, 227, 0.82), rgba(192, 159, 228, 0.55));
      }
      .aura-shape--2 {
        top: 180px;
        right: 8%;
        width: 220px;
        height: 220px;
        border-radius: 50%;
        border: 6px solid rgba(244, 247, 121, 0.55);
        background: transparent;
      }
      .aura-shape--3 {
        bottom: -140px;
        left: 12%;
        width: 190px;
        height: 320px;
        background: linear-gradient(180deg, rgba(15, 59, 46, 0.8), rgba(141, 225, 173, 0.45));
        transform: rotate(-12deg);
      }
      .aura-shape--4 {
        bottom: -170px;
        right: -96px;
        width: 360px;
        height: 280px;
        background: linear-gradient(135deg, rgba(140, 47, 57, 0.78), rgba(94, 74, 227, 0.5));
        transform: rotate(18deg);
        border-radius: 60px;
      }
      canvas {
        display: block;
        margin: 0 auto;
        border-radius: 32px;
        border: 2px solid rgba(255, 255, 255, 0.18);
        background: #1c1b32;
      }
      #preview {
        display: block;
      }
      #score-plot {
        display: block;
        border-radius: 28px;
        border: 1px solid rgba(249, 245, 255, 0.16);
        background: linear-gradient(135deg, rgba(12, 59, 46, 0.18), rgba(22, 22, 41, 0.35));
        backdrop-filter: blur(6px);
      }
      #network-viz {
        border-radius: 32px;
        border: 1px solid rgba(255, 255, 255, 0.22);
        background: rgba(12, 59, 46, 0.12);
      }
      #network-viz svg {
        width: 100%;
        height: 100%;
        border-radius: 30px;
      }
      #network-viz text {
        font-size: 10px;
        fill: rgba(249, 245, 255, 0.82);
        pointer-events: none;
      }
      #diagnostics {
        border-radius: 28px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(12, 59, 46, 0.12);
        box-shadow: inset 0 0 0 1px rgba(249, 245, 255, 0.05);
        overflow-y: auto;
        font-family: "Instrument Serif", serif;
      }
      .glass-panel {
        border-radius: 28px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: linear-gradient(135deg, rgba(249, 245, 255, 0.18), rgba(94, 74, 227, 0.08));
        box-shadow: 0 20px 45px rgba(10, 10, 26, 0.35);
      }
      .noscript-alert {
        background: linear-gradient(135deg, rgba(140, 47, 57, 0.24), rgba(249, 245, 255, 0.12));
        border-color: rgba(140, 47, 57, 0.45);
        color: #8c2f39;
        text-shadow: 0 1px 12px rgba(249, 245, 255, 0.35);
      }
      .icon-btn {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 62px;
        height: 62px;
        border-radius: 22px;
        border: none;
        background: var(--button-gradient);
        color: var(--button-text-color);
        font-size: 26px;
        font-weight: 600;
        letter-spacing: 0.04em;
        box-shadow: 0 14px 30px rgba(17, 17, 31, 0.35), inset 0 2px 0 rgba(255, 255, 255, 0.6);
        cursor: pointer;
        transition: transform 0.18s ease, box-shadow 0.2s ease;
      }
      .icon-btn::before {
        content: "";
        position: absolute;
        inset: 4px;
        border-radius: 18px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.52), rgba(255, 255, 255, 0));
        opacity: 0.85;
        pointer-events: none;
      }
      .icon-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 18px 36px rgba(17, 17, 31, 0.38);
      }
      .icon-btn:active {
        transform: translateY(1px) scale(0.97);
        box-shadow: 0 8px 18px rgba(17, 17, 31, 0.4) inset;
      }
      #model-history-slider {
        width: 100%;
        height: 6px;
        margin-top: 4px;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(94, 74, 227, 0.35), rgba(141, 225, 173, 0.55));
        box-shadow: inset 0 1px 0 rgba(249, 245, 255, 0.25);
        outline: none;
        cursor: pointer;
        -webkit-appearance: none;
        appearance: none;
        transition: box-shadow 0.2s ease, opacity 0.2s ease;
      }
      #model-history-slider:focus-visible {
        box-shadow: 0 0 0 3px rgba(94, 74, 227, 0.35);
      }
      #model-history-slider:disabled {
        cursor: not-allowed;
        opacity: 0.35;
      }
      #model-history-slider::-webkit-slider-runnable-track {
        height: 6px;
        border-radius: 999px;
        background: transparent;
      }
      #model-history-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        margin-top: -6px;
        border-radius: 50%;
        border: 2px solid rgba(94, 74, 227, 0.75);
        background: #f9f5ff;
        box-shadow: 0 4px 12px rgba(15, 15, 36, 0.35);
        transition: transform 0.2s ease;
      }
      #model-history-slider::-webkit-slider-thumb:hover {
        transform: scale(1.06);
      }
      #model-history-slider::-moz-range-track {
        height: 6px;
        border-radius: 999px;
        background: transparent;
      }
      #model-history-slider::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(94, 74, 227, 0.75);
        background: #f9f5ff;
        box-shadow: 0 4px 12px rgba(15, 15, 36, 0.35);
        transition: transform 0.2s ease;
      }
      #model-history-slider::-moz-range-thumb:hover {
        transform: scale(1.06);
      }
      .icon-btn--violet,
      .icon-btn--emerald {
        background: var(--button-gradient);
        color: var(--button-text-color);
      }
      .icon-btn--wide {
        width: auto;
        min-width: 150px;
        padding: 0 1.8rem;
        font-size: 18px;
      }
      .control-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.65rem;
        padding: 0.55rem 1.1rem;
        border-radius: 9999px;
        border: 1px solid rgba(249, 245, 255, 0.18);
        background: rgba(12, 59, 46, 0.12);
        box-shadow: inset 0 0 0 1px rgba(249, 245, 255, 0.05);
        font-size: 13px;
        letter-spacing: 0.08em;
        color: rgba(249, 245, 255, 0.72);
        cursor: pointer;
        user-select: none;
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      }
      .control-toggle:hover {
        border-color: rgba(192, 159, 228, 0.45);
        background: rgba(94, 74, 227, 0.16);
      }
      .control-toggle[data-active="true"] {
        background: rgba(94, 74, 227, 0.2);
        border-color: rgba(192, 159, 228, 0.55);
        box-shadow: 0 18px 36px rgba(17, 17, 31, 0.34);
        color: rgba(249, 245, 255, 0.88);
      }
      .control-checkbox {
        width: 18px;
        height: 18px;
        flex-shrink: 0;
        accent-color: #5e4ae3;
        border-radius: 6px;
        border: 1px solid rgba(192, 159, 228, 0.45);
        background: rgba(249, 245, 255, 0.06);
        box-shadow: inset 0 1px 2px rgba(15, 19, 35, 0.4);
        cursor: pointer;
      }
      .control-checkbox:focus-visible {
        outline: 2px solid rgba(244, 247, 121, 0.65);
        outline-offset: 2px;
      }
      .control-toggle__text {
        font-family: "Instrument Serif", serif;
        font-size: 13px;
        letter-spacing: 0.08em;
      }
      select,
      input[type='range'] {
        font-family: "Instrument Serif", serif;
      }
      select {
        background: rgba(249, 245, 255, 0.14);
        border: 1px solid rgba(255, 255, 255, 0.24);
        border-radius: 18px;
        color: #f9f5ff;
        padding: 0.6rem 1rem;
      }
      select:focus {
        outline: none;
        border-color: rgba(244, 247, 121, 0.7);
        box-shadow: 0 0 0 3px rgba(244, 247, 121, 0.25);
      }
      input[type='range'] {
        width: 240px;
        accent-color: #f4f779;
      }
      canvas:focus {
        outline: none;
      }
      @media (min-width: 768px) {
        #canvas,
        #preview {
          margin-left: 0;
          margin-right: 0;
        }
      }
      @media (max-width: 768px) {
        canvas {
          width: min(88vw, 320px);
          height: auto;
        }
        .icon-btn {
          width: 56px;
          height: 56px;
          font-size: 22px;
        }
        .icon-btn--wide {
          min-width: 140px;
          padding: 0 1.5rem;
        }
      }
      /* No external runtimes required; pure JS renderer */
    </style>
  </head>
  <body class="relative min-h-screen overflow-x-hidden font-body antialiased text-shell">
    <div class="aura-shape aura-shape--1"></div>
    <div class="aura-shape aura-shape--2"></div>
    <div class="aura-shape aura-shape--3"></div>
    <div class="aura-shape aura-shape--4"></div>
    <main class="relative z-10 flex flex-col items-center px-6 py-12 md:py-16 gap-12">
      <header class="max-w-3xl text-center">
        <p class="text-xs uppercase tracking-[0.45em] text-plum/70">AUTO ARCADE</p>
        <h1 class="mt-5 text-4xl md:text-6xl font-display text-citron drop-shadow-[0_18px_40px_rgba(94,74,227,0.35)]">
          Tetris Reinforcement Learning Lab
        </h1>
      </header>
      <noscript>
        <div class="glass-panel noscript-alert px-6 py-4 text-base rounded-3xl">
          JavaScript is disabled. Enable it to play.
        </div>
      </noscript>
      <div class="game relative flex w-full max-w-5xl flex-col items-center gap-10">
        <div class="flex w-full max-w-5xl flex-col items-center gap-4 md:flex-row md:items-start md:justify-center md:gap-6">
          <canvas id="canvas" width="300" height="600" tabindex="0" class="shadow-glow"></canvas>
          <div class="flex w-full max-w-sm flex-col items-center gap-6 md:w-auto md:items-start md:gap-8">
            <div class="flex flex-col items-center gap-3 md:items-start">
              <canvas id="preview" width="140" height="140" class="h-[140px] w-[140px]"></canvas>
            </div>
            <div class="flex flex-col items-center gap-2 md:items-start md:text-left">
              <div id="level" class="text-xs uppercase tracking-[0.45em] text-plum/70">Level: 0</div>
              <div
                id="score"
                class="text-4xl font-display text-citron drop-shadow-[0_14px_35px_rgba(244,247,121,0.35)]"
              >
                Score: 0
              </div>
            </div>
          </div>
        </div>
      </div>
      <section class="flex w-full max-w-3xl flex-col items-center gap-5">
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <button id="toggle" class="icon-btn" title="Play/Pause" aria-label="Play/Pause">▶</button>
          <button id="reset" class="icon-btn icon-btn--emerald" title="Reset" aria-label="Reset">⟲</button>
        </div>
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <label for="speed" id="speed-label" class="text-xs uppercase tracking-[0.35em] text-plum/70">
            Speed: <span id="speed-display" class="text-citron">1x</span>
          </label>
          <input id="speed" type="range" min="1" max="50" value="1" class="w-60 md:w-72 accent-citron" />
        </div>
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <label for="model-select" class="text-xs uppercase tracking-[0.35em] text-plum/70">Model:</label>
          <select id="model-select" class="bg-transparent text-base font-display">
            <option value="linear" selected>Linear (ES)</option>
            <option value="mlp">MLP (tf.js)</option>
          </select>
          <label
            id="render-toggle-label"
            class="control-toggle"
            title="Show the training board and preview during evolution (slower)"
            data-active="false"
          >
            <input
              id="render-toggle"
              type="checkbox"
              class="control-checkbox"
              aria-label="Show training (slow)"
            />
            <span class="control-toggle__text">Show training (slow)</span>
          </label>
        </div>
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <button
            id="download-weights"
            class="icon-btn icon-btn--wide"
            title="Download current model weights"
            aria-label="Download current model weights"
          >
            Save Weights
          </button>
          <button
            id="upload-weights-button"
            class="icon-btn icon-btn--violet icon-btn--wide"
            title="Upload weights from a saved file"
            aria-label="Upload model weights"
          >
            Load Weights
          </button>
          <input id="upload-weights" type="file" accept=".txt,.json,text/plain" class="hidden" />
        </div>
        <div
          id="mlp-config"
          class="glass-panel hidden w-full max-w-3xl flex flex-col items-center gap-4 px-4 py-4 text-sm text-plum/70"
        >
          <p class="text-xs uppercase tracking-[0.35em] text-plum/60">MLP Architecture Controls</p>
          <p class="max-w-xl text-center text-[13px] text-plum/60">
            Adjust the multi-layer perceptron policy before or during training. Choose how many hidden layers to use and how many
            neurons should live in each layer; the model and visualisation update instantly.
          </p>
          <div class="flex flex-wrap items-center justify-center gap-3">
            <label for="mlp-hidden-count" class="text-xs uppercase tracking-[0.35em] text-plum/70">Hidden Layers</label>
            <select id="mlp-hidden-count" class="bg-transparent text-base font-display">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
          </div>
          <div id="mlp-layer-controls" class="flex flex-wrap items-center justify-center gap-4"></div>
        </div>
        <div class="controls flex flex-wrap items-center justify-center gap-4">
          <button
            id="start-training"
            class="icon-btn icon-btn--violet icon-btn--wide"
            title="Start training"
            aria-label="Start training"
          >
            Start Training
          </button>
          <button
            id="reset-model"
            class="icon-btn icon-btn--emerald icon-btn--wide"
            title="Reset model parameters"
            aria-label="Reset model parameters"
          >
            Reset Model Parameters
          </button>
        </div>
        <div class="mt-10 flex w-full flex-col items-center gap-4">
          <span class="text-sm uppercase tracking-[0.45em] text-plum/70 md:text-base">Training Progress</span>
          <canvas
            id="score-plot"
            width="520"
            height="240"
            class="h-[240px] w-full max-w-[520px]"
          ></canvas>
        </div>
      </section>
      <section class="mt-6 w-full max-w-5xl space-y-6">
        <div id="train-status" class="text-center text-xs uppercase tracking-[0.45em] text-mint/70"></div>
        <div
          id="model-architecture"
          class="text-center text-sm uppercase tracking-[0.3em] text-plum/60"
          aria-live="polite"
        ></div>
        <div id="network-viz" aria-label="Network weight visualization" class="glass-panel mx-auto h-[260px] w-full overflow-hidden p-6"></div>
        <div class="mx-auto mt-4 w-full max-w-5xl space-y-2">
          <div class="flex items-center justify-between text-xs uppercase tracking-[0.35em] text-plum/70">
            <span>Model history</span>
            <span id="model-history-label" class="text-mint/80" aria-live="polite">Live (current training)</span>
          </div>
          <input
            id="model-history-slider"
            type="range"
            min="0"
            max="0"
            value="0"
            step="1"
            class="w-full"
            aria-label="Scrub through saved best models by generation"
            disabled
          />
          <div id="model-history-meta" class="text-xs text-plum/70">
            Best-of-generation snapshots will appear as training progresses.
          </div>
        </div>
        <div
          id="diagnostics"
          aria-live="polite"
          class="glass-panel mx-auto h-[240px] w-full max-w-5xl overflow-y-auto p-6 text-left text-sm leading-relaxed text-shell/80"
        ></div>
      </section>
      <section class="w-full max-w-5xl">
        <div class="glass-panel mx-auto mt-8 w-full space-y-6 rounded-3xl px-6 py-8 text-left">
          <div>
            <span class="text-xs uppercase tracking-[0.45em] text-plum/70">Feature Engineering</span>
            <h2 class="mt-2 text-2xl font-display text-citron">Model Inputs Explained</h2>
            <p class="mt-3 text-sm leading-relaxed text-plum/80">
              Each candidate placement is simulated and summarized by handcrafted features before being scored by the linear or
              MLP policy. These descriptors capture board safety, line clears, and surface texture so the agent can balance
              clearing lines with maintaining a stable stack.
            </p>
          </div>
          <dl class="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt class="font-semibold text-shell">Lines</dt>
              <dd class="text-sm text-plum/80">Normalized count of cleared lines after the drop (lines ÷ 4).</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Lines²</dt>
              <dd class="text-sm text-plum/80">Square of cleared lines scaled by 16, rewarding multi-line clears.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Single Clear</dt>
              <dd class="text-sm text-plum/80">Indicator that exactly one row was removed by the placement.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Double Clear</dt>
              <dd class="text-sm text-plum/80">Indicator for clearing exactly two lines at once.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Triple Clear</dt>
              <dd class="text-sm text-plum/80">Indicator for clearing exactly three simultaneous lines.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Tetris</dt>
              <dd class="text-sm text-plum/80">Indicator capturing a four-line clear produced by the move.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Holes</dt>
              <dd class="text-sm text-plum/80">Fraction of empty cells trapped beneath blocks within each column.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Bumpiness</dt>
              <dd class="text-sm text-plum/80">Normalized sum of height differences between adjacent columns.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Max Height</dt>
              <dd class="text-sm text-plum/80">Tallest column height scaled by the board height.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Well Sum</dt>
              <dd class="text-sm text-plum/80">Total depth of wells (columns lower than both neighbors) normalized by board area.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Edge Wells</dt>
              <dd class="text-sm text-plum/80">Deepest left or right edge indentation relative to its lone neighbor.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Tetris Well</dt>
              <dd class="text-sm text-plum/80">Depth of the single deepest well when it is unique, scaled by board height.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Contact</dt>
              <dd class="text-sm text-plum/80">Normalized surface area where blocks touch neighbors or the floor.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Row Transitions</dt>
              <dd class="text-sm text-plum/80">Horizontal filled-to-empty transitions counted across each row.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Col Transitions</dt>
              <dd class="text-sm text-plum/80">Vertical filled-to-empty transitions counted down each column.</dd>
            </div>
            <div>
              <dt class="font-semibold text-shell">Aggregate Height</dt>
              <dd class="text-sm text-plum/80">Sum of all column heights normalized by the playable area.</dd>
            </div>
          </dl>
        </div>
      </section>
    </main>
    <script>
      // --- Minimal Tetris in plain JavaScript (no PyScript) ---
      (function () {
        const canvas = document.getElementById('canvas');
        const preview = document.getElementById('preview');
        const diag = document.getElementById('diagnostics');
        const MAX_LOG_LINES = 200;
        const trainStatus = document.getElementById('train-status');
        const architectureEl = document.getElementById('model-architecture');
        const networkVizEl = document.getElementById('network-viz');
        const historySlider = document.getElementById('model-history-slider');
        const historyLabel = document.getElementById('model-history-label');
        const historyMeta = document.getElementById('model-history-meta');
        const mlpConfigEl = document.getElementById('mlp-config');
        const mlpHiddenCountSel = document.getElementById('mlp-hidden-count');
        const mlpLayerControlsEl = document.getElementById('mlp-layer-controls');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const ctx = canvas.getContext('2d');
        const pctx = preview.getContext('2d');
        const WIDTH = 10;
        const HEIGHT = 20;
        const FULL_ROW_MASK = (1 << WIDTH) - 1;
        const DEFAULT_CELL = 30;
        const DEFAULT_PREVIEW_CELL = 28; // slightly smaller cell for preview
        const MIN_CELL_SIZE = 12;
        const SCALE_STEPS = [42, 40, 38, 36, 34, 32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12];
        const MAX_BOARD_WIDTH = SCALE_STEPS[0] * WIDTH;
        let CELL = DEFAULT_CELL;
        let PREV_CELL = DEFAULT_PREVIEW_CELL;
        const BOARD_BG = '#1b1839';
        const GRID_LINE = 'rgba(255, 255, 255, 0.08)';
        const PREVIEW_STROKE = 'rgba(249, 245, 255, 0.6)';
        // Performance tuning caps
        const MAX_AI_STEPS_PER_FRAME = 64;
        const speedSlider = document.getElementById('speed');
        const speedDisplay = document.getElementById('speed-display');
        let speedMult = 1;
        if (speedSlider) {
          speedSlider.addEventListener('input', () => {
            speedMult = Number(speedSlider.value);
            if (speedDisplay) speedDisplay.textContent = `${speedMult}x`;
            if (state.running) {
              clearTimeout(state.raf);
              scheduleNext();
            }
          });
        }

        const computeEffectiveBoardWidth = () => {
          if (!canvas) return DEFAULT_CELL * WIDTH;
          const parent = canvas.parentElement;
          const viewportWidth = Math.max(
            0,
            Math.min(window.innerWidth || 0, document.documentElement ? document.documentElement.clientWidth : 0),
          );
          let effectiveWidth = parent && parent.clientWidth ? parent.clientWidth : 0;
          if (viewportWidth > 0) {
            effectiveWidth = effectiveWidth > 0 ? Math.min(effectiveWidth, viewportWidth) : viewportWidth;
          }
          if (!effectiveWidth || !Number.isFinite(effectiveWidth)) {
            return DEFAULT_CELL * WIDTH;
          }
          return Math.max(MIN_CELL_SIZE * WIDTH, Math.min(MAX_BOARD_WIDTH, effectiveWidth));
        };

        const snapCellSize = (rawCell) => {
          if (!Number.isFinite(rawCell) || rawCell <= 0) {
            return CELL;
          }
          for (const step of SCALE_STEPS) {
            if (rawCell >= step) {
              return step;
            }
          }
          const fallback = Math.max(MIN_CELL_SIZE, Math.floor(rawCell));
          return fallback > 0 ? fallback : MIN_CELL_SIZE;
        };

        const applyCanvasScale = () => {
          if (!canvas || !preview) {
            return false;
          }
          const effectiveWidth = computeEffectiveBoardWidth();
          const rawCell = Math.max(MIN_CELL_SIZE, Math.floor(effectiveWidth / WIDTH));
          const nextCell = snapCellSize(rawCell);
          if (!Number.isFinite(nextCell) || nextCell <= 0) {
            return false;
          }
          const boardChanged = nextCell !== CELL;
          CELL = nextCell;
          PREV_CELL = Math.max(MIN_CELL_SIZE - 2, Math.round(CELL * 0.9));
          const boardWidth = CELL * WIDTH;
          const boardHeight = CELL * HEIGHT;
          if (canvas.width !== boardWidth) {
            canvas.width = boardWidth;
          }
          if (canvas.height !== boardHeight) {
            canvas.height = boardHeight;
          }
          canvas.style.width = `${boardWidth}px`;
          canvas.style.height = `${boardHeight}px`;

          const previewExtent = PREV_CELL * 4 + Math.max(PREV_CELL, 24);
          if (preview.width !== previewExtent) {
            preview.width = previewExtent;
          }
          if (preview.height !== previewExtent) {
            preview.height = previewExtent;
          }
          preview.style.width = `${previewExtent}px`;
          preview.style.height = `${previewExtent}px`;

          return boardChanged;
        };

        const log = (t) => {
          if (!diag) return;
          const d = document.createElement('div');
          const now = new Date().toLocaleTimeString();
          d.textContent = `[${now}] ${t}`;
          diag.prepend(d);
          // Trim log to avoid unbounded DOM growth
          while (diag.childElementCount > MAX_LOG_LINES) {
            diag.removeChild(diag.lastChild);
          }
        };

        const trainingProfiler = createTrainingProfiler();
        window.__trainingProfiler = trainingProfiler;

        function createTrainingProfiler() {
          const stats = new Map();
          const stack = [];
          let enabled = false;
          const now =
            typeof performance !== 'undefined' && typeof performance.now === 'function'
              ? () => performance.now()
              : () => Date.now();

          function start(name) {
            if (!enabled) return null;
            const token = { name, start: now(), children: 0 };
            stack.push(token);
            return token;
          }

          function stop(token) {
            if (!enabled || !token) return 0;
            const end = now();
            const last = stack.pop();
            if (!last || last !== token) {
              stack.length = 0;
              if (typeof console !== 'undefined' && typeof console.warn === 'function') {
                console.warn('Training profiler stack out of sync', token && token.name);
              }
              return 0;
            }
            const elapsed = end - token.start;
            const child = token.children || 0;
            const exclusive = Math.max(0, elapsed - child);
            let stat = stats.get(token.name);
            if (!stat) {
              stat = { count: 0, total: 0, self: 0, min: Infinity, max: 0 };
              stats.set(token.name, stat);
            }
            stat.count += 1;
            stat.total += elapsed;
            stat.self += exclusive;
            if (elapsed < stat.min) stat.min = elapsed;
            if (elapsed > stat.max) stat.max = elapsed;
            if (stack.length) {
              const parent = stack[stack.length - 1];
              parent.children = (parent.children || 0) + elapsed;
            }
            return elapsed;
          }

          function section(name, fn) {
            if (!enabled) return fn();
            const token = start(name);
            try {
              return fn();
            } finally {
              stop(token);
            }
          }

          function summary(options = {}) {
            const sortBy = options.sortBy || 'total';
            const descending = options.descending !== false;
            const limit = typeof options.limit === 'number' ? options.limit : null;
            const rows = [];
            for (const [name, stat] of stats.entries()) {
              const count = stat.count || 0;
              const total = stat.total || 0;
              const selfTime = stat.self || 0;
              const avg = count ? total / count : 0;
              const selfAvg = count ? selfTime / count : 0;
              rows.push({
                name,
                count,
                total,
                self: selfTime,
                average: avg,
                self_average: selfAvg,
                min: stat.min === Infinity ? 0 : stat.min,
                max: stat.max || 0,
              });
            }
            const keyMap = {
              total: (row) => row.total,
              self: (row) => row.self,
              count: (row) => row.count,
              average: (row) => row.average,
              self_average: (row) => row.self_average,
              max: (row) => row.max,
              min: (row) => row.min,
            };
            const keyFn = keyMap[sortBy] || keyMap.total;
            rows.sort((a, b) => {
              const va = keyFn(a);
              const vb = keyFn(b);
              if (va === vb) {
                return a.name.localeCompare(b.name);
              }
              return descending ? vb - va : va - vb;
            });
            return limit !== null && limit >= 0 ? rows.slice(0, limit) : rows;
          }

          function reset() {
            stats.clear();
            stack.length = 0;
          }

          function enable() {
            enabled = true;
          }

          function disable() {
            enabled = false;
            stack.length = 0;
          }

          return {
            enable,
            disable,
            reset,
            summary,
            section,
            start,
            stop,
            get enabled() {
              return enabled;
            },
          };
        }

        function logTrainingProfileSummary(limit = 6) {
          const summary = trainingProfiler.summary({ sortBy: 'total', descending: true, limit });
          const trainState = typeof window !== 'undefined' && window.__train ? window.__train : null;
          if (trainState) {
            trainState.performanceSummary = summary;
          }
          if (!summary.length) {
            log('[Perf] No training performance samples recorded.');
            return summary;
          }
          const parts = summary.map((row) =>
            `${row.name}: total=${row.total.toFixed(2)}ms self=${row.self.toFixed(2)}ms avg=${row.average.toFixed(2)}ms count=${row.count}`,
          );
          log(`[Perf] Hot sections — ${parts.join(' | ')}`);
          if (typeof console !== 'undefined') {
            if (typeof console.table === 'function') {
              const tableRows = summary.map((row) => ({
                Section: row.name,
                Count: row.count,
                'Total (ms)': Number(row.total.toFixed(2)),
                'Self (ms)': Number(row.self.toFixed(2)),
                'Avg (ms)': Number(row.average.toFixed(2)),
                'Self Avg (ms)': Number(row.self_average.toFixed(2)),
                'Min (ms)': Number(row.min.toFixed(2)),
                'Max (ms)': Number(row.max.toFixed(2)),
              }));
              console.table(tableRows);
            } else if (typeof console.log === 'function') {
              console.log('Training performance summary', summary);
            }
          }
          return summary;
        }

        window.logTrainingProfileSummary = logTrainingProfileSummary;

        const Shapes = {
          I: [[0,0],[0,1],[0,2],[0,3]],
          O: [[0,0],[0,1],[1,0],[1,1]],
          T: [[0,0],[0,1],[0,2],[1,1]],
          S: [[0,1],[0,2],[1,0],[1,1]],
          Z: [[0,0],[0,1],[1,1],[1,2]],
          J: [[0,0],[1,0],[1,1],[1,2]],
          L: [[0,2],[1,0],[1,1],[1,2]],
        };

        const rotate = (state) => {
          const rot = state.map(([r,c]) => [c, -r]);
          let minR = Math.min(...rot.map(([r]) => r));
          let minC = Math.min(...rot.map(([,c]) => c));
          return rot.map(([r,c]) => [r - minR, c - minC]);
        };

        const genRotations = (s) => {
          const r = [s];
          for (let i=0;i<3;i++) r.push(s = rotate(s));
          return r;
        };

        const SHAPES = {};
        for (const k of Object.keys(Shapes)) SHAPES[k] = genRotations(Shapes[k]);

        const UNIQUE_ROTATIONS = Object.fromEntries(
          Object.entries(SHAPES).map(([shape, states]) => {
            const seen = new Set();
            const indices = [];
            for (let i = 0; i < states.length; i++) {
              const signature = states[i]
                .map(([r, c]) => `${r},${c}`)
                .sort()
                .join('|');
              if (!seen.has(signature)) {
                seen.add(signature);
                indices.push(i);
              }
            }
            return [shape, indices];
          })
        );

        const emptyGrid = () => Array.from({length: HEIGHT}, () => Array(WIDTH).fill(0));

        // Level speed table roughly matching classic NES Tetris up to level 9
        const LEVEL_FRAMES = {
          0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6
        };
        const gravityForLevel = (lvl) => {
          if (lvl >= 10) return 0;
          const frames = LEVEL_FRAMES[lvl] ?? LEVEL_FRAMES[9];
          return (frames/60)*1000; // convert frames to ms
        };

        class Piece {
          constructor(shape){ this.shape = shape; this.rot = 0; this.row = 0; this.col = Math.floor(WIDTH/2) - 2; }
          blocks(){ const s = SHAPES[this.shape][this.rot]; return s.map(([dr,dc]) => [this.row+dr, this.col+dc]); }
          move(dx,dy){ this.col += dx; this.row += dy; }
          rotate(dir=1){ const states = SHAPES[this.shape]; this.rot = (this.rot + (dir>=0?1:states.length-1)) % states.length; }
        }

        const canMove = (grid, piece, dx, dy) => {
          for(const [r,c] of piece.blocks()){
            const nr = r + dy, nc = c + dx;
            if (nr < 0 || nr >= HEIGHT || nc < 0 || nc >= WIDTH) return false;
            if (grid[nr][nc] !== 0) return false;
          }
          return true;
        };

        const lock = (grid, piece) => { for(const [r,c] of piece.blocks()) grid[r][c] = piece.shape; };

        const clearRows = (grid) => {
          let remaining = grid.filter(row => row.some(v => v===0));
          const cleared = HEIGHT - remaining.length;
          while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0));
          for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r];
          return cleared;
        };

        const SHAPE_COLORS = {
          I: '#4cc9f0',
          O: '#f2e963',
          T: '#7a5bff',
          S: '#7ae48b',
          Z: '#ff6f76',
          J: '#4a6cff',
          L: '#ff9f66',
        };

        const hexToRgb = (hex) => {
          if (!hex) return null;
          const normalized = hex.replace('#', '');
          const expand = normalized.length === 3
            ? normalized.split('').map((c) => c + c).join('')
            : normalized;
          if (expand.length !== 6) return null;
          const r = parseInt(expand.slice(0, 2), 16);
          const g = parseInt(expand.slice(2, 4), 16);
          const b = parseInt(expand.slice(4, 6), 16);
          if ([r, g, b].some((v) => Number.isNaN(v))) return null;
          return [r, g, b];
        };

        const rgbToHex = (rgb) => {
          if (!rgb) return null;
          return (
            '#'
            + rgb
                .map((v) => {
                  const clamped = Math.max(0, Math.min(255, Math.round(v)));
                  return clamped.toString(16).padStart(2, '0');
                })
                .join('')
          );
        };

        const mixColor = (hex, mixHex, weight = 0.5) => {
          const base = hexToRgb(hex);
          const mix = hexToRgb(mixHex);
          if (!base || !mix) return hex;
          const w = Math.max(0, Math.min(1, weight));
          const blended = base.map((v, idx) => v * (1 - w) + mix[idx] * w);
          return rgbToHex(blended) || hex;
        };

        const lightenHex = (hex, amount = 0.25) => mixColor(hex, '#ffffff', amount);
        const darkenHex = (hex, amount = 0.25) => mixColor(hex, '#000000', amount);

        const paintBlock = (context, color, x, y, size, options = {}) => {
          const { shadow = true, stroke = GRID_LINE } = options;
          const gradient = context.createLinearGradient(x, y, x + size, y + size);
          gradient.addColorStop(0, lightenHex(color, 0.35));
          gradient.addColorStop(0.5, color);
          gradient.addColorStop(1, darkenHex(color, 0.2));
          context.save();
          context.fillStyle = gradient;
          if (shadow) {
            context.shadowColor = lightenHex(color, 0.35);
            context.shadowBlur = 8;
          }
          context.fillRect(x, y, size, size);
          if (shadow) {
            context.shadowBlur = 0;
          }
          context.strokeStyle = stroke;
          context.strokeRect(x, y, size, size);
          context.restore();
        };

        function draw(grid, active){
          try {
            if(window.__train && window.__train.enabled && window.__train.visualizeBoard === false){
              return; // skip board rendering when training visualization is disabled
            }
          } catch(_) {}
          ctx.fillStyle = BOARD_BG;
          ctx.fillRect(0,0,WIDTH*CELL,HEIGHT*CELL);
          ctx.lineWidth = 1.2;
          // locked
          for(let r=0;r<HEIGHT;r++){
            for(let c=0;c<WIDTH;c++){
              const val = grid[r][c];
              const x = c*CELL;
              const y = r*CELL;
              if(val){
                const color = SHAPE_COLORS[val] || '#6c7dd9';
                paintBlock(ctx, color, x, y, CELL, { shadow: false });
              } else {
                ctx.strokeStyle = GRID_LINE;
                ctx.strokeRect(x, y, CELL, CELL);
              }
            }
          }
          // active
          if(active){
            const color = SHAPE_COLORS[active.shape] || '#6c7dd9';
            for(const [r,c] of active.blocks()){
              paintBlock(ctx, color, c*CELL, r*CELL, CELL, { shadow: true });
            }
          }
        }

        function drawNext(shape){
          try {
            if(window.__train && window.__train.enabled && window.__train.visualizeBoard === false){
              return; // skip preview rendering when training visualization is disabled
            }
          } catch(_) {}
          const W = preview.width, H = preview.height;
          pctx.clearRect(0, 0, W, H);
          if(!shape) return;
          const state = SHAPES[shape][0];
          let minR=Infinity, minC=Infinity, maxR=-Infinity, maxC=-Infinity;
          for(const [r,c] of state){ minR=Math.min(minR,r); minC=Math.min(minC,c); maxR=Math.max(maxR,r); maxC=Math.max(maxC,c); }
          const w = (maxC-minC+1)*PREV_CELL; const h = (maxR-minR+1)*PREV_CELL;
          const offX = Math.floor((W - w)/2); const offY = Math.floor((H - h)/2);
          for(const [r,c] of state){
            const x = offX + (c-minC)*PREV_CELL;
            const y = offY + (r-minR)*PREV_CELL;
            const color = SHAPE_COLORS[shape] || '#6c7dd9';
            paintBlock(pctx, color, x, y, PREV_CELL, { shadow: false, stroke: PREVIEW_STROKE });
          }
        }

        // Legacy stub: line-clear tracking was only needed for shaped fitness
        function recordClear(){ /* no-op */ }

        function isHeadlessTrainingActive(){
          try {
            const tr = window.__train;
            return !!(tr && tr.enabled && tr.visualizeBoard === false);
          } catch (_) {
            return false;
          }
        }

        function updateScore(force){
          if(!force && isHeadlessTrainingActive()) return;
          if(scoreEl) scoreEl.textContent = `Score: ${state.score}`;
        }
        function updateLevel(force){
          if(!force && isHeadlessTrainingActive()) return;
          if(levelEl) levelEl.textContent = `Level: ${state.level}`;
        }

        const state = { grid: emptyGrid(), active: null, next: null, score: 0, level:0, pieces:0, running:false, paused:false, last:0, acc:0, gravity:gravityForLevel(0), raf:null, wdAcc:0, lastSig:'', renderEvery:1, renderCounter:0 };

        applyCanvasScale();
        draw(state.grid, state.active);
        drawNext(state.next);

        requestAnimationFrame(() => {
          if (applyCanvasScale()) {
            draw(state.grid, state.active);
            drawNext(state.next);
          }
        });

        const scheduleScaleUpdate = (() => {
          let rafId = null;
          return () => {
            if (rafId !== null) {
              cancelAnimationFrame(rafId);
            }
            rafId = requestAnimationFrame(() => {
              rafId = null;
              if (applyCanvasScale()) {
                draw(state.grid, state.active);
                drawNext(state.next);
              }
            });
          };
        })();

        window.addEventListener('resize', scheduleScaleUpdate, { passive: true });
        if (window.visualViewport && typeof window.visualViewport.addEventListener === 'function') {
          window.visualViewport.addEventListener('resize', scheduleScaleUpdate, { passive: true });
        }

        const shapes = Object.keys(SHAPES);
        function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=arr[i]; arr[i]=arr[j]; arr[j]=t; } return arr; }
        let bag = [];
        const drawFromBag = () => { if(bag.length===0){ bag = shuffle(shapes.slice()); } return bag.pop(); };

        const spawn = () => { const s = state.next || drawFromBag(); state.active = new Piece(s); state.next = drawFromBag(); drawNext(state.next); updateScore(); updateLevel(); };

        // Robust game-over trigger used by outer loop/inputs.
        // Delegates to window.__onGameOver if available; otherwise, performs a minimal safe reset.
        function triggerGameOver(){
          try {
            if (typeof window.__onGameOver === 'function') {
              return window.__onGameOver();
            }
          } catch (_) { /* fall through to fallback */ }
          // Fallback: minimal reset so the loop can continue gracefully
          try {
            log('Game over (fallback). Resetting.');
          } catch(_) {}
          Object.assign(state, { grid: emptyGrid(), active: null, next: null, score: 0, level: 0, pieces: 0 });
          state.gravity = gravityForLevel(0);
          updateLevel();
          updateScore();
          spawn();
        }

        const scheduleNext = () => {
          // Run the main loop at a steady ~60 FPS; speed multiplier is applied
          // inside the loop by scaling the effective delta time.
          let delay = 1000 / 60;
          try {
            const tr = window.__train;
            if (tr && tr.enabled && tr.visualizeBoard === false) {
              delay = 0;
            }
          } catch (_) {}
          state.raf = setTimeout(() => tick(performance.now()), delay);
        };

        function updateRenderDecimation(){
          // Default: draw every frame; this can be expanded later to skip frames
          state.renderEvery = 1;
          state.renderCounter = 0;
        }

        function tick(ts){
          try {
            if(!state.running){ return; }
            if(!state.last) state.last = ts;
            const dt = ts - state.last; state.last = ts;
            let effDt = dt * speedMult;
            try {
              const tr = window.__train;
              if(tr && tr.enabled && tr.visualizeBoard === false){
                effDt = dt;
              }
            } catch(_) {}
            // Watchdog: detect lack of progress for > 2s wall time and reset
            const curSig = state.active ? `${state.active.shape}:${state.active.rot}:${state.active.row}:${state.active.col}:${state.score}:${state.pieces}` : `none:${state.score}:${state.pieces}`;
            if(curSig === state.lastSig){ state.wdAcc += dt; } else { state.wdAcc = 0; state.lastSig = curSig; }
            if(state.wdAcc > 2000 && !state.paused){ log('Watchdog: no progress for 2s -> game over'); triggerGameOver(); state.wdAcc = 0; }
            // Fallback: ensure there is always an active piece when running
            if(!state.paused && !state.active){
              spawn();
              if(!canMove(state.grid, state.active, 0, 0)) { log('Tick: spawned into block -> game over'); triggerGameOver(); return; }
            }
            if(!state.paused && state.active){
              // Global guard: if the active piece cannot exist at its current
              // position (e.g., spawn collision), trigger game over/reset.
              if(!canMove(state.grid, state.active, 0, 0)){
                log('Tick: spawn blocked -> game over');
                triggerGameOver();
                return;
              }
              if(window.__train && window.__train.enabled){
                window.__aiStep(effDt);
              } else {
                state.acc += effDt;
                while(state.acc >= state.gravity){
                  state.acc -= state.gravity;
                  if(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                  else {
                    lock(state.grid, state.active);
                    state.pieces++;
                    if(state.pieces % 20 === 0){
                      state.level++;
                      state.gravity = gravityForLevel(state.level);
                      updateLevel();
                    }
                    const cleared = clearRows(state.grid);
                    if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                    // Top-out guard after lock/clear in manual mode
                    if(state.grid[0].some(v => v !== 0)) { triggerGameOver(); }
                else {
                  spawn();
                      if(!canMove(state.grid, state.active, 0, 0)){ triggerGameOver(); }
                  }
                  }
                }
              }
            }
          } catch (e) {
            try { log(`Tick error: ${e && e.message ? e.message : e}`); } catch(_) {}
            try { triggerGameOver(); } catch(_) {}
          } finally {
            try {
              if(state.renderEvery <= 1){
                draw(state.grid, state.active);
              } else {
                if(state.renderCounter <= 0){
                  draw(state.grid, state.active);
                  state.renderCounter = state.renderEvery - 1;
                } else {
                  state.renderCounter -= 1;
                }
              }
            } catch(_) {}
            scheduleNext();
          }
        }

        function start(){ if(state.running){ log('Already running'); return; } canvas.focus(); state.grid = emptyGrid(); state.score=0; state.level=0; state.pieces=0; state.gravity=gravityForLevel(0); updateScore(); updateLevel(); state.last=0; state.acc=0; state.wdAcc=0; state.lastSig=''; state.running=true; state.paused=false; updateRenderDecimation(); spawn(); draw(state.grid, state.active); scheduleNext(); log('Game started'); renderControls(); }
        function pause(){ if(!state.running){ log('Pause ignored: not running'); return; } state.paused=true; log('Paused'); }
        function resume(){ if(!state.running){ log('Resume ignored: not running'); return; } state.paused=false; log('Resumed'); }
        function stop(){ if(!state.running){ log('Stop ignored: not running'); return; } state.running=false; state.paused=false; if(state.raf) clearTimeout(state.raf); state.raf=null; log('Game stopped'); renderControls(); }

        // Toggle + reset controls
        const toggleBtn = document.getElementById('toggle');
        const resetBtn = document.getElementById('reset');
        function renderControls(){
          if(!toggleBtn) return;
          const showPauseIcon = state.running && !state.paused;
          toggleBtn.textContent = showPauseIcon ? '⏸' : '▶';
          toggleBtn.classList.toggle('icon-btn--emerald', showPauseIcon);
        }
        function togglePlayPause(){ if(!state.running){ start(); } else if(state.paused){ resume(); } else { pause(); } renderControls(); }
        function resetGame(){ if(state.running){ stop(); } start(); }

        // keyboard
        const BLOCK_KEYS = new Set(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','PageUp','PageDown','Home','End']);
        document.addEventListener('keydown', (e) => {
          if(!state.running) return;
          if (BLOCK_KEYS.has(e.key)) e.preventDefault();
          if(state.paused || !state.active || (window.__train && window.__train.enabled)) return;
          if(e.key==='ArrowLeft' && canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0);
          else if(e.key==='ArrowRight' && canMove(state.grid, state.active, 1, 0)) state.active.move(1,0);
          else if(e.key==='ArrowUp'){ state.active.rotate(); if(!canMove(state.grid, state.active, 0, 0)) state.active.rotate(-1); }
          else if(e.key==='ArrowDown' && canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
          else if(e.key===' '){
            while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
            lock(state.grid, state.active);
            state.pieces++;
            if(state.pieces % 20 === 0){
              state.level++;
              state.gravity = gravityForLevel(state.level);
              updateLevel();
            }
            const cleared = clearRows(state.grid);
            if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared);} 
            if(state.grid[0].some(v => v !== 0)) { triggerGameOver(); }
            else { spawn(); if(!canMove(state.grid, state.active, 0, 0)) triggerGameOver(); }
          }
          draw(state.grid, state.active);
        });

        // buttons
        toggleBtn.addEventListener('click', togglePlayPause);
        resetBtn.addEventListener('click', resetGame);

        log('Ready. Click Start to run.');
        renderControls();

        // ================= AI Training (placement-level with animation) =================
        // Expose minimal API on window to avoid invasive edits above
        (function(){
          // Features (scaled):
          const FEATURE_NAMES = [
            'Lines',
            'Lines²',
            'Single Clear',
            'Double Clear',
            'Triple Clear',
            'Tetris',
            'Holes',
            'Bumpiness',
            'Max Height',
            'Well Sum',
            'Edge Wells',
            'Tetris Well',
            'Contact',
            'Row Transitions',
            'Col Transitions',
            'Aggregate Height',
          ];
          const FEAT_DIM = FEATURE_NAMES.length;
          const AI_STEP_MS = 28; // ms between AI animation steps

          // MLP architecture (when selected)
          const DEFAULT_MLP_HIDDEN = [8];
          const MLP_MIN_HIDDEN_LAYERS = 1;
          const MLP_MAX_HIDDEN_LAYERS = 3;
          const MLP_MIN_UNITS = 1;
          const MLP_MAX_UNITS = 32;
          let mlpHiddenLayers = DEFAULT_MLP_HIDDEN.slice();
          let currentModelType = 'linear';

          function sanitizeHiddenUnits(value, idx, fallback){
            const fallbackSource = Number.isFinite(fallback)
              ? Math.round(fallback)
              : (DEFAULT_MLP_HIDDEN[Math.min(idx, DEFAULT_MLP_HIDDEN.length - 1)] ?? DEFAULT_MLP_HIDDEN[0] ?? 8);
            const n = Number(value);
            if(!Number.isFinite(n)){
              return Math.max(MLP_MIN_UNITS, Math.min(MLP_MAX_UNITS, fallbackSource));
            }
            const rounded = Math.round(n);
            return Math.max(MLP_MIN_UNITS, Math.min(MLP_MAX_UNITS, rounded));
          }

          function mlpParamDim(layers = mlpHiddenLayers){
            const count = Math.max(MLP_MIN_HIDDEN_LAYERS, Math.min(MLP_MAX_HIDDEN_LAYERS, layers.length || 0));
            let dim = 0;
            let prev = FEAT_DIM;
            for(let i = 0; i < count; i++){
              const size = sanitizeHiddenUnits(layers[i], i, mlpHiddenLayers[i]);
              dim += prev * size + size;
              prev = size;
            }
            dim += prev + 1; // output layer (1 unit + bias)
            return dim;
          }

          function currentMlpLayerSizes(){
            const count = Math.max(MLP_MIN_HIDDEN_LAYERS, Math.min(MLP_MAX_HIDDEN_LAYERS, mlpHiddenLayers.length || 0));
            const sizes = [];
            for(let i = 0; i < count; i++){
              sizes.push(sanitizeHiddenUnits(mlpHiddenLayers[i], i, mlpHiddenLayers[i]));
            }
            return [FEAT_DIM, ...sizes, 1];
          }

          // Numeric dtype for weight arrays
          const HAS_F16 = (typeof Float16Array !== 'undefined');
          const DEFAULT_DTYPE = HAS_F16 ? 'f16' : 'f32';
          function allocWeights(n, dtype){ return (dtype==='f16' && HAS_F16) ? new Float16Array(n) : new Float32Array(n); }
          // Safe default allocator before `train` exists (avoid TDZ issues)
          let newWeightArray = (n) => allocWeights(n, DEFAULT_DTYPE);

          // Initial weights for Linear model (intentionally poor to make the very first attempt worse)
          // Order: [lines, lines2, is1, is2, is3, is4, holes, bumpiness, maxH, wellSum, edgeWell, tetrisWell, contact, rowTrans, colTrans, aggH]
          const INITIAL_MEAN_LINEAR_BASE = [0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.4, 0.2, 0.1, 0.1, 0.0, 0.0, 0.0, 0.1, 0.1, 0.2];
          const INITIAL_STD_LINEAR_BASE  = new Array(FEAT_DIM).fill(0.4);

          function paramDim(){ return currentModelType === 'mlp' ? mlpParamDim() : FEAT_DIM; }
          function makeTyped(vals){ const arr = newWeightArray(vals.length); for(let i=0;i<vals.length;i++) arr[i]=vals[i]; return arr; }
          function cloneWeightsArray(source){
            if(!source || !source.length){
              return new Float64Array(0);
            }
            const copy = new Float64Array(source.length);
            for(let i = 0; i < source.length; i++){
              copy[i] = source[i];
            }
            return copy;
          }
          function initialMean(model, layers = mlpHiddenLayers){
            if(model === 'mlp'){
              const dim = mlpParamDim(layers);
              const base = new Array(dim).fill(0.0);
              return makeTyped(base);
            }
            return makeTyped(INITIAL_MEAN_LINEAR_BASE);
          }
          function initialStd(model, layers = mlpHiddenLayers){
            if(model === 'mlp'){
              const dim = mlpParamDim(layers);
              const base = new Array(dim).fill(0.2);
              return makeTyped(base);
            }
            return makeTyped(INITIAL_STD_LINEAR_BASE);
          }

          function describeModelArchitecture(){
            if(currentModelType === 'mlp'){
              const sizes = currentMlpLayerSizes();
              if(!sizes.length) return 'Architecture: unavailable';
              const parts = sizes.map((size, idx) => {
                if(idx === 0) return `${size} in`;
                if(idx === sizes.length - 1) return `${size} out`;
                return `${size}`;
              });
              return `Architecture: ${parts.join(' → ')}`;
            }
            return `Linear policy with ${FEAT_DIM} inputs`;
          }

          function describeSnapshotArchitecture(entry){
            if(!entry){
              return describeModelArchitecture();
            }
            const genLabel = Number.isFinite(entry.gen) ? `Gen ${entry.gen}` : 'Saved model';
            const layerSizes = Array.isArray(entry.layerSizes) ? entry.layerSizes : null;
            if(entry.modelType === 'mlp' && layerSizes && layerSizes.length >= 2){
              const parts = layerSizes.map((size, idx) => {
                if(idx === 0) return `${size} in`;
                if(idx === layerSizes.length - 1) return `${size} out`;
                return `${size}`;
              });
              return `${genLabel} — ${parts.join(' → ')}`;
            }
            if(entry.modelType === 'linear'){
              const inputCount = layerSizes && layerSizes.length ? layerSizes[0] : FEAT_DIM;
              return `${genLabel} — Linear policy with ${inputCount} inputs`;
            }
            return `${genLabel} — Architecture unavailable`;
          }

          function formatScore(value){
            if(!Number.isFinite(value)){
              return 'n/a';
            }
            return Math.round(value).toLocaleString();
          }

          function getHistorySelection(){
            if(!train || !Array.isArray(train.bestByGeneration) || !train.bestByGeneration.length){
              return null;
            }
            if(train.historySelection === null || train.historySelection < 0){
              return null;
            }
            const capped = Math.min(train.bestByGeneration.length - 1, train.historySelection);
            if(capped < 0){
              return null;
            }
            return { entry: train.bestByGeneration[capped], index: capped };
          }

          function syncHistoryControls(){
            if(!historySlider) return;
            const total = train && Array.isArray(train.bestByGeneration) ? train.bestByGeneration.length : 0;
            const hasHistory = total > 0;
            historySlider.min = 0;
            const sliderMax = hasHistory ? total : 0;
            historySlider.max = sliderMax;
            historySlider.step = 1;
            const selection = train && train.historySelection !== null ? Math.max(0, Math.min(total - 1, train.historySelection)) : null;
            const sliderValue = hasHistory ? (selection !== null ? selection : sliderMax) : 0;
            historySlider.value = String(sliderValue);
            historySlider.disabled = !hasHistory;
            if(hasHistory){
              const fill = sliderMax > 0 ? Math.max(0, Math.min(100, (sliderValue / sliderMax) * 100)) : 0;
              const active = 'rgba(141, 225, 173, 0.85)';
              const base = 'rgba(94, 74, 227, 0.25)';
              historySlider.style.background = `linear-gradient(90deg, ${active} 0%, ${active} ${fill}%, ${base} ${fill}%, ${base} 100%)`;
            } else {
              historySlider.style.background = 'linear-gradient(90deg, rgba(94, 74, 227, 0.35), rgba(141, 225, 173, 0.55))';
            }

            const activeIndex = (!hasHistory || sliderValue >= sliderMax)
              ? null
              : Math.max(0, Math.min(total - 1, Math.round(sliderValue)));

            if(historyLabel){
              if(activeIndex === null){
                historyLabel.textContent = 'Live (current training)';
              } else {
                const entry = train.bestByGeneration[activeIndex];
                historyLabel.textContent = `Gen ${entry.gen}`;
              }
            }

            if(historyMeta){
              if(!hasHistory){
                historyMeta.textContent = 'Best-of-generation snapshots will appear as training progresses.';
              } else if(activeIndex === null){
                const latest = train.bestByGeneration[total - 1];
                const info = [];
                if(Number.isFinite(latest.gen)) info.push(`Latest stored: Gen ${latest.gen}`);
                if(Number.isFinite(latest.fitness)) info.push(`Score ${formatScore(latest.fitness)}`);
                if(latest.modelType) info.push(latest.modelType.toUpperCase());
                historyMeta.textContent = info.length ? info.join(' • ') : 'Snapshot details unavailable.';
              } else {
                const entry = train.bestByGeneration[activeIndex];
                const info = [];
                if(entry.modelType) info.push(entry.modelType.toUpperCase());
                if(Number.isFinite(entry.fitness)) info.push(`Score ${formatScore(entry.fitness)}`);
                historyMeta.textContent = info.length ? info.join(' • ') : 'Snapshot details unavailable.';
              }
            }
          }

          function recordGenerationSnapshot(snapshot){
            if(!train) return;
            if(!Array.isArray(train.bestByGeneration)){
              train.bestByGeneration = [];
            }
            const prevLength = train.bestByGeneration.length;
            train.bestByGeneration.push({
              gen: snapshot.gen,
              fitness: snapshot.fitness,
              modelType: snapshot.modelType,
              layerSizes: Array.isArray(snapshot.layerSizes) ? snapshot.layerSizes.slice() : null,
              weights: snapshot.weights,
              scoreIndex: Number.isFinite(snapshot.scoreIndex) ? snapshot.scoreIndex : null,
              recordedAt: snapshot.recordedAt || Date.now(),
            });
            if(train.historySelection !== null){
              const lastIdxBefore = Math.max(0, prevLength - 1);
              if(prevLength === 0 || train.historySelection >= lastIdxBefore){
                train.historySelection = train.bestByGeneration.length - 1;
              }
            }
            syncHistoryControls();
          }

          function activeWeightArray(){
            if(train && train.currentWeightsOverride && train.currentWeightsOverride.length){
              return train.currentWeightsOverride;
            }
            if(train && train.enabled && train.candIndex >= 0 && train.candIndex < train.candWeights.length){
              const candidate = train.candWeights[train.candIndex];
              if(candidate && candidate.length){
                return candidate;
              }
            }
            if(train && train.mean && train.mean.length){
              return train.mean;
            }
            if(train && train.bestEverWeights && train.bestEverWeights.length){
              return train.bestEverWeights;
            }
            return null;
          }

          function createWeightSnapshot(){
            const weights = activeWeightArray();
            if(!weights || !weights.length){
              return null;
            }
            const values = Array.from(weights, (v) => Number(v));
            const hiddenLayersSnapshot = (train && train.modelType === 'mlp')
              ? (() => {
                  const sizes = currentMlpLayerSizes();
                  if(!sizes || sizes.length <= 2){
                    return [];
                  }
                  return sizes.slice(1, sizes.length - 1).map((size, idx) => sanitizeHiddenUnits(size, idx, size));
                })()
              : [];
            const snapshot = {
              version: 1,
              createdAt: new Date().toISOString(),
              modelType: train ? train.modelType : currentModelType,
              dtype: (train && train.dtype) ? train.dtype : DEFAULT_DTYPE,
              featureCount: FEAT_DIM,
              hiddenLayers: hiddenLayersSnapshot,
              weights: values,
            };
            if(train && Number.isFinite(train.gen)){
              snapshot.generation = train.gen;
            }
            if(train && Number.isFinite(train.bestEverFitness)){
              snapshot.bestEverFitness = train.bestEverFitness;
            }
            return snapshot;
          }

          function downloadCurrentWeights(){
            try {
              const snapshot = createWeightSnapshot();
              if(!snapshot){
                log('Weights unavailable for download yet. Start a game or training session first.');
                return;
              }
              const text = JSON.stringify(snapshot, null, 2);
              const blob = new Blob([text], { type: 'text/plain' });
              const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
              const safeModel = (snapshot.modelType || 'model').toLowerCase();
              const fileName = `tetris-${safeModel}-weights-${timestamp}.txt`;
              const link = document.createElement('a');
              link.href = URL.createObjectURL(blob);
              link.download = fileName;
              document.body.appendChild(link);
              link.click();
              setTimeout(() => {
                try {
                  URL.revokeObjectURL(link.href);
                } catch (_) {}
                if(link.parentNode){
                  link.parentNode.removeChild(link);
                }
              }, 0);
              log(`Saved ${snapshot.modelType.toUpperCase()} weights (${snapshot.weights.length} params) to ${fileName}.`);
            } catch (err) {
              console.error(err);
              const message = (err && err.message) ? err.message : 'unknown error';
              log(`Failed to export weights: ${message}`);
            }
          }

          function parseWeightSnapshot(text){
            if(!text || !text.trim()){
              throw new Error('File was empty');
            }
            let data;
            try {
              data = JSON.parse(text);
            } catch (err) {
              throw new Error('File was not valid JSON');
            }
            if(!data || typeof data !== 'object'){
              throw new Error('Snapshot data missing');
            }
            if(data.version && Number(data.version) !== 1){
              throw new Error(`Unsupported snapshot version ${data.version}`);
            }
            if(data.modelType !== 'linear' && data.modelType !== 'mlp'){
              throw new Error('Snapshot missing model type');
            }
            if(!Array.isArray(data.weights) || !data.weights.length){
              throw new Error('Snapshot missing weights');
            }
            if(data.featureCount && data.featureCount !== FEAT_DIM){
              throw new Error(`Snapshot expects ${data.featureCount} features but this build uses ${FEAT_DIM}`);
            }
            data.version = 1;
            return data;
          }

          function applyWeightSnapshot(snapshot, context){
            if(!snapshot){
              throw new Error('Snapshot missing');
            }
            const modelType = snapshot.modelType;
            let dtype = snapshot.dtype;
            if(dtype === 'f16' && !HAS_F16){
              dtype = 'f32';
            }
            if(dtype !== 'f16' && dtype !== 'f32'){
              dtype = 'f32';
            }

            const weights = snapshot.weights.map((v) => Number(v));
            let expectedDim = FEAT_DIM;
            let snapshotHidden = [];
            if(modelType === 'mlp'){
              const raw = Array.isArray(snapshot.hiddenLayers) ? snapshot.hiddenLayers : [];
              snapshotHidden = raw.slice(0, MLP_MAX_HIDDEN_LAYERS).map((value, idx) => sanitizeHiddenUnits(value, idx, value));
              if(snapshotHidden.length === 0){
                const fallback = DEFAULT_MLP_HIDDEN[0] || 8;
                snapshotHidden.push(sanitizeHiddenUnits(fallback, 0, fallback));
              }
              let prev = FEAT_DIM;
              expectedDim = 0;
              for(let i = 0; i < snapshotHidden.length; i++){
                const size = sanitizeHiddenUnits(snapshotHidden[i], i, snapshotHidden[i]);
                snapshotHidden[i] = size;
                expectedDim += prev * size + size;
                prev = size;
              }
              expectedDim += prev + 1;
            }

            if(weights.length !== expectedDim){
              throw new Error(`Expected ${expectedDim} weights for ${modelType.toUpperCase()} model, received ${weights.length}`);
            }

            const typed = allocWeights(expectedDim, dtype);
            for(let i = 0; i < expectedDim; i++){
              const val = weights[i];
              typed[i] = Number.isFinite(val) ? val : 0;
            }

            const wasRunning = train && train.enabled;
            if(wasRunning){
              stopTraining();
            }

            if(modelSel){
              modelSel.value = modelType;
            }

            if(modelType === 'mlp'){
              applyMlpHiddenLayers(snapshotHidden, { rerenderControls: true, syncInputs: true });
            }

            train.modelType = modelType;
            currentModelType = modelType;
            train.dtype = dtype;

            resetTraining();
            syncMlpConfigVisibility();

            train.mean = typed;
            train.std = initialStd(modelType, mlpHiddenLayers);
            train.currentWeightsOverride = null;
            train.ai.plan = null;

            const bestCopy = new Float64Array(typed.length);
            for(let i = 0; i < typed.length; i++){
              bestCopy[i] = typed[i];
            }
            train.bestEverWeights = bestCopy;
            train.bestEverFitness = Number.isFinite(snapshot.bestEverFitness) ? snapshot.bestEverFitness : -Infinity;
            const snapGen = Number(snapshot.generation);
            if(Number.isFinite(snapGen) && snapGen >= 0){
              train.gen = snapGen;
            }

            updateTrainStatus();

            const origin = context && context.fileName ? ` from ${context.fileName}` : '';
            log(`Loaded ${modelType.toUpperCase()} weights (${typed.length} params)${origin}.`);
            if(wasRunning){
              log('Training paused. Restart AI training to continue with imported weights.');
            }
          }

          function applyMlpHiddenLayers(newLayers, options = {}){
            const desiredLength = Math.max(
              MLP_MIN_HIDDEN_LAYERS,
              Math.min(MLP_MAX_HIDDEN_LAYERS, newLayers.length || 0),
            );
            const sanitized = [];
            for(let i = 0; i < desiredLength; i++){
              const fallback = mlpHiddenLayers[i];
              sanitized.push(sanitizeHiddenUnits(newLayers[i], i, fallback));
            }
            if(sanitized.length === 0){
              sanitized.push(sanitizeHiddenUnits(DEFAULT_MLP_HIDDEN[0], 0, DEFAULT_MLP_HIDDEN[0]));
            }
            const prevLayers = mlpHiddenLayers.slice();
            mlpHiddenLayers = sanitized;
            if(mlpHiddenCountSel){
              mlpHiddenCountSel.value = String(sanitized.length);
            }
            if(options.rerenderControls){
              renderMlpLayerControls();
            } else if(options.syncInputs !== false){
              for(let i = 0; i < sanitized.length; i++){
                const input = document.getElementById(`mlp-layer-${i}`);
                if(input && Number(input.value) !== sanitized[i]){
                  input.value = sanitized[i];
                }
              }
            }
            const changed = sanitized.length !== prevLayers.length
              || sanitized.some((val, idx) => val !== prevLayers[idx]);
            if(train){
              train.mlpHiddenLayers = sanitized.slice();
              if(changed){
                if(train.modelType === 'mlp'){
                  const wasRunning = train.enabled;
                  resetTraining();
                  if(wasRunning){
                    startTraining();
                  }
                } else {
                  updateTrainStatus();
                }
              }
            }
            return sanitized;
          }

          function renderMlpLayerControls(){
            if(!mlpLayerControlsEl) return;
            mlpLayerControlsEl.innerHTML = '';
            for(let i = 0; i < mlpHiddenLayers.length; i++){
              const wrapper = document.createElement('div');
              wrapper.className = 'flex items-center gap-3';
              const inputId = `mlp-layer-${i}`;
              const label = document.createElement('label');
              label.setAttribute('for', inputId);
              label.className = 'text-xs uppercase tracking-[0.35em] text-plum/70';
              label.textContent = `Layer ${i + 1} Nodes`;
              const input = document.createElement('input');
              input.type = 'number';
              input.id = inputId;
              input.min = String(MLP_MIN_UNITS);
              input.max = String(MLP_MAX_UNITS);
              input.step = '1';
              input.value = mlpHiddenLayers[i];
              input.className = 'w-20 rounded-2xl border border-white/20 bg-white/10 px-3 py-1 text-center text-shell focus:outline-none focus:ring-2 focus:ring-citron/60';
              input.setAttribute('aria-label', `Hidden layer ${i + 1} nodes`);
              input.addEventListener('change', (e) => {
                const sanitized = sanitizeHiddenUnits(e.target.value, i, mlpHiddenLayers[i]);
                if(mlpHiddenLayers[i] === sanitized){
                  e.target.value = sanitized;
                  return;
                }
                const layers = mlpHiddenLayers.slice();
                layers[i] = sanitized;
                applyMlpHiddenLayers(layers, { syncInputs: false });
                e.target.value = sanitized;
              });
              wrapper.appendChild(label);
              wrapper.appendChild(input);
              mlpLayerControlsEl.appendChild(wrapper);
            }
          }

          function handleHiddenCountChange(value){
            const parsed = Math.round(Number(value));
            const desired = Number.isFinite(parsed)
              ? Math.max(MLP_MIN_HIDDEN_LAYERS, Math.min(MLP_MAX_HIDDEN_LAYERS, parsed))
              : mlpHiddenLayers.length;
            if(desired === mlpHiddenLayers.length){
              if(mlpHiddenCountSel){
                mlpHiddenCountSel.value = String(mlpHiddenLayers.length);
              }
              return;
            }
            const layers = mlpHiddenLayers.slice();
            if(desired > layers.length){
              const seed = layers.length
                ? layers[layers.length - 1]
                : sanitizeHiddenUnits(DEFAULT_MLP_HIDDEN[0], layers.length, DEFAULT_MLP_HIDDEN[0]);
              while(layers.length < desired){
                layers.push(seed);
              }
            } else {
              layers.length = desired;
            }
            applyMlpHiddenLayers(layers, { rerenderControls: true });
          }

          function syncMlpConfigVisibility(){
            if(!mlpConfigEl) return;
            if(train && train.modelType === 'mlp'){
              mlpConfigEl.classList.remove('hidden');
            } else {
              mlpConfigEl.classList.add('hidden');
            }
          }

          function initMlpConfigUi(){
            if(mlpHiddenCountSel){
              mlpHiddenCountSel.value = String(mlpHiddenLayers.length);
              mlpHiddenCountSel.addEventListener('change', (e) => {
                handleHiddenCountChange(e.target.value);
              });
            }
            renderMlpLayerControls();
            if(train){
              train.mlpHiddenLayers = mlpHiddenLayers.slice();
            }
            syncMlpConfigVisibility();
          }

          function sliceSegment(arr, start, end){
            if(!arr) return null;
            if(typeof arr.subarray === 'function'){
              return arr.subarray(start, end);
            }
            return arr.slice(start, end);
          }

          function inferLayerSizesFromWeights(weights, override){
            const inputDim = FEATURE_NAMES.length;
            if(Array.isArray(override) && override.length >= 2){
              return override.slice();
            }
            if(!weights || !weights.length){
              return [inputDim, 1];
            }
            const total = weights.length;
            const cache = new Map();

            function dfs(offset, prev){
              if(offset === total){
                return [];
              }
              const key = `${offset}|${prev}`;
              if(cache.has(key)) return cache.get(key);
              const remaining = total - offset;

              if(remaining % prev === 0){
                const outSize = remaining / prev;
                const seq = [outSize];
                cache.set(key, seq);
                return seq;
              }

              const maxNext = Math.floor(remaining / (prev + 1));
              for(let next = maxNext; next >= 1; next--){
                const need = prev * next + next;
                if(need > remaining) continue;
                const rest = dfs(offset + need, next);
                if(rest){
                  const seq = [next, ...rest];
                  cache.set(key, seq);
                  return seq;
                }
              }
              cache.set(key, null);
              return null;
            }

            const seq = dfs(0, inputDim);
            if(seq){
              return [inputDim, ...seq];
            }
            if(total === inputDim){
              return [inputDim, 1];
            }
            if(total === inputDim + 1){
              return [inputDim, 1];
            }
            return [inputDim, 1];
          }

          function sliceWeightMatrices(weights, layerSizes){
            const slices = [];
            if(!weights || !layerSizes || layerSizes.length < 2) return slices;
            let offset = 0;
            const totalLen = weights.length || 0;
            for(let layer = 1; layer < layerSizes.length; layer++){
              const prev = layerSizes[layer - 1];
              const curr = layerSizes[layer];
              const weightCount = prev * curr;
              const matrix = sliceSegment(weights, offset, offset + weightCount);
              offset += weightCount;
              let bias = null;
              if(offset + curr <= totalLen){
                bias = sliceSegment(weights, offset, offset + curr);
                offset += curr;
              }
              slices.push({ weights: matrix, bias });
            }
            return slices;
          }

          function renderNetworkD3(weights, overrideLayerSizes){
            if(!networkVizEl || typeof d3 === 'undefined'){
              return;
            }
            const width = networkVizEl.clientWidth || 320;
            const height = networkVizEl.clientHeight || 220;
            const marginX = 52;
            const marginY = 28;

            let svg = d3.select(networkVizEl).select('svg');
            if(svg.empty()){
              svg = d3.select(networkVizEl)
                .append('svg')
                .attr('role', 'img')
                .attr('aria-label', 'Visualization of model weights')
                .attr('preserveAspectRatio', 'xMidYMid meet');
            }
            svg
              .attr('width', width)
              .attr('height', height)
              .attr('viewBox', `0 0 ${width} ${height}`);
            svg.selectAll('*').remove();

            if(!weights || !weights.length){
              svg.append('text')
                .attr('x', width / 2)
                .attr('y', height / 2)
                .attr('text-anchor', 'middle')
                .attr('fill', '#888')
                .text('Weights unavailable');
              return;
            }

            const layerSizes = inferLayerSizesFromWeights(weights, overrideLayerSizes);
            const slices = sliceWeightMatrices(weights, layerSizes);
            const totalLayers = layerSizes.length;
            const innerWidth = Math.max(width - 2 * marginX, 10);
            const innerHeight = Math.max(height - 2 * marginY, 10);

            const nodes = [];
            const nodeLookup = new Map();
            for(let layerIdx = 0; layerIdx < totalLayers; layerIdx++){
              const layerSize = layerSizes[layerIdx];
              const x = totalLayers === 1 ? width / 2 : marginX + (innerWidth * layerIdx) / Math.max(1, totalLayers - 1);
              const step = layerSize > 1 ? innerHeight / (layerSize - 1) : 0;
              const biasSlice = layerIdx > 0 && slices[layerIdx - 1] ? slices[layerIdx - 1].bias : null;
              for(let i = 0; i < layerSize; i++){
                const y = layerSize > 1 ? marginY + step * i : height / 2;
                const id = `${layerIdx}-${i}`;
                const label = layerIdx === 0
                  ? (FEATURE_NAMES[i] || `x${i + 1}`)
                  : (layerIdx === totalLayers - 1
                    ? (layerSize === 1 ? 'Output' : `y${i + 1}`)
                    : `h${layerIdx}-${i + 1}`);
                const biasVal = (biasSlice && biasSlice.length > i) ? biasSlice[i] : null;
                const node = { id, layer: layerIdx, index: i, x, y, label, bias: biasVal };
                nodes.push(node);
                nodeLookup.set(id, node);
              }
            }

            const edges = [];
            for(let layerIdx = 1; layerIdx < layerSizes.length; layerIdx++){
              const prev = layerSizes[layerIdx - 1];
              const curr = layerSizes[layerIdx];
              const slice = slices[layerIdx - 1];
              const matrix = slice && slice.weights ? slice.weights : null;
              for(let i = 0; i < prev; i++){
                for(let j = 0; j < curr; j++){
                  const wIdx = matrix ? (i * curr + j) : null;
                  const weightValue = (matrix && wIdx !== null && wIdx < matrix.length) ? matrix[wIdx] : 0;
                  edges.push({
                    source: nodeLookup.get(`${layerIdx - 1}-${i}`),
                    target: nodeLookup.get(`${layerIdx}-${j}`),
                    weight: weightValue,
                  });
                }
              }
            }

            const maxAbs = edges.length ? d3.max(edges, (d) => Math.abs(d.weight)) : 0;
            const denom = (maxAbs && Number.isFinite(maxAbs) && maxAbs > 0) ? maxAbs : 1;

            const edgeGroup = svg.append('g').attr('class', 'edges');
            const edgeSel = edgeGroup.selectAll('line')
              .data(edges)
              .enter()
              .append('line')
              .attr('x1', (d) => d.source ? d.source.x : 0)
              .attr('y1', (d) => d.source ? d.source.y : 0)
              .attr('x2', (d) => d.target ? d.target.x : 0)
              .attr('y2', (d) => d.target ? d.target.y : 0)
              .attr('stroke', (d) => (d.weight >= 0 ? '#2b8cbe' : '#d7301f'))
              .attr('stroke-width', (d) => {
                const norm = Math.min(1, Math.abs(d.weight) / denom);
                return 0.6 + norm * 3.4;
              })
              .attr('stroke-opacity', (d) => {
                const norm = Math.min(1, Math.abs(d.weight) / denom);
                return 0.2 + norm * 0.8;
              });
            edgeSel.append('title').text((d) => `w=${d.weight.toFixed(3)}`);

            const nodeGroup = svg.append('g').attr('class', 'nodes');
            const nodeSel = nodeGroup.selectAll('g')
              .data(nodes)
              .enter()
              .append('g')
              .attr('transform', (d) => `translate(${d.x}, ${d.y})`);

            nodeSel.append('circle')
              .attr('r', 10)
              .attr('fill', '#fff')
              .attr('stroke', '#555')
              .attr('stroke-width', 1.2);

            nodeSel.append('text')
              .attr('text-anchor', (d) => {
                if(d.layer === 0) return 'end';
                if(d.layer === totalLayers - 1) return 'start';
                return 'middle';
              })
              .attr('x', (d) => {
                if(d.layer === 0) return -14;
                if(d.layer === totalLayers - 1) return 14;
                return 0;
              })
              .attr('dy', 4)
              .text((d) => d.label);

            nodeSel.append('title').text((d) => {
              if(d.layer === 0){
                return d.label;
              }
              if(typeof d.bias === 'number' && Number.isFinite(d.bias)){
                return `${d.label} (bias ${d.bias.toFixed(3)})`;
              }
              return d.label;
            });
          }

          const train = {
            enabled: false,
            gen: 0,
            popSize: 16,
            eliteFrac: 0.25,
            modelType: 'linear',
            mlpHiddenLayers: mlpHiddenLayers.slice(),
            dtype: DEFAULT_DTYPE,
            mean: initialMean('linear'),
            std: initialStd('linear'),
            minStd: 0.05,
            maxStd: 3.0,
            candWeights: [],
            candScores: [],
            candIndex: -1,
            // Visualization + speed controls for training
            visualizeBoard: false,     // if false: skip board/preview rendering
            currentWeightsOverride: null,
            ai: { plan: null, acc: 0, lastSig: '', staleMs: 0 },
            performanceSummary: [],
            gameScores: [],
            gameModelTypes: [],
            gameScoresOffset: 0,
            totalGamesPlayed: 0,
            bestEverFitness: -Infinity,
            bestEverWeights: null,
            bestByGeneration: [],
            historySelection: null,
            maxPlotPoints: 4000,
            scorePlotUpdateFreq: 5,
            scorePlotPending: 0,
            scorePlotAxisMax: 0,
          };
          window.__train = train;
          // After `train` exists, honor train.dtype for future allocations
          newWeightArray = (n) => allocWeights(n, (train && train.dtype) ? train.dtype : DEFAULT_DTYPE);

          train.scorePlotAxisMax = Math.max(10, Math.ceil(train.popSize * 1.2));
          train.scorePlotPending = 0;
          syncHistoryControls();

          function updateTrainStatus(){
            if(trainStatus){
              if(train.enabled){
                trainStatus.textContent = `Gen ${train.gen+1}, Candidate ${train.candIndex+1}/${train.popSize} — Model: ${train.modelType.toUpperCase()}`;
              } else {
                trainStatus.textContent = `Training stopped — Model: ${train.modelType.toUpperCase()}`;
              }
            }
            const historySelection = getHistorySelection();
            const snapshot = historySelection ? historySelection.entry : null;
            let currentWeights = null;
            let overrideLayers = null;

            if(snapshot){
              currentWeights = snapshot.weights || null;
              if(Array.isArray(snapshot.layerSizes) && snapshot.layerSizes.length >= 2){
                overrideLayers = snapshot.layerSizes.slice();
              } else if(snapshot.modelType === 'mlp'){
                overrideLayers = currentMlpLayerSizes();
              } else if(snapshot.modelType === 'linear'){
                overrideLayers = [FEAT_DIM, 1];
              }
            } else if(train.currentWeightsOverride){
              currentWeights = train.currentWeightsOverride;
              if(train.modelType === 'mlp'){
                overrideLayers = currentMlpLayerSizes();
              }
            } else if(train.enabled && train.candIndex >= 0 && train.candIndex < train.candWeights.length){
              currentWeights = train.candWeights[train.candIndex];
              if(train.modelType === 'mlp'){
                overrideLayers = currentMlpLayerSizes();
              }
            } else if(train.mean){
              currentWeights = train.mean;
              if(train.modelType === 'mlp'){
                overrideLayers = currentMlpLayerSizes();
              }
            }

            if(!snapshot && !currentWeights && train.bestEverWeights){
              currentWeights = train.bestEverWeights;
              overrideLayers = (train.modelType === 'mlp') ? currentMlpLayerSizes() : [FEAT_DIM, 1];
            }

            if(architectureEl){
              if(snapshot){
                architectureEl.textContent = describeSnapshotArchitecture(snapshot);
              } else {
                architectureEl.textContent = describeModelArchitecture();
              }
            }
            try {
              renderNetworkD3(currentWeights, overrideLayers);
            } catch (_) {
              /* ignore render failures */
            }
          }

          function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
          function samplePopulation(){
            const dim = paramDim();
            train.candWeights = [];
            for(let i=0; i<train.popSize; i++){
              const w = newWeightArray(dim);
              for(let d=0; d<dim; d++){
                const mean = (train.mean && Number.isFinite(train.mean[d])) ? train.mean[d] : 0;
                const rawStd = (train.std && Number.isFinite(train.std[d])) ? train.std[d] : 0;
                const scale = Math.max(train.minStd, Math.abs(rawStd));
                w[d] = mean + randn() * scale;
              }
              train.candWeights.push(w);
            }
            // Ensure the very first attempt (gen 0, cand 0) uses the mean weights (intentionally poor)
            if(train.gen === 0 && train.candWeights.length > 0){
              const dim0 = train.mean.length; const m = newWeightArray(dim0); for(let d=0; d<dim0; d++) m[d]=train.mean[d];
              train.candWeights[0] = m;
            }
            train.candScores = new Array(train.popSize).fill(0);
            train.candIndex = 0;
          }

          function startTraining(){
            if(!state.running){ start(); }
            trainingProfiler.reset();
            trainingProfiler.enable();
            train.performanceSummary = [];
            train.enabled = true; train.gen = 0; train.ai.plan = null; train.ai.acc = 0; samplePopulation();
            train.ai.lastSig = '';
            train.ai.staleMs = 0;
            train.gameScores = [];
            train.gameModelTypes = [];
            train.gameScoresOffset = 0;
            train.totalGamesPlayed = 0;
            train.currentWeightsOverride = null;
            train.scorePlotPending = 0;
            train.scorePlotAxisMax = Math.max(10, Math.ceil(train.popSize * 1.2));
            updateTrainStatus();
            const btn = document.getElementById('start-training');
            if(btn){
              btn.textContent = 'Stop Training';
              btn.classList.remove('icon-btn--violet');
              btn.classList.add('icon-btn--emerald');
              btn.setAttribute('title', 'Stop training');
              btn.setAttribute('aria-label', 'Stop training');
            }
            log('Training started');
          }
          function stopTraining(){
            const wasRunning = train.enabled;
            train.enabled = false;
            train.ai.plan = null;
            const btn = document.getElementById('start-training');
            if(btn){
              btn.textContent = 'Start Training';
              btn.classList.remove('icon-btn--emerald');
              btn.classList.add('icon-btn--violet');
              btn.setAttribute('title', 'Start training');
              btn.setAttribute('aria-label', 'Start training');
            }
            if(train.scorePlotPending && train.gameScores.length){
              updateScorePlot();
            }
            train.scorePlotPending = 0;
            log('Training stopped');
            if(wasRunning){
              logTrainingProfileSummary();
            }
            trainingProfiler.disable();
            trainingProfiler.reset();
            updateTrainStatus();
          }
          function resetTraining(){
            stopTraining();
            currentModelType = train.modelType;
            train.mlpHiddenLayers = mlpHiddenLayers.slice();
            // Reset mean/std based on selected model
            train.mean = initialMean(train.modelType);
            train.std = initialStd(train.modelType);
            train.gen = 0;
            train.candWeights = [];
            train.candScores = [];
            train.candIndex = -1;
            train.ai.plan = null;
            train.ai.acc = 0;
            train.performanceSummary = [];
            train.gameScores = [];
            train.gameModelTypes = [];
            train.gameScoresOffset = 0;
            train.totalGamesPlayed = 0;
            train.currentWeightsOverride = null;
            train.bestEverFitness = -Infinity;
            train.bestEverWeights = null;
            train.bestByGeneration = [];
            train.historySelection = null;
            train.scorePlotPending = 0;
            train.scorePlotAxisMax = Math.max(10, Math.ceil(train.popSize * 1.2));
            updateScorePlot();
            syncHistoryControls();
            updateTrainStatus();
            log('Training parameters reset');
          }
          window.startTraining = startTraining; window.stopTraining = stopTraining; window.resetTraining = resetTraining;

          function onGameOver(){
            log('Game over. Resetting.');
            if(train.enabled){
              const fitness = state.score;
              if(train.candIndex >= 0) train.candScores[train.candIndex] = fitness;
              // Append raw score for progress plot and mark model type
              train.gameScores.push(state.score);
              train.gameModelTypes.push(train.modelType);
              if(!Number.isFinite(train.totalGamesPlayed)){
                train.totalGamesPlayed = 0;
              }
              if(!Number.isFinite(train.gameScoresOffset)){
                train.gameScoresOffset = 0;
              }
              train.totalGamesPlayed += 1;
              // Cap data arrays to bound memory
              const cap = train.maxPlotPoints;
              const overflow = train.gameScores.length - cap;
              if (overflow > 0) {
                train.gameScores.splice(0, overflow);
                train.gameModelTypes.splice(0, overflow);
                train.gameScoresOffset += overflow;
              }
              const updateStride = Math.max(1, train.scorePlotUpdateFreq || 5);
              train.scorePlotPending = (train.scorePlotPending || 0) + 1;
              if(train.scorePlotPending >= updateStride){
                updateScorePlot();
              }
              if(train.candIndex + 1 < train.popSize){
                train.candIndex += 1;
                Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                state.gravity = gravityForLevel(0);
                updateLevel(); updateScore();
                spawn(); train.ai.plan = null; train.ai.acc = 0;
                log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                updateTrainStatus();
              } else {
                const idx = [...train.candScores.keys()].sort((a,b)=>train.candScores[b]-train.candScores[a]);
                const bestIdx = idx[0];
                const bestThisGen = train.candScores[bestIdx];
                const eliteCount = Math.max(1, Math.floor(train.eliteFrac * train.popSize));
                const elites = idx.slice(0, eliteCount);
                const dim = paramDim();
                const newMean = newWeightArray(dim);
                if(elites.length > 0){
                  for(let i = 0; i < elites.length; i++){
                    const wCand = train.candWeights[elites[i]];
                    for(let d = 0; d < dim; d++){
                      newMean[d] += wCand[d];
                    }
                  }
                  for(let d = 0; d < dim; d++){
                    newMean[d] /= elites.length;
                  }
                }
                const newStd = newWeightArray(dim);
                if(elites.length > 0){
                  for(let i = 0; i < elites.length; i++){
                    const wCand = train.candWeights[elites[i]];
                    for(let d = 0; d < dim; d++){
                      const diff = wCand[d] - newMean[d];
                      newStd[d] += diff * diff;
                    }
                  }
                }
                for(let d = 0; d < dim; d++){
                  const variance = elites.length > 0 ? newStd[d] / Math.max(1, elites.length) : 0;
                  const stdValue = Math.sqrt(Math.max(0, variance));
                  const bounded = Math.min(train.maxStd, Math.max(train.minStd, stdValue));
                  newStd[d] = Number.isFinite(bounded) ? bounded : train.minStd;
                }
                train.bestFitness = bestThisGen;
                const bestWeights = train.candWeights[bestIdx];
                train.mean = newMean;
                train.std = newStd;
                if(bestWeights && Number.isFinite(bestThisGen) && bestThisGen > (train.bestEverFitness ?? -Infinity)){
                  train.bestEverFitness = bestThisGen;
                  train.bestEverWeights = cloneWeightsArray(bestWeights);
                }
                train.gen += 1;
                train.currentWeightsOverride = null;
                log(`Gen ${train.gen} complete. Best score: ${bestThisGen}`);
                samplePopulation();
                Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                state.gravity = gravityForLevel(0);
                updateLevel(); updateScore();
                spawn(); train.ai.plan = null; train.ai.acc = 0;
                updateScorePlot();
                log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                updateTrainStatus();
                return;
              }
            } else {
              Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
              state.gravity = gravityForLevel(0);
              updateLevel(); updateScore();
              spawn();
            }
          }
          window.__onGameOver = onGameOver;

          function stateWidth(state){ let maxC=0; for(const [,c] of state) if(c>maxC) maxC=c; return maxC+1; }
          function copyGrid(g){ return g.map(r=>r.slice()); }
          function dropRowSim(grid, piece){ if(!canMove(grid,piece,0,0)) return null; while(canMove(grid,piece,0,1)) piece.move(0,1); return piece.row; }

          // Return true if dropRowSim finds a valid landing row for the given rotation and column.
          function pathClear(grid, shape, rot, col){
            const piece = new Piece(shape);
            piece.rot = rot;
            piece.row = 0;
            piece.col = col;
            return dropRowSim(grid, piece) !== null;
          }

          function enumeratePlacements(grid, shape){
            return trainingProfiler.section('train.full.enumerate', () => {
              const actions = [];
              const rotIdx = UNIQUE_ROTATIONS[shape];
              for(const rot of rotIdx){
                const width = stateWidth(SHAPES[shape][rot]);
                for(let col=0; col<=WIDTH-width; col++){
                  if(pathClear(grid, shape, rot, col)){
                    actions.push({ rot, col });
                  }
                }
              }
              return actions;
            });
          }
          function lockSim(grid, piece){ for(const [r,c] of piece.blocks()) grid[r][c]=1; }
          function clearRowsSim(grid){ let remaining = grid.filter(row => row.some(v => v===0)); const cleared = HEIGHT - remaining.length; while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0)); for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r]; return cleared; }
          const BOARD_AREA = WIDTH * HEIGHT;
          const BUMP_NORMALIZER = ((WIDTH - 1) * HEIGHT) || 1;
          const CONTACT_NORMALIZER = (BOARD_AREA * 2) || 1;
          function columnHeights(grid){ const h=Array(WIDTH).fill(0); for(let c=0;c<WIDTH;c++){ let r=0; while(r<HEIGHT && grid[r][c]===0) r++; h[c]=HEIGHT-r; } return h; }
          function countHoles(grid){ let holes=0; for(let c=0;c<WIDTH;c++){ let seen=false; for(let r=0;r<HEIGHT;r++){ const v=grid[r][c]; if(v){ seen=true; } else if(seen){ holes++; } } } return holes; }
          function bumpiness(heights){ let b=0; for(let c=0;c<WIDTH-1;c++) b+=Math.abs(heights[c]-heights[c+1]); return b; }
          function wellMetrics(heights){
            let wellSum=0;
            let edgeWell=0;
            let maxWellDepth=0;
            let wellCount=0;
            for(let c=0;c<WIDTH;c++){
              const left = (c>0)?heights[c-1]:Infinity;
              const right = (c<WIDTH-1)?heights[c+1]:Infinity;
              const minNbr = Math.min(left,right);
              const depth = minNbr - heights[c];
              if(depth>0){
                wellSum += depth;
                wellCount++;
                if(depth>maxWellDepth){
                  maxWellDepth = depth;
                }
              }
              if(c===0){
                edgeWell = Math.max(edgeWell, right - heights[0]);
              }
              if(c===WIDTH-1){
                edgeWell = Math.max(edgeWell, left - heights[WIDTH-1]);
              }
            }
            const safeEdge = Math.max(0, edgeWell);
            const tetrisWell = (wellCount === 1) ? maxWellDepth : 0;
            return {wellSum, edgeWell: safeEdge, maxWellDepth, wellCount, tetrisWell};
          }
          function contactArea(g){ let contact=0; for(let r=0;r<HEIGHT;r++){ for(let c=0;c<WIDTH;c++){ if(!g[r][c]) continue; // bottom
                if(r===HEIGHT-1 || g[r+1][c]) contact++; // left
                if(c>0 && g[r][c-1]) contact++; // right
                if(c<WIDTH-1 && g[r][c+1]) contact++; } } return contact; }
          function rowTransitions(g){ let t=0; for(let r=0;r<HEIGHT;r++){ let prev=0; for(let c=0;c<WIDTH;c++){ const cur = g[r][c]?1:0; if(cur!==prev) t++; prev=cur; } if(prev!==0) t++; } return t; }
          function colTransitions(g){ let t=0; for(let c=0;c<WIDTH;c++){ let prev=0; for(let r=0;r<HEIGHT;r++){ const cur = g[r][c]?1:0; if(cur!==prev) t++; prev=cur; } if(prev!==0) t++; } return t; }
          function simulateAfterPlacement(grid, shape, rot, col){
            return trainingProfiler.section('train.full.simulate', () => {
              const g = copyGrid(grid);
              const p = new Piece(shape);
              p.rot = rot;
              p.row = 0;
              p.col = col;
              const fr = dropRowSim(g, p);
              if(fr === null) return null;
              p.row = fr;
              lockSim(g, p);
              const lines = clearRowsSim(g);
              return { grid: g, lines };
            });
          }
          function fillFeatureVector(target, lines, holes, bump, maxHeight, wellSum, edgeWell, tetrisWell, contact, rowTransitions, colTransitions, aggregateHeight){
            let cleared = (typeof lines === 'number' && Number.isFinite(lines)) ? lines : 0;
            if(cleared < 0) cleared = 0;
            target[0] = cleared / 4;
            target[1] = (cleared * cleared) / 16;
            target[2] = cleared === 1 ? 1 : 0;
            target[3] = cleared === 2 ? 1 : 0;
            target[4] = cleared === 3 ? 1 : 0;
            target[5] = cleared === 4 ? 1 : 0;
            const area = BOARD_AREA || 1;
            target[6] = holes / area;
            target[7] = bump / BUMP_NORMALIZER;
            target[8] = HEIGHT ? maxHeight / HEIGHT : 0;
            target[9] = wellSum / area;
            target[10] = HEIGHT ? edgeWell / HEIGHT : 0;
            target[11] = HEIGHT ? tetrisWell / HEIGHT : 0;
            target[12] = contact / CONTACT_NORMALIZER;
            target[13] = rowTransitions / area;
            target[14] = colTransitions / area;
            target[15] = aggregateHeight / area;
            return target;
          }
          function featuresFromGrid(g, lines){
            return trainingProfiler.section('train.full.features', () => {
              const h = columnHeights(g);
              const Holes = countHoles(g);
              const Bump = bumpiness(h);
              let maxH = 0;
              let aggH = 0;
              for(let i=0; i<h.length; i++){
                const v = h[i] || 0;
                aggH += v;
                if(v > maxH) maxH = v;
              }
              let {wellSum, edgeWell, tetrisWell} = wellMetrics(h);
              if(Holes > 0){
                tetrisWell = 0;
              }
              const Contact = contactArea(g);
              const rT = rowTransitions(g);
              const cT = colTransitions(g);
              return fillFeatureVector(new Array(FEAT_DIM), lines, Holes, Bump, maxH, wellSum, edgeWell, tetrisWell, Contact, rT, cT, aggH);
            });
          }
          function dot(weights, feats){ let s=0; for(let d=0; d<FEAT_DIM; d++) s+=weights[d]*feats[d]; return s; }
          const mlpActivationScratch = [];
          let mlpOutputScratch = null;
          let mlpScratchDtype = null;

          function resetMlpScratchIfNeeded(dtype){
            if(mlpScratchDtype !== dtype){
              mlpScratchDtype = dtype;
              mlpActivationScratch.length = 0;
              mlpOutputScratch = null;
            }
          }

          function getMlpLayerScratch(layerIdx, size, dtype){
            let buffer = mlpActivationScratch[layerIdx];
            if(!buffer || buffer.length !== size){
              buffer = allocWeights(size, dtype);
              mlpActivationScratch[layerIdx] = buffer;
            }
            if(typeof buffer.fill === 'function'){
              buffer.fill(0);
            } else {
              for(let i = 0; i < size; i++){
                buffer[i] = 0;
              }
            }
            return buffer;
          }

          function getMlpOutputScratch(dtype){
            if(!mlpOutputScratch || mlpOutputScratch.length !== 1){
              mlpOutputScratch = allocWeights(1, dtype);
            }
            mlpOutputScratch[0] = 0;
            return mlpOutputScratch;
          }

          function mlpScore(weights, feats){
            if(!weights || !weights.length){
              return 0;
            }
            const hiddenLayers = mlpHiddenLayers.length ? mlpHiddenLayers : DEFAULT_MLP_HIDDEN;
            const dtype = (train && train.dtype)
              ? train.dtype
              : ((HAS_F16 && typeof Float16Array !== 'undefined' && weights instanceof Float16Array)
                ? 'f16'
                : (weights instanceof Float32Array ? 'f32' : DEFAULT_DTYPE));
            resetMlpScratchIfNeeded(dtype);
            let offset = 0;
            let prevSize = FEAT_DIM;
            let activations = feats;
            const weightLen = weights.length;
            for(let layerIdx = 0; layerIdx < hiddenLayers.length; layerIdx++){
              const layerSize = hiddenLayers[layerIdx];
              const weightBase = offset;
              const biasBase = weightBase + prevSize * layerSize;
              const nextActivations = getMlpLayerScratch(layerIdx, layerSize, dtype);
              const weightLimit = Math.min(biasBase, weightLen);
              for(let i = 0; i < prevSize; i++){
                const value = activations[i];
                if(!Number.isFinite(value) || value === 0){
                  continue;
                }
                const base = weightBase + i * layerSize;
                if(base >= weightLimit){
                  break;
                }
                const maxJ = Math.min(layerSize, weightLimit - base);
                for(let j = 0; j < maxJ; j++){
                  nextActivations[j] += value * weights[base + j];
                }
              }
              for(let j = 0; j < layerSize; j++){
                const biasIdx = biasBase + j;
                const sum = nextActivations[j] + (biasIdx < weightLen ? weights[biasIdx] : 0);
                nextActivations[j] = sum > 0 ? sum : 0;
              }
              offset = biasBase + layerSize;
              activations = nextActivations;
              prevSize = layerSize;
            }
            const outWeightsBase = offset;
            const outBiasIndex = outWeightsBase + prevSize;
            const outLimit = Math.min(outBiasIndex, weightLen);
            const outputScratch = getMlpOutputScratch(dtype);
            for(let i = 0; i < prevSize; i++){
              const value = activations[i];
              if(!Number.isFinite(value) || value === 0){
                continue;
              }
              const wIdx = outWeightsBase + i;
              if(wIdx >= outLimit){
                break;
              }
              outputScratch[0] += value * weights[wIdx];
            }
            const bias = (outBiasIndex < weightLen) ? weights[outBiasIndex] : 0;
            return outputScratch[0] + bias;
          }
          function scoreFeats(weights, feats){ return (train.modelType === 'mlp') ? mlpScore(weights, feats) : dot(weights, feats); }
          function choosePlacement(weights, grid, curShape){
            return trainingProfiler.section('train.plan.single', () => {
              const acts = enumeratePlacements(grid, curShape);
              if(acts.length === 0) return null;
              let best = null;
              let bestScore = -Infinity;
              // Evaluate each valid placement exactly once.
              for(const a of acts){
                const sim = simulateAfterPlacement(grid, curShape, a.rot, a.col);
                if(!sim) continue;
                const baseFeats = featuresFromGrid(sim.grid, sim.lines);
                const score = scoreFeats(weights, baseFeats);
                if(score > bestScore){
                  bestScore = score;
                  best = a;
                }
              }
              return best;
            });
          }
          function planForCurrentPiece(){
            return trainingProfiler.section('train.plan', () => {
              if(!state.active) return null;
              const w = train.currentWeightsOverride || train.candWeights[train.candIndex] || train.mean;
              // Single-ply evaluation selects the best placement for the current piece.
              const placement = choosePlacement(w, state.grid, state.active.shape);
              if(!placement){
                return null;
              }
              const len = SHAPES[state.active.shape].length;
              const cur = state.active.rot % len;
              const needRot = (placement.rot - cur + len) % len;
              return { targetRot: placement.rot, targetCol: placement.col, rotLeft: needRot, stage: 'rotate' };
            });
          }

          // Scatter plot of raw score per game (all candidates)
        function updateScorePlot(){
          const canvas = document.getElementById('score-plot');
          if(!canvas) return;
          const ctx = canvas.getContext('2d');
          const W = canvas.width, H = canvas.height;
          ctx.clearRect(0,0,W,H);

          const padL = 48;
          const padR = 24;
          const padT = 26;
          const padB = 44;
          const axisColor = 'rgba(249, 245, 255, 0.68)';
          const gridColor = 'rgba(249, 245, 255, 0.1)';

          const trainState = window.__train || null;
          const scores = (trainState && trainState.gameScores) ? trainState.gameScores : [];
          const types  = (trainState && trainState.gameModelTypes) ? trainState.gameModelTypes : [];
          const xw = Math.max(0, W - padL - padR);
          const yh = Math.max(0, H - padT - padB);

          const maxScore = scores.length ? Math.max(...scores) : 0;
          let maxY = Math.ceil(Math.max(10000, maxScore) / 10000) * 10000;
          if(!Number.isFinite(maxY) || maxY <= 0){
            maxY = 10000;
          }

          const yTicks = [];
          for(let tick = 0; tick <= maxY; tick += 10000){
            yTicks.push(tick);
          }
          if(yTicks[yTicks.length - 1] !== maxY){
            yTicks.push(maxY);
          }

          ctx.lineWidth = 1;
          ctx.strokeStyle = gridColor;
          yTicks.forEach((tick) => {
            const y = H - padB - (tick / maxY) * yh;
            ctx.beginPath();
            ctx.moveTo(padL, y);
            ctx.lineTo(W - padR, y);
            ctx.stroke();
          });

          ctx.strokeStyle = axisColor;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(padL, padT);
          ctx.lineTo(padL, H - padB);
          ctx.lineTo(W - padR, H - padB);
          ctx.stroke();

          ctx.strokeStyle = axisColor;
          ctx.lineWidth = 1;
          ctx.fillStyle = axisColor;
          ctx.font = '11px "Instrument Serif", serif';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'middle';
          yTicks.forEach((tick) => {
            const y = H - padB - (tick / maxY) * yh;
            ctx.beginPath();
            ctx.moveTo(padL - 6, y);
            ctx.lineTo(padL, y);
            ctx.stroke();
            ctx.fillText(tick.toLocaleString(), padL - 10, y);
          });

          const count = scores.length;
          if(trainState && typeof trainState.scorePlotPending !== 'number'){
            trainState.scorePlotPending = 0;
          }
          if(!count){
            if(trainState){
              trainState.scorePlotPending = 0;
              if(!trainState.scorePlotAxisMax || trainState.scorePlotAxisMax < 1){
                const baseline = Math.max(10, Math.ceil((trainState.popSize || 10) * 1.2));
                const maxCap = Math.max(1, trainState.maxPlotPoints || baseline);
                trainState.scorePlotAxisMax = Math.min(maxCap, baseline);
              }
            }
            return;
          }

          let axisMax = count;
          if(trainState){
            const maxCap = Math.max(count, trainState.maxPlotPoints || count);
            let currentAxis = Number.isFinite(trainState.scorePlotAxisMax) ? trainState.scorePlotAxisMax : 0;
            if(currentAxis < 1){
              const baseline = Math.max(10, Math.ceil((trainState.popSize || count || 5) * 1.2));
              currentAxis = Math.min(maxCap, baseline);
            }
            if(count > currentAxis){
              let next = Math.ceil(currentAxis * 1.2);
              if(!Number.isFinite(next) || next <= currentAxis){
                next = currentAxis + 1;
              }
              currentAxis = Math.min(maxCap, Math.max(next, count));
            }
            trainState.scorePlotAxisMax = currentAxis;
            trainState.scorePlotPending = 0;
            axisMax = Math.max(count, currentAxis);
          }

          const denom = axisMax > 1 ? axisMax - 1 : 1;
          const desiredTicks = Math.min(8, Math.max(3, Math.round(xw / 70)));
          let step = 1;
          if(axisMax > 1){
            const raw = denom / Math.max(1, desiredTicks - 1);
            const exponent = Math.floor(Math.log10(raw));
            const base = Math.pow(10, exponent);
            const fraction = raw / base;
            let niceFraction;
            if(fraction >= 5){
              niceFraction = 5;
            } else if(fraction >= 2){
              niceFraction = 2;
            } else {
              niceFraction = 1;
            }
            step = Math.max(1, Math.round(niceFraction * base));
          }

          const tickSet = new Set();
          for(let tick = 1; tick <= axisMax; tick += step){
            tickSet.add(Math.round(tick));
          }
          tickSet.add(axisMax);
          tickSet.add(count);
          const xTicks = Array.from(tickSet)
            .filter((tick) => tick >= 1 && tick <= axisMax)
            .sort((a,b) => a - b);

          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillStyle = axisColor;
          ctx.strokeStyle = axisColor;
          ctx.lineWidth = 1;
          xTicks.forEach((tick) => {
            const ratio = axisMax <= 1 ? 1 : (tick - 1) / denom;
            const x = padL + ratio * xw;
            ctx.beginPath();
            ctx.moveTo(x, H - padB);
            ctx.lineTo(x, H - padB + 6);
            ctx.stroke();
            ctx.fillText(String(tick), x, H - padB + 8);
          });

          const COLORS = { linear: '#76b3ff', mlp: '#ff9a6b' };
          const safeMaxY = maxY || 1;
          const pointPositions = [];
          for(let i=0; i<count; i++){
            const gameNumber = i + 1;
            const ratio = axisMax <= 1 ? 1 : (gameNumber - 1) / denom;
            const x = padL + ratio * xw;
            const y = H - padB - (scores[i] / safeMaxY) * yh;
            const color = COLORS[types[i] || 'linear'] || COLORS.linear;
            pointPositions.push({ x, y });
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.lineWidth = 1.2;
            ctx.strokeStyle = 'rgba(12, 17, 32, 0.85)';
            ctx.stroke();
          }

          if(trainState && Array.isArray(trainState.bestByGeneration) && trainState.bestByGeneration.length){
            const offset = Number.isFinite(trainState.gameScoresOffset) ? trainState.gameScoresOffset : 0;
            let selection = trainState.historySelection;
            if(selection !== null && selection !== undefined){
              selection = Math.max(0, Math.min(trainState.bestByGeneration.length - 1, Math.round(selection)));
              const snapshot = trainState.bestByGeneration[selection];
              const hasIndex = snapshot && Number.isFinite(snapshot.scoreIndex);
              if(hasIndex){
                const relative = Math.round(snapshot.scoreIndex - offset);
                if(relative >= 0 && relative < pointPositions.length){
                  const point = pointPositions[relative];
                  if(point && Number.isFinite(point.x) && Number.isFinite(point.y)){
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 7, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.25)';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 5.5, 0, Math.PI * 2);
                    ctx.fillStyle = '#3b82f6';
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#1d4ed8';
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 2.5, 0, Math.PI * 2);
                    ctx.fillStyle = '#bfdbfe';
                    ctx.fill();
                    ctx.restore();
                  }
                }
              }
            }
          }
        }

          function runAiMicroStep(){
            return trainingProfiler.section('train.ai.micro_step', () => {
              if(!state.active){
                return false;
              }

              // Watchdog: if the active piece hasn't changed state for a while, force a drop
              const sig = `${state.active.shape}:${state.active.rot}:${state.active.row}:${state.active.col}:${state.score}`;
              if(train.ai.lastSig === sig){
                train.ai.staleMs = (train.ai.staleMs || 0) + AI_STEP_MS;
              } else {
                train.ai.staleMs = 0;
                train.ai.lastSig = sig;
              }
              if(train.ai.staleMs > 1000){
                log('AI: watchdog forced drop');
                while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                lock(state.grid, state.active);
                state.pieces++;
                if(state.pieces % 20 === 0){
                  state.level++;
                  state.gravity = gravityForLevel(state.level);
                  updateLevel();
                }
                const cleared = clearRows(state.grid);
                if(cleared){
                  state.score += cleared * 100 * (cleared > 1 ? cleared : 1);
                  updateScore();
                  recordClear(cleared);
                }
                if(state.grid[0].some((v) => v !== 0)) {
                  onGameOver();
                  train.ai.plan = null;
                  train.ai.staleMs = 0;
                  return false;
                }
                spawn();
                train.ai.plan = null;
                train.ai.staleMs = 0;
                if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
                return false;
              }

              if(!train.ai.plan){
                train.ai.plan = planForCurrentPiece();
                if(!train.ai.plan){
                  // force drop to end episode
                  while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                  lock(state.grid, state.active);
                  state.pieces++;
                  if(state.pieces % 20 === 0){
                    state.level++;
                    state.gravity = gravityForLevel(state.level);
                    updateLevel();
                  }
                  const cleared = clearRows(state.grid);
                  if(cleared){
                    state.score += cleared * 100 * (cleared > 1 ? cleared : 1);
                    updateScore();
                    recordClear(cleared);
                  }
                  if(state.grid[0].some((v) => v !== 0)) {
                    log('AI: top-out after forced drop');
                    onGameOver();
                    return false;
                  }
                  spawn();
                  if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
                  return false;
                }
              }

              const plan = train.ai.plan;
              if(!plan) return true;
              if(plan.stage === 'rotate'){
                if(plan.rotLeft > 0){
                  state.active.rotate();
                  if(!canMove(state.grid, state.active, 0, 0)){
                    // Rotation blocked: abandon this plan to avoid stalling
                    state.active.rotate(-1);
                    train.ai.plan = null;
                    log('AI: rotation blocked, abandoning plan');
                  } else {
                    plan.rotLeft -= 1;
                  }
                  return true;
                }
                plan.stage = 'move';
                return true;
              }
              if(plan.stage === 'move'){
                if(state.active.col < plan.targetCol){
                  if(canMove(state.grid, state.active, 1, 0)){
                    state.active.move(1,0);
                  } else {
                    plan.stage = 'drop';
                  }
                  return true;
                }
                if(state.active.col > plan.targetCol){
                  if(canMove(state.grid, state.active, -1, 0)){
                    state.active.move(-1,0);
                  } else {
                    plan.stage = 'drop';
                  }
                  return true;
                }
                plan.stage = 'drop';
                return true;
              }
              if(plan.stage === 'drop'){
                if(canMove(state.grid, state.active, 0, 1)){
                  state.active.move(0,1);
                  return true;
                }
                lock(state.grid, state.active);
                state.pieces++;
                if(state.pieces % 20 === 0){
                  state.level++;
                  state.gravity = gravityForLevel(state.level);
                  updateLevel();
                }
                const cleared = clearRows(state.grid);
                if(cleared){
                  state.score += cleared * 100 * (cleared > 1 ? cleared : 1);
                  updateScore();
                  recordClear(cleared);
                }
                if(state.grid[0].some((v) => v !== 0)) {
                  log('AI: top-out after drop');
                  onGameOver();
                  train.ai.plan = null;
                  return false;
                }
                spawn();
                train.ai.plan = null;
                if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
                return false;
              }
              return true;
            });
          }

          function aiStep(dt){
            if(!state.active){ return; }
            if(!canMove(state.grid, state.active, 0, 0)) { log('AI: spawn blocked -> game over'); onGameOver(); return; }

            const headlessTraining = train && train.enabled && train.visualizeBoard === false;
            if(headlessTraining){
              train.ai.acc = 0;
              while(runAiMicroStep()){
                // continue stepping until the micro step signals to pause
              }
              return;
            }

            let __aiSteps = 0;
            train.ai.acc += dt;
            while (train.ai.acc >= AI_STEP_MS && __aiSteps < MAX_AI_STEPS_PER_FRAME) {
              train.ai.acc -= AI_STEP_MS;
              __aiSteps += 1;
              if(!runAiMicroStep()){
                return;
              }
            }
          }
          window.__aiStep = aiStep;

          const downloadBtn = document.getElementById('download-weights');
          if(downloadBtn){
            downloadBtn.addEventListener('click', downloadCurrentWeights);
          }
          const uploadInput = document.getElementById('upload-weights');
          const uploadBtn = document.getElementById('upload-weights-button');
          if(uploadBtn && uploadInput){
            uploadBtn.addEventListener('click', () => {
              uploadInput.click();
            });
            uploadInput.addEventListener('change', () => {
              const file = uploadInput.files && uploadInput.files[0];
              if(!file){
                return;
              }
              const reader = new FileReader();
              reader.onload = (event) => {
                try {
                  const text = typeof event.target.result === 'string' ? event.target.result : '';
                  const snapshot = parseWeightSnapshot(text);
                  applyWeightSnapshot(snapshot, { fileName: file.name });
                } catch (err) {
                  console.error(err);
                  const message = (err && err.message) ? err.message : 'unknown error';
                  log(`Failed to load weights: ${message}`);
                } finally {
                  uploadInput.value = '';
                }
              };
              reader.onerror = () => {
                log('Failed to read weight file.');
                uploadInput.value = '';
              };
              reader.readAsText(file);
            });
          }

          const handleHistorySliderInput = () => {
            if(!historySlider || !train){
              return;
            }
            if(!Array.isArray(train.bestByGeneration) || train.bestByGeneration.length === 0){
              train.historySelection = null;
            } else {
              const raw = Number(historySlider.value);
              const total = train.bestByGeneration.length;
              const sliderMax = total;
              if(!Number.isFinite(raw) || raw >= sliderMax){
                train.historySelection = null;
              } else {
                const idx = Math.min(total - 1, Math.max(0, Math.round(raw)));
                train.historySelection = idx;
              }
            }
            syncHistoryControls();
            updateTrainStatus();
            updateScorePlot();
          };
          if(historySlider){
            historySlider.addEventListener('input', handleHistorySliderInput);
            historySlider.addEventListener('change', handleHistorySliderInput);
          }

          // Hook up training buttons
          const startTrainingBtn = document.getElementById('start-training');
          if(startTrainingBtn){ startTrainingBtn.addEventListener('click', () => { if(train.enabled) stopTraining(); else startTraining(); }); }
          const resetModelBtn = document.getElementById('reset-model');
          if(resetModelBtn){ resetModelBtn.addEventListener('click', resetTraining); }
          const renderToggleInput = document.getElementById('render-toggle');
          const renderToggleLabel = document.getElementById('render-toggle-label');
          function syncRenderToggle(){
            if(!renderToggleInput) return;
            renderToggleInput.checked = !!train.visualizeBoard;
            if(renderToggleLabel){
              renderToggleLabel.dataset.active = renderToggleInput.checked ? 'true' : 'false';
            }
          }
          if(renderToggleInput){
            renderToggleInput.checked = !!train.visualizeBoard;
            renderToggleInput.addEventListener('change', () => {
              train.visualizeBoard = renderToggleInput.checked;
              syncRenderToggle();
              if(train.visualizeBoard){
                try { draw(state.grid, state.active); drawNext(state.next); } catch(_) {}
                updateScore(true); updateLevel(true);
              }
            });
          }
          syncRenderToggle();
          initMlpConfigUi();
          const modelSel = document.getElementById('model-select');
          function setModelType(mt){
            if(mt !== 'linear' && mt !== 'mlp') return;
            const wasRunning = train.enabled;
            if(wasRunning) stopTraining();
            train.modelType = mt;
            currentModelType = mt;
            train.mlpHiddenLayers = mlpHiddenLayers.slice();
            // Prefer f16 for MLP if available, else f32
            train.dtype = (mt==='mlp' && HAS_F16) ? 'f16' : 'f32';
            // Re-init mean/std to the appropriate initial values for this model
            train.mean = initialMean(mt);
            train.std  = initialStd(mt);
            updateTrainStatus();
            // Reset training state
            resetTraining();
            syncMlpConfigVisibility();
            if(wasRunning) startTraining();
          }
          if(modelSel){ modelSel.addEventListener('change', (e) => setModelType(modelSel.value)); }
          updateTrainStatus();
        })();
      })();
    </script>
  </body>
</html>

