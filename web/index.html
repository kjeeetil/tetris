<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://pyscript.net https://cdn.jsdelivr.net data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://pyscript.net https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://pyscript.net; connect-src 'self' https://pyscript.net https://cdn.jsdelivr.net data: blob:; img-src 'self' data:;" />
    <title>Tetris</title>
    
    <style>
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        padding: 0;
      }
      #canvas {
        margin: 0;
        border: 2px solid #000;
        display: block;
      }
      .game {
        margin: 24px auto 0 auto;
        display: flex;
        gap: 16px;
        justify-content: center;
        align-items: flex-start;
        max-width: 560px;
      }
      .sidebar {
        width: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }
      .panel {
        width: 160px;
        padding: 8px;
        border: 1px solid #ccc;
        background: #fdfdfd;
      }
      .panel-title {
        font-size: 12px;
        color: #555;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        margin-bottom: 6px;
      }
      #preview {
        display: block;
        width: 160px;
        height: 160px;
        border: 1px solid #eee;
        background: #fff;
      }
      #score {
        font-family: Georgia, "Times New Roman", "Palatino Linotype", "Book Antiqua", serif;
        font-size: 22px;
        line-height: 1.2;
        color: #222;
      }
      .controls {
        margin: 12px auto;
        display: flex;
        gap: 8px;
        justify-content: center;
        align-items: center;
      }
      #diagnostics {
        width: 320px;
        height: 140px;
        margin: 12px auto 24px auto;
        padding: 8px;
        border: 1px solid #ccc;
        background: #fafafa;
        text-align: left;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
      }
      /* No external runtimes required; pure JS renderer */
    </style>
  </head>
  <body>
    <h1>Tetris</h1>
    <noscript>
      <div style="color:#b00020;margin:12px;">JavaScript is disabled. Enable it to run PyScript/pygame.</div>
    </noscript>
    <div class="game">
      <canvas id="canvas" width="300" height="600" tabindex="0"></canvas>
      <div class="sidebar">
        <div class="panel">
          <div class="panel-title">Next</div>
          <canvas id="preview" width="160" height="160"></canvas>
        </div>
        <div id="score">Score: 0</div>
      </div>
    </div>
    <div class="controls">
      <button id="start">Start</button>
      <button id="pause">Pause</button>
      <button id="resume">Resume</button>
      <button id="stop">Stop</button>
    </div>
    <div id="diagnostics" aria-live="polite"></div>
    <script>
      // --- Minimal Tetris in plain JavaScript (no PyScript) ---
      (function () {
        const canvas = document.getElementById('canvas');
        const preview = document.getElementById('preview');
        const diag = document.getElementById('diagnostics');
        const scoreEl = document.getElementById('score');
        const ctx = canvas.getContext('2d');
        const pctx = preview.getContext('2d');
        const CELL = 30, WIDTH = 10, HEIGHT = 20;
        const GRAVITY_MS = 500;
        const PREV_CELL = 28; // slightly smaller cell for preview

        const log = (t) => {
          if (!diag) return;
          const d = document.createElement('div');
          const now = new Date().toLocaleTimeString();
          d.textContent = `[${now}] ${t}`;
          diag.prepend(d);
        };

        const Shapes = {
          I: [[0,0],[0,1],[0,2],[0,3]],
          O: [[0,0],[0,1],[1,0],[1,1]],
          T: [[0,0],[0,1],[0,2],[1,1]],
          S: [[0,1],[0,2],[1,0],[1,1]],
          Z: [[0,0],[0,1],[1,1],[1,2]],
          J: [[0,0],[1,0],[1,1],[1,2]],
          L: [[0,2],[1,0],[1,1],[1,2]],
        };

        const rotate = (state) => {
          const rot = state.map(([r,c]) => [c, -r]);
          let minR = Math.min(...rot.map(([r]) => r));
          let minC = Math.min(...rot.map(([,c]) => c));
          return rot.map(([r,c]) => [r - minR, c - minC]);
        };

        const genRotations = (s) => {
          const r = [s];
          for (let i=0;i<3;i++) r.push(s = rotate(s));
          return r;
        };

        const SHAPES = {};
        for (const k of Object.keys(Shapes)) SHAPES[k] = genRotations(Shapes[k]);

        const emptyGrid = () => Array.from({length: HEIGHT}, () => Array(WIDTH).fill(0));

        class Piece {
          constructor(shape){ this.shape = shape; this.rot = 0; this.row = 0; this.col = Math.floor(WIDTH/2) - 2; }
          blocks(){ const s = SHAPES[this.shape][this.rot]; return s.map(([dr,dc]) => [this.row+dr, this.col+dc]); }
          move(dx,dy){ this.col += dx; this.row += dy; }
          rotate(dir=1){ const states = SHAPES[this.shape]; this.rot = (this.rot + (dir>=0?1:states.length-1)) % states.length; }
        }

        const canMove = (grid, piece, dx, dy) => {
          for(const [r,c] of piece.blocks()){
            const nr = r + dy, nc = c + dx;
            if (nr < 0 || nr >= HEIGHT || nc < 0 || nc >= WIDTH) return false;
            if (grid[nr][nc] !== 0) return false;
          }
          return true;
        };

        const lock = (grid, piece) => { for(const [r,c] of piece.blocks()) grid[r][c] = 1; };

        const clearRows = (grid) => {
          let remaining = grid.filter(row => row.some(v => v===0));
          const cleared = HEIGHT - remaining.length;
          while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0));
          for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r];
          return cleared;
        };

        const SHAPE_COLORS = {
          I: '#00ffff', O: '#ffff00', T: '#800080', S: '#00ff00', Z: '#ff0000', J: '#0000ff', L: '#ffa500'
        };

        function draw(grid, active){
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,WIDTH*CELL,HEIGHT*CELL);
          // locked
          for(let r=0;r<HEIGHT;r++){
            for(let c=0;c<WIDTH;c++){
              if(grid[r][c]){ ctx.fillStyle = '#444'; ctx.fillRect(c*CELL,r*CELL,CELL,CELL); }
              ctx.strokeStyle = '#333'; ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);
            }
          }
          // active
          if(active){ ctx.fillStyle = '#6cf'; for(const [r,c] of active.blocks()){ ctx.fillRect(c*CELL,r*CELL,CELL,CELL); ctx.strokeStyle = '#333'; ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);} }
        }

        function drawNext(shape){
          const W = preview.width, H = preview.height;
          pctx.fillStyle = '#ffffff'; pctx.fillRect(0,0,W,H);
          pctx.strokeStyle = '#f0f0f0'; pctx.strokeRect(0,0,W,H);
          if(!shape) return;
          const state = SHAPES[shape][0];
          let minR=Infinity, minC=Infinity, maxR=-Infinity, maxC=-Infinity;
          for(const [r,c] of state){ minR=Math.min(minR,r); minC=Math.min(minC,c); maxR=Math.max(maxR,r); maxC=Math.max(maxC,c); }
          const w = (maxC-minC+1)*PREV_CELL; const h = (maxR-minR+1)*PREV_CELL;
          const offX = Math.floor((W - w)/2); const offY = Math.floor((H - h)/2);
          pctx.fillStyle = SHAPE_COLORS[shape] || '#6cf';
          for(const [r,c] of state){
            const x = offX + (c-minC)*PREV_CELL;
            const y = offY + (r-minR)*PREV_CELL;
            pctx.fillRect(x, y, PREV_CELL, PREV_CELL);
            pctx.strokeStyle = '#dddddd';
            pctx.strokeRect(x, y, PREV_CELL, PREV_CELL);
          }
        }

        function updateScore(){ if(scoreEl) scoreEl.textContent = `Score: ${state.score}`; }

        const state = { grid: emptyGrid(), active: null, next: null, score: 0, running:false, paused:false, last:0, acc:0, raf:null };

        const shapes = Object.keys(SHAPES);
        const randShape = () => shapes[Math.floor(Math.random()*shapes.length)];

        const spawn = () => { const s = state.next || randShape(); state.active = new Piece(s); state.next = randShape(); drawNext(state.next); updateScore(); };

        function tick(ts){
          if(!state.running){ return; }
          if(!state.last) state.last = ts;
          const dt = ts - state.last; state.last = ts;
          if(!state.paused && state.active){
            state.acc += dt;
            if(state.acc >= GRAVITY_MS){
              state.acc = 0;
              if(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
              else { lock(state.grid, state.active); const cleared = clearRows(state.grid); if(cleared){ state.score += cleared*100; updateScore(); log(`Cleared ${cleared} row(s). Score: ${state.score}`); } spawn(); if(!canMove(state.grid, state.active, 0, 0)){ log('Game over. Resetting.'); Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0}); spawn(); } }
            }
          }
          draw(state.grid, state.active);
          state.raf = requestAnimationFrame(tick);
        }

        function start(){ if(state.running){ log('Already running'); return; } canvas.focus(); state.grid = emptyGrid(); state.score=0; updateScore(); state.last=0; state.acc=0; state.running=true; state.paused=false; spawn(); draw(state.grid, state.active); state.raf = requestAnimationFrame(tick); log('Game started'); }
        function pause(){ if(!state.running){ log('Pause ignored: not running'); return; } state.paused=true; log('Paused'); }
        function resume(){ if(!state.running){ log('Resume ignored: not running'); return; } state.paused=false; log('Resumed'); }
        function stop(){ if(!state.running){ log('Stop ignored: not running'); return; } state.running=false; state.paused=false; if(state.raf) cancelAnimationFrame(state.raf); log('Game stopped'); }

        // keyboard
        const BLOCK_KEYS = new Set(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','PageUp','PageDown','Home','End']);
        document.addEventListener('keydown', (e) => {
          if(!state.running) return;
          if (BLOCK_KEYS.has(e.key)) e.preventDefault();
          if(state.paused || !state.active) return;
          if(e.key==='ArrowLeft' && canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0);
          else if(e.key==='ArrowRight' && canMove(state.grid, state.active, 1, 0)) state.active.move(1,0);
          else if(e.key==='ArrowUp'){ state.active.rotate(); if(!canMove(state.grid, state.active, 0, 0)) state.active.rotate(-1); }
          else if(e.key==='ArrowDown' && canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
          else if(e.key===' '){ while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1); lock(state.grid, state.active); const cleared = clearRows(state.grid); if(cleared){ state.score += cleared*100; updateScore(); log(`Cleared ${cleared} row(s). Score: ${state.score}`);} spawn(); }
          draw(state.grid, state.active);
        });

        // buttons
        document.getElementById('start').addEventListener('click', start);
        document.getElementById('pause').addEventListener('click', pause);
        document.getElementById('resume').addEventListener('click', resume);
        document.getElementById('stop').addEventListener('click', stop);

        log('Ready. Click Start to run.');
      })();
    </script>
  </body>
</html>

