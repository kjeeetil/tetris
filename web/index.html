<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://pyscript.net https://cdn.jsdelivr.net data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://pyscript.net https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://pyscript.net; connect-src 'self' https://pyscript.net https://cdn.jsdelivr.net data: blob:; img-src 'self' data:;" />
    <title>Tetris</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
    
    <style>
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        padding: 0;
      }
      #canvas {
        margin: 0;
        border: 2px solid #000;
        display: block;
      }
      .game {
        margin: 24px auto 0 auto;
        display: flex;
        gap: 16px;
        justify-content: center;
        align-items: flex-start;
        max-width: 560px;
      }
      .sidebar {
        width: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }
      .panel {
        width: 160px;
        padding: 8px;
        border: 1px solid #ccc;
        background: #fdfdfd;
      }
      .panel-title {
        font-size: 12px;
        color: #555;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        margin-bottom: 6px;
      }
      #preview {
        display: block;
        width: 160px;
        height: 160px;
        border: 1px solid #eee;
        background: #fff;
      }
      #score {
        font-family: Georgia, "Times New Roman", "Palatino Linotype", "Book Antiqua", serif;
        font-size: 22px;
        line-height: 1.2;
        color: #222;
      }
      .controls {
        margin: 12px auto;
        display: flex;
        gap: 12px;
        justify-content: center;
        align-items: center;
      }
      .icon-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: 1px solid #bbb;
        background: #fff;
        font-size: 20px;
        line-height: 44px;
        cursor: pointer;
        box-shadow: 0 1px 2px rgba(0,0,0,0.08);
      }
      .icon-btn:active { transform: translateY(1px); }
      #diagnostics {
        width: 320px;
        height: 140px;
        margin: 12px auto 24px auto;
        padding: 8px;
        border: 1px solid #ccc;
        background: #fafafa;
        text-align: left;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
      }
      @media (max-width: 600px) {
        .game {
          flex-direction: column;
          max-width: 100%;
          align-items: center;
        }
        #canvas {
          width: 90vw;
          height: auto;
          max-width: 300px;
          margin: 0 auto;
        }
        .sidebar {
          width: 100%;
          flex-direction: row;
          justify-content: center;
        }
        .panel {
          width: auto;
        }
        #preview {
          width: 80px;
          height: 80px;
        }
        .controls {
          flex-wrap: wrap;
        }
        .icon-btn {
          width: 56px;
          height: 56px;
          font-size: 24px;
          line-height: 56px;
        }
      }
      /* No external runtimes required; pure JS renderer */
    </style>
  </head>
  <body>
    <h1>Tetris</h1>
    <noscript>
      <div style="color:#b00020;margin:12px;">JavaScript is disabled. Enable it to play.</div>
    </noscript>
    <div class="game">
      <canvas id="canvas" width="300" height="600" tabindex="0"></canvas>
      <div class="sidebar">
        <div class="panel">
          <div class="panel-title">Next</div>
          <canvas id="preview" width="160" height="160"></canvas>
        </div>
        <div class="panel">
          <div class="panel-title">Training Progress</div>
          <canvas id="score-plot" width="160" height="120"></canvas>
        </div>
        <div id="level">Level: 0</div>
        <div id="score">Score: 0</div>
      </div>
    </div>
    <div class="controls">
      <button id="toggle" class="icon-btn" title="Play/Pause" aria-label="Play/Pause">▶</button>
      <button id="reset" class="icon-btn" title="Reset" aria-label="Reset">⟲</button>
    </div>
    <div class="controls">
      <button id="train" class="icon-btn" title="Start/Stop Training" aria-label="Start/Stop Training">AI</button>
      <button id="train-reset" class="icon-btn" title="Reset Training" aria-label="Reset Training">♻️</button>
    </div>
    <div class="controls">
      <label for="model-select">Model:</label>
      <select id="model-select">
        <option value="linear" selected>Linear (ES)</option>
        <option value="mlp">MLP (tf.js)</option>
      </select>
    </div>
    <div class="controls">
      <label for="speed" id="speed-label">Speed: <span id="speed-display">1x</span></label>
      <input id="speed" type="range" min="1" max="50" value="1" />
    </div>
    <div id="train-status"></div>
    <div id="weights-display"></div>
    <div id="diagnostics" aria-live="polite"></div>
    <script>
      // --- Minimal Tetris in plain JavaScript (no PyScript) ---
      (function () {
        const canvas = document.getElementById('canvas');
        const preview = document.getElementById('preview');
        const diag = document.getElementById('diagnostics');
        const MAX_LOG_LINES = 200;
        const trainStatus = document.getElementById('train-status');
        const weightsEl = document.getElementById('weights-display');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const ctx = canvas.getContext('2d');
        const pctx = preview.getContext('2d');
        const CELL = 30, WIDTH = 10, HEIGHT = 20;
        const PREV_CELL = 28; // slightly smaller cell for preview
        // Performance tuning caps
        const MAX_AI_STEPS_PER_FRAME = 64;
        const speedSlider = document.getElementById('speed');
        const speedDisplay = document.getElementById('speed-display');
        let speedMult = 1;
        if (speedSlider) {
          speedSlider.addEventListener('input', () => {
            speedMult = Number(speedSlider.value);
            if (speedDisplay) speedDisplay.textContent = `${speedMult}x`;
            if (state.running) {
              clearTimeout(state.raf);
              scheduleNext();
            }
          });
        }

        const log = (t) => {
          if (!diag) return;
          const d = document.createElement('div');
          const now = new Date().toLocaleTimeString();
          d.textContent = `[${now}] ${t}`;
          diag.prepend(d);
          // Trim log to avoid unbounded DOM growth
          while (diag.childElementCount > MAX_LOG_LINES) {
            diag.removeChild(diag.lastChild);
          }
        };

        const Shapes = {
          I: [[0,0],[0,1],[0,2],[0,3]],
          O: [[0,0],[0,1],[1,0],[1,1]],
          T: [[0,0],[0,1],[0,2],[1,1]],
          S: [[0,1],[0,2],[1,0],[1,1]],
          Z: [[0,0],[0,1],[1,1],[1,2]],
          J: [[0,0],[1,0],[1,1],[1,2]],
          L: [[0,2],[1,0],[1,1],[1,2]],
        };

        const rotate = (state) => {
          const rot = state.map(([r,c]) => [c, -r]);
          let minR = Math.min(...rot.map(([r]) => r));
          let minC = Math.min(...rot.map(([,c]) => c));
          return rot.map(([r,c]) => [r - minR, c - minC]);
        };

        const genRotations = (s) => {
          const r = [s];
          for (let i=0;i<3;i++) r.push(s = rotate(s));
          return r;
        };

        const SHAPES = {};
        for (const k of Object.keys(Shapes)) SHAPES[k] = genRotations(Shapes[k]);

        const emptyGrid = () => Array.from({length: HEIGHT}, () => Array(WIDTH).fill(0));

        // Level speed table roughly matching classic NES Tetris
        const LEVEL_FRAMES = {
          0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6,
          10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2,
          20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1
        };
        const gravityForLevel = (lvl) => {
          const frames = LEVEL_FRAMES[Math.min(lvl,29)];
          return (frames/60)*1000; // convert frames to ms
        };

        class Piece {
          constructor(shape){ this.shape = shape; this.rot = 0; this.row = 0; this.col = Math.floor(WIDTH/2) - 2; }
          blocks(){ const s = SHAPES[this.shape][this.rot]; return s.map(([dr,dc]) => [this.row+dr, this.col+dc]); }
          move(dx,dy){ this.col += dx; this.row += dy; }
          rotate(dir=1){ const states = SHAPES[this.shape]; this.rot = (this.rot + (dir>=0?1:states.length-1)) % states.length; }
        }

        const canMove = (grid, piece, dx, dy) => {
          for(const [r,c] of piece.blocks()){
            const nr = r + dy, nc = c + dx;
            if (nr < 0 || nr >= HEIGHT || nc < 0 || nc >= WIDTH) return false;
            if (grid[nr][nc] !== 0) return false;
          }
          return true;
        };

        const lock = (grid, piece) => { for(const [r,c] of piece.blocks()) grid[r][c] = piece.shape; };

        const clearRows = (grid) => {
          let remaining = grid.filter(row => row.some(v => v===0));
          const cleared = HEIGHT - remaining.length;
          while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0));
          for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r];
          return cleared;
        };

        const SHAPE_COLORS = {
          I: '#00ffff', O: '#ffff00', T: '#800080', S: '#00ff00', Z: '#ff0000', J: '#0000ff', L: '#ffa500'
        };

        function draw(grid, active){
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,WIDTH*CELL,HEIGHT*CELL);
          // locked
          for(let r=0;r<HEIGHT;r++){
            for(let c=0;c<WIDTH;c++){
              const val = grid[r][c];
              if(val){ ctx.fillStyle = SHAPE_COLORS[val] || '#444'; ctx.fillRect(c*CELL,r*CELL,CELL,CELL); }
              ctx.strokeStyle = '#333'; ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);
            }
          }
          // active
          if(active){ ctx.fillStyle = SHAPE_COLORS[active.shape] || '#6cf'; for(const [r,c] of active.blocks()){ ctx.fillRect(c*CELL,r*CELL,CELL,CELL); ctx.strokeStyle = '#333'; ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);} }
        }

        function drawNext(shape){
          const W = preview.width, H = preview.height;
          pctx.fillStyle = '#ffffff'; pctx.fillRect(0,0,W,H);
          pctx.strokeStyle = '#f0f0f0'; pctx.strokeRect(0,0,W,H);
          if(!shape) return;
          const state = SHAPES[shape][0];
          let minR=Infinity, minC=Infinity, maxR=-Infinity, maxC=-Infinity;
          for(const [r,c] of state){ minR=Math.min(minR,r); minC=Math.min(minC,c); maxR=Math.max(maxR,r); maxC=Math.max(maxC,c); }
          const w = (maxC-minC+1)*PREV_CELL; const h = (maxR-minR+1)*PREV_CELL;
          const offX = Math.floor((W - w)/2); const offY = Math.floor((H - h)/2);
          pctx.fillStyle = SHAPE_COLORS[shape] || '#6cf';
          for(const [r,c] of state){
            const x = offX + (c-minC)*PREV_CELL;
            const y = offY + (r-minR)*PREV_CELL;
            pctx.fillRect(x, y, PREV_CELL, PREV_CELL);
            pctx.strokeStyle = '#dddddd';
            pctx.strokeRect(x, y, PREV_CELL, PREV_CELL);
          }
        }

        // Record cleared line counts for training fitness (safe no-op if training is off)
        function recordClear(lines){
          try {
            const tr = window.__train;
            if(tr && tr.enabled){
              if(!tr.clearCounts) tr.clearCounts = {1:0,2:0,3:0,4:0};
              if(lines>=1 && lines<=4){ tr.clearCounts[lines] = (tr.clearCounts[lines]||0) + 1; }
            }
          } catch(_) { /* ignore */ }
        }

        function updateScore(){ if(scoreEl) scoreEl.textContent = `Score: ${state.score}`; }
        function updateLevel(){ if(levelEl) levelEl.textContent = `Level: ${state.level}`; }

        const state = { grid: emptyGrid(), active: null, next: null, score: 0, level:0, pieces:0, running:false, paused:false, last:0, acc:0, gravity:gravityForLevel(0), raf:null, wdAcc:0, lastSig:'', renderEvery:1, renderCounter:0 };

        const shapes = Object.keys(SHAPES);
        const randShape = () => shapes[Math.floor(Math.random()*shapes.length)];

        const spawn = () => { const s = state.next || randShape(); state.active = new Piece(s); state.next = randShape(); drawNext(state.next); updateScore(); updateLevel(); };

        const scheduleNext = () => {
          // Run the main loop at a steady ~60 FPS; speed multiplier is applied
          // inside the loop by scaling the effective delta time.
          const delay = 1000 / 60;
          state.raf = setTimeout(() => tick(performance.now()), delay);
        };

        function updateRenderDecimation(){
          // Default: draw every frame; this can be expanded later to skip frames
          state.renderEvery = 1;
          state.renderCounter = 0;
        }

function tick(ts){
          try {
            if(!state.running){ return; }
            if(!state.last) state.last = ts;
            const dt = ts - state.last; state.last = ts;
            const effDt = dt * speedMult;
            // Watchdog: detect lack of progress for > 2s wall time and reset
            const curSig = state.active ? `${state.active.shape}:${state.active.rot}:${state.active.row}:${state.active.col}:${state.score}:${state.pieces}` : `none:${state.score}:${state.pieces}`;
            if(curSig === state.lastSig){ state.wdAcc += dt; } else { state.wdAcc = 0; state.lastSig = curSig; }
            if(state.wdAcc > 2000 && !state.paused){ log('Watchdog: no progress for 2s -> game over'); window.__onGameOver(); state.wdAcc = 0; }
            // Fallback: ensure there is always an active piece when running
            if(!state.paused && !state.active){
              spawn();
              if(!canMove(state.grid, state.active, 0, 0)) { log('Tick: spawned into block -> game over'); window.__onGameOver(); return; }
            }
            if(!state.paused && state.active){
              // Global guard: if the active piece cannot exist at its current
              // position (e.g., spawn collision), trigger game over/reset.
              if(!canMove(state.grid, state.active, 0, 0)){
                log('Tick: spawn blocked -> game over');
                window.__onGameOver();
                return;
              }
              if(window.__train && window.__train.enabled){
                window.__aiStep(effDt);
              } else {
                state.acc += effDt;
                while(state.acc >= state.gravity){
                  state.acc -= state.gravity;
                  if(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                  else {
                    lock(state.grid, state.active);
                    state.pieces++;
                    if(state.pieces % 20 === 0){
                      state.level++;
                      state.gravity = gravityForLevel(state.level);
                      updateLevel();
                    }
                    const cleared = clearRows(state.grid);
                    if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                    // Top-out guard after lock/clear in manual mode
                    if(state.grid[0].some(v => v !== 0)) { window.__onGameOver(); }
                    else {
                      spawn();
                      if(!canMove(state.grid, state.active, 0, 0)){ window.__onGameOver(); }
                    }
                  }
                }
              }
            }
          } catch (e) {
            try { log(`Tick error: ${e && e.message ? e.message : e}`); } catch(_) {}
            try { window.__onGameOver(); } catch(_) {}
          } finally {
            try {
              if(state.renderEvery <= 1){
                draw(state.grid, state.active);
              } else {
                if(state.renderCounter <= 0){
                  draw(state.grid, state.active);
                  state.renderCounter = state.renderEvery - 1;
                } else {
                  state.renderCounter -= 1;
                }
              }
            } catch(_) {}
            scheduleNext();
          }
        }

        function start(){ if(state.running){ log('Already running'); return; } canvas.focus(); state.grid = emptyGrid(); state.score=0; state.level=0; state.pieces=0; state.gravity=gravityForLevel(0); updateScore(); updateLevel(); state.last=0; state.acc=0; state.wdAcc=0; state.lastSig=''; state.running=true; state.paused=false; updateRenderDecimation(); spawn(); draw(state.grid, state.active); scheduleNext(); log('Game started'); renderControls(); }
        function pause(){ if(!state.running){ log('Pause ignored: not running'); return; } state.paused=true; log('Paused'); }
        function resume(){ if(!state.running){ log('Resume ignored: not running'); return; } state.paused=false; log('Resumed'); }
        function stop(){ if(!state.running){ log('Stop ignored: not running'); return; } state.running=false; state.paused=false; if(state.raf) clearTimeout(state.raf); state.raf=null; log('Game stopped'); renderControls(); }

        // Toggle + reset controls
        const toggleBtn = document.getElementById('toggle');
        const resetBtn = document.getElementById('reset');
        function renderControls(){ toggleBtn.textContent = (!state.running || state.paused) ? '▶' : '⏸'; }
        function togglePlayPause(){ if(!state.running){ start(); } else if(state.paused){ resume(); } else { pause(); } renderControls(); }
        function resetGame(){ if(state.running){ stop(); } start(); }

        // keyboard
        const BLOCK_KEYS = new Set(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','PageUp','PageDown','Home','End']);
        document.addEventListener('keydown', (e) => {
          if(!state.running) return;
          if (BLOCK_KEYS.has(e.key)) e.preventDefault();
          if(state.paused || !state.active || (window.__train && window.__train.enabled)) return;
          if(e.key==='ArrowLeft' && canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0);
          else if(e.key==='ArrowRight' && canMove(state.grid, state.active, 1, 0)) state.active.move(1,0);
          else if(e.key==='ArrowUp'){ state.active.rotate(); if(!canMove(state.grid, state.active, 0, 0)) state.active.rotate(-1); }
          else if(e.key==='ArrowDown' && canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
          else if(e.key===' '){
            while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
            lock(state.grid, state.active);
            state.pieces++;
            if(state.pieces % 20 === 0){
              state.level++;
              state.gravity = gravityForLevel(state.level);
              updateLevel();
            }
            const cleared = clearRows(state.grid);
            if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared);} 
            if(state.grid[0].some(v => v !== 0)) { onGameOver(); }
            else { spawn(); if(!canMove(state.grid, state.active, 0, 0)) onGameOver(); }
          }
          draw(state.grid, state.active);
        });

        // buttons
        toggleBtn.addEventListener('click', togglePlayPause);
        resetBtn.addEventListener('click', resetGame);

        log('Ready. Click Start to run.');
        renderControls();

        // ================= AI Training (placement-level with animation) =================
        // Expose minimal API on window to avoid invasive edits above
        (function(){
          // Features: [lines, lines2, is1, is2, is3, is4, holes, bumpiness, maxH]
          const FEAT_DIM = 9;
          const AI_STEP_MS = 28; // ms between AI animation steps
          const LOOKAHEAD_LAMBDA = 0.7; // weight for next-piece lookahead score
          const LOOKAHEAD_BEAM = 6; // evaluate next-piece lookahead only for top-K first moves
          const SCORE_WEIGHT = 3.0; // emphasize final score in fitness

          // MLP architecture (when selected)
          const MLP_H1 = 8; // hidden units (smaller for speed)
          const MLP_PARAM_DIM = FEAT_DIM*MLP_H1 + MLP_H1 + MLP_H1*1 + 1; // W1 + b1 + W2 + b2

          // Initial weights for Linear model (intentionally poor to make the very first attempt worse)
          // Order: [lines, lines2, is1, is2, is3, is4, holes, bumpiness, maxH]
          const INITIAL_MEAN_LINEAR = new Float64Array([0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.4, 0.2, 0.1]);
          const INITIAL_STD_LINEAR  = new Float64Array([0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4]);
          const INITIAL_MEAN_MLP    = new Float64Array(MLP_PARAM_DIM).fill(0.0);
          const INITIAL_STD_MLP     = new Float64Array(MLP_PARAM_DIM).fill(0.2);

          function paramDim(){ return (train && train.modelType === 'mlp') ? MLP_PARAM_DIM : FEAT_DIM; }
          function initialMean(model){ return model === 'mlp' ? new Float64Array(INITIAL_MEAN_MLP) : new Float64Array(INITIAL_MEAN_LINEAR); }
          function initialStd(model){ return model === 'mlp' ? new Float64Array(INITIAL_STD_MLP) : new Float64Array(INITIAL_STD_LINEAR); }

          const train = {
            enabled: false,
            gen: 0,
            popSize: 16,
            eliteFrac: 0.25,
            modelType: 'linear',
            mean: new Float64Array(INITIAL_MEAN_LINEAR),
            std: new Float64Array(INITIAL_STD_LINEAR),
            minStd: 0.05,
            maxStd: 3.0,
            candWeights: [],
            candScores: [],
            candIndex: -1,
            phase: 'eval',
            reevalRuns: 3,
            reevalDone: 0,
            reevalAccum: 0,
            reevalTarget: -1,
            currentWeightsOverride: null,
            ai: { plan: null, acc: 0 },
            clearCounts: {1:0,2:0,3:0,4:0},
            gameScores: [],
            gameModelTypes: [],
            bestFitness: -Infinity,
            bestEverFitness: -Infinity,
            bestEverWeights: null,
            genNoImprove: 0,
            // exploration config
            heavyTailFrac: 0.25,
            heavyTailScale: 3.0,
            plateauGens: 8,
            stdBoost: 1.8,
            maxPlotPoints: 4000,
          };
          window.__train = train;

          function formatWeights(arr){ const MAX_SHOW = 24; const vals = Array.from(arr).slice(0, MAX_SHOW).map(v=>Number.isFinite(v)?v.toFixed(2):String(v)); const suffix = arr.length>MAX_SHOW? ' …' : ''; return vals.join(', ') + suffix; }
          function updateTrainStatus(){
            if(trainStatus){
              if(train.enabled){
                trainStatus.textContent = `Gen ${train.gen+1}, Candidate ${train.candIndex+1}/${train.popSize} — Model: ${train.modelType.toUpperCase()}`;
              } else {
                trainStatus.textContent = `Training stopped — Model: ${train.modelType.toUpperCase()}`;
              }
            }
            if(weightsEl){
              const w = train.enabled ? train.candWeights[train.candIndex] : train.mean;
              weightsEl.textContent = w ? `Weights: ${formatWeights(w)}` : '';
            }
          }

          function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
          function samplePopulation(){
            const dim = paramDim();
            train.candWeights = [];
            const heavyCount = Math.floor(train.heavyTailFrac * train.popSize);
            for(let i=0;i<train.popSize;i++){
              const w = new Float64Array(dim);
              const scale = (i < heavyCount) ? (train.heavyTailScale) : 1.0;
              for(let d=0; d<dim; d++) w[d] = train.mean[d] + (train.std[d] || train.minStd) * scale * randn();
              train.candWeights.push(w);
            }
            // Ensure the very first attempt (gen 0, cand 0) uses the mean weights (intentionally poor)
            if(train.gen === 0 && train.candWeights.length > 0){
              train.candWeights[0] = new Float64Array(train.mean);
            }
            train.candScores = new Array(train.popSize).fill(0);
            train.candIndex = 0;
            train.clearCounts = {1:0,2:0,3:0,4:0};
          }

          function startTraining(){
            if(!state.running){ start(); }
            train.enabled = true; train.gen = 0; train.ai.plan = null; train.ai.acc = 0; samplePopulation();
            train.gameScores = [];
            train.phase = 'eval'; train.currentWeightsOverride = null; train.reevalDone = 0; train.reevalAccum = 0; train.reevalTarget = -1;
            updateTrainStatus();
            const btn = document.getElementById('train'); if(btn) btn.textContent = '⏹';
            log('Training started');
          }
          function stopTraining(){ train.enabled = false; train.ai.plan = null; const btn = document.getElementById('train'); if(btn) btn.textContent = 'AI'; log('Training stopped'); updateTrainStatus(); }
          function resetTraining(){
            stopTraining();
            // Reset mean/std based on selected model
            train.mean = initialMean(train.modelType);
            train.std = initialStd(train.modelType);
            train.gen = 0;
            train.candWeights = [];
            train.candScores = [];
            train.candIndex = -1;
            train.ai.plan = null;
            train.ai.acc = 0;
            train.clearCounts = {1:0,2:0,3:0,4:0};
            train.gameScores = [];
            train.phase = 'eval'; train.currentWeightsOverride = null; train.reevalDone = 0; train.reevalAccum = 0; train.reevalTarget = -1; train.bestFitness = -Infinity; train.bestEverFitness = -Infinity; train.bestEverWeights = null;
            updateScorePlot();
            updateTrainStatus();
            log('Training parameters reset');
          }
          window.startTraining = startTraining; window.stopTraining = stopTraining; window.resetTraining = resetTraining;

          function onGameOver(){
            log('Game over. Resetting.');
            if(train.enabled){
              // Shaped fitness: prefer multi-line clears and discourage singles
              const c = train.clearCounts || {1:0,2:0,3:0,4:0};
              const c1 = c[1] || 0, c2 = c[2] || 0, c3 = c[3] || 0, c4 = c[4] || 0;
              const fitness = SCORE_WEIGHT*state.score + 100*(4*c4 + 2*c3 + 1*c2) - 100*c1;
              if(train.candIndex >= 0) train.candScores[train.candIndex] = fitness;
              // Append raw score for progress plot and mark model type
              train.gameScores.push(state.score);
              train.gameModelTypes.push(train.modelType);
              // Cap data arrays to bound memory
              const cap = train.maxPlotPoints;
              if (train.gameScores.length > cap) {
                train.gameScores.splice(0, train.gameScores.length - cap);
                train.gameModelTypes.splice(0, train.gameModelTypes.length - cap);
              }
              updateScorePlot();
              // Re-evaluation phase handling
              if(train.phase === 'reeval'){
                train.reevalAccum += fitness; train.reevalDone += 1;
                if(train.reevalDone < train.reevalRuns){
                  Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                  state.gravity = gravityForLevel(0);
                  updateLevel(); updateScore();
                  spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                  updateTrainStatus();
                  return;
                } else {
                  const avgFit = train.reevalAccum / train.reevalRuns;
                  if(train.reevalTarget >= 0) train.candScores[train.reevalTarget] = avgFit;
                  train.currentWeightsOverride = null; train.phase = 'eval';
                  // Complete generation update after re-eval
                  const idx = [...train.candScores.keys()].sort((a,b)=>train.candScores[b]-train.candScores[a]);
                  const eliteCount = Math.max(1, Math.floor(train.eliteFrac * train.popSize));
                  const elites = idx.slice(0, eliteCount);
                  const dim = paramDim();
                  const eliteMean = new Float64Array(dim);
                  for(const ei of elites){ const w = train.candWeights[ei]; for(let d=0; d<dim; d++) eliteMean[d]+=w[d]; }
                  for(let d=0; d<dim; d++) eliteMean[d] /= eliteCount;
                  const mu = 0.3; const bestW = train.candWeights[idx[0]];
                  const newMean = new Float64Array(dim);
                  for(let d=0; d<dim; d++) newMean[d] = (1-mu)*eliteMean[d] + mu*bestW[d];
                  const newStd = new Float64Array(dim);
                  for(const ei of elites){ const w = train.candWeights[ei]; for(let d=0; d<dim; d++){ const diff=w[d]-eliteMean[d]; newStd[d]+=diff*diff; } }
                  for(let d=0; d<dim; d++) newStd[d] = Math.max(train.minStd, Math.min(train.maxStd, Math.sqrt(newStd[d]/eliteCount)));
                  const bestThisGen = train.candScores[idx[0]];
                  if(bestThisGen > (train.bestEverFitness ?? -Infinity)){
                    train.bestEverFitness = bestThisGen; train.bestEverWeights = new Float64Array(train.candWeights[idx[0]]);
                  }
                  if(bestThisGen > train.bestFitness){ for(let d=0; d<newStd.length; d++) newStd[d] = Math.max(train.minStd, newStd[d] * 0.85); train.bestFitness = bestThisGen; train.genNoImprove = 0; }
                  else { train.genNoImprove += 1; if(train.genNoImprove >= train.plateauGens){ for(let d=0; d<newStd.length; d++) newStd[d] = Math.min(train.maxStd, newStd[d] * train.stdBoost); train.genNoImprove = 0; log('Plateau detected: boosted exploration std'); } }
                  train.mean = newMean; train.std = newStd; train.gen += 1; log(`Gen ${train.gen} complete. Best fitness: ${bestThisGen}`);
                  samplePopulation();
                  // Elitist carryover
                  if(train.candWeights.length>0) train.candWeights[0] = new Float64Array(bestW);
                  if(train.bestEverWeights && train.candWeights.length>1) train.candWeights[1] = new Float64Array(train.bestEverWeights);
                  Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                  state.gravity = gravityForLevel(0);
                  updateLevel(); updateScore();
                  spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                  updateScorePlot();
                  log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                  updateTrainStatus();
                  return;
                }
              }
              if(train.candIndex + 1 < train.popSize){
                train.candIndex += 1;
                Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                state.gravity = gravityForLevel(0);
                updateLevel(); updateScore();
                spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                updateTrainStatus();
              } else {
              // Start re-evaluation of best-of-gen before updating population
              const idx = [...train.candScores.keys()].sort((a,b)=>train.candScores[b]-train.candScores[a]);
              const bestIdx = idx[0];
              train.phase = 'reeval'; train.reevalTarget = bestIdx; train.reevalDone = 0; train.reevalAccum = 0; train.currentWeightsOverride = new Float64Array(train.candWeights[bestIdx]);
              Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
              state.gravity = gravityForLevel(0);
              updateLevel(); updateScore();
              spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
              updateTrainStatus();
              return;
              }
            } else {
              Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
              state.gravity = gravityForLevel(0);
              updateLevel(); updateScore();
              spawn();
            }
          }
          window.__onGameOver = onGameOver;

          function uniqueRotIdx(shape){ const states = SHAPES[shape]; const seen = new Set(); const out=[]; for(let i=0;i<states.length;i++){ const key = JSON.stringify(states[i].slice().sort()); if(!seen.has(key)){ seen.add(key); out.push(i); } } return out; }
          function stateWidth(state){ let maxC=0; for(const [,c] of state) if(c>maxC) maxC=c; return maxC+1; }
          function copyGrid(g){ return g.map(r=>r.slice()); }
          function dropRowSim(grid, piece){ if(!canMove(grid,piece,0,0)) return null; while(canMove(grid,piece,0,1)) piece.move(0,1); return piece.row; }

          // Approximate delay between horizontal moves in ms, used to estimate
          // how many sideways shifts are possible before a gravity drop.
          const HORIZONTAL_MOVE_INTERVAL_MS = 100;

          // Return true if a piece can reach (rot, col) from spawn under gravity.
          function pathClear(grid, shape, rot, col, level){
            // Start from spawn
            const spawnCol = Math.floor(WIDTH/2) - 2;
            const piece = new Piece(shape);
            piece.row = 0; piece.col = spawnCol; piece.rot = 0;

            // Try rotate-at-spawn step-by-step
            const statesLen = SHAPES[shape].length;
            const rotSteps = (rot - piece.rot + statesLen) % statesLen;
            for(let i=0; i<rotSteps; i++){
              piece.rotate();
              if(!canMove(grid, piece, 0, 0)) return false;
            }

            // Compute the final resting row from the target column/rotation
            const target = new Piece(shape);
            target.row = 0; target.col = col; target.rot = rot;
            const finalRow = dropRowSim(grid, target);
            if(finalRow === null) return false;

            // If already in the right column, ensure vertical path is clear
            if(col === piece.col){
              while(piece.row < finalRow){
                if(!canMove(grid, piece, 0, 1)) return false;
                piece.move(0, 1);
              }
              return true;
            }

            // Level 29: treat as instant drop (no horizontal movement)
            if(level >= 29) return false;

            // Estimate how many horizontal moves fit per gravity tick
            const gravity = gravityForLevel(level);
            const movesPerRow = Math.max(1, Math.floor(gravity / HORIZONTAL_MOVE_INTERVAL_MS));

            // Translate toward target column under gravity
            while(piece.col !== col){
              // Gravity first
              if(!canMove(grid, piece, 0, 1)) return false;
              piece.move(0, 1);

              const dir = (col > piece.col) ? 1 : -1;
              const steps = Math.min(movesPerRow, Math.abs(col - piece.col));
              for(let s=0; s<steps; s++){
                if(!canMove(grid, piece, dir, 0)) return false;
                piece.move(dir, 0);
              }
            }

            // Finish dropping to the final row
            while(piece.row < finalRow){
              if(!canMove(grid, piece, 0, 1)) return false;
              piece.move(0, 1);
            }
            return true;
          }

          function enumeratePlacements(grid, shape){
            const actions=[]; const rotIdx=uniqueRotIdx(shape);
            for(const rot of rotIdx){
              const width=stateWidth(SHAPES[shape][rot]);
              for(let col=0; col<=WIDTH-width; col++){
                const p=new Piece(shape); p.rot=rot; p.row=0; p.col=col;
                const fr=dropRowSim(grid,p);
                if(fr!==null && pathClear(grid, shape, rot, col, state.level)) actions.push({rot,col});
              }
            }
            return actions;
          }
          function lockSim(grid, piece){ for(const [r,c] of piece.blocks()) grid[r][c]=1; }
          function clearRowsSim(grid){ let remaining = grid.filter(row => row.some(v => v===0)); const cleared = HEIGHT - remaining.length; while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0)); for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r]; return cleared; }
          function columnHeights(grid){ const h=Array(WIDTH).fill(0); for(let c=0;c<WIDTH;c++){ let r=0; while(r<HEIGHT && grid[r][c]===0) r++; h[c]=HEIGHT-r; } return h; }
          function countHoles(grid){ let holes=0; for(let c=0;c<WIDTH;c++){ let seen=false; for(let r=0;r<HEIGHT;r++){ const v=grid[r][c]; if(v){ seen=true; } else if(seen){ holes++; } } } return holes; }
          function bumpiness(heights){ let b=0; for(let c=0;c<WIDTH-1;c++) b+=Math.abs(heights[c]-heights[c+1]); return b; }
          function simulateAfterPlacement(grid, shape, rot, col){ const g=copyGrid(grid); const p=new Piece(shape); p.rot=rot; p.row=0; p.col=col; const fr=dropRowSim(g,p); if(fr===null) return null; p.row=fr; lockSim(g,p); const lines=clearRowsSim(g); return {grid:g, lines}; }
          function featuresFromGrid(g, lines){ const h=columnHeights(g); const Holes=countHoles(g); const Bump=bumpiness(h); const maxH=Math.max(...h); const is1=lines===1?1:0, is2=lines===2?1:0, is3=lines===3?1:0, is4=lines===4?1:0; const lines2=lines*lines; return [lines, lines2, is1, is2, is3, is4, Holes, Bump, maxH]; }
          function featuresForPlacement(grid, shape, rot, col){ const sim=simulateAfterPlacement(grid, shape, rot, col); if(!sim) return null; const feats = featuresFromGrid(sim.grid, sim.lines); return { feats, lines: sim.lines, grid: sim.grid } }
          function dot(weights, feats){ let s=0; for(let d=0; d<FEAT_DIM; d++) s+=weights[d]*feats[d]; return s; }
          function scorePlacement(weights, grid, shape, act){ const ff=featuresForPlacement(grid, shape, act.rot, act.col); if(!ff) return -Infinity; return dot(weights, ff.feats); }
          function choosePlacement(weights, grid, shape){ const acts=enumeratePlacements(grid, shape); if(acts.length===0) return null; let best=acts[0], bestS=-Infinity; for(const a of acts){ const s=scorePlacement(weights, grid, shape, a); if(s>bestS){ bestS=s; best=a; } } return best; }
          function mlpScore(weights, feats){
            // weights layout: [W1 (FEAT_DIM*H1), b1 (H1), W2 (H1), b2 (1)]
            const H = MLP_H1;
            const W1 = weights.subarray(0, FEAT_DIM*H);
            const b1 = weights.subarray(FEAT_DIM*H, FEAT_DIM*H + H);
            const W2 = weights.subarray(FEAT_DIM*H + H, FEAT_DIM*H + H + H);
            const b2 = weights[FEAT_DIM*H + H + H];
            // Manual forward (faster than tf.js per-placement)
            const h = new Float64Array(H);
            for(let j=0;j<H;j++){
              let sum = b1[j];
              for(let i=0;i<FEAT_DIM;i++) sum += feats[i] * W1[i*H + j];
              h[j] = sum > 0 ? sum : 0;
            }
            let y = b2;
            for(let j=0;j<H;j++) y += h[j] * W2[j];
            return y;
          }
          function scoreFeats(weights, feats){ return (train.modelType === 'mlp') ? mlpScore(weights, feats) : dot(weights, feats); }
          function choosePlacement2(weights, grid, curShape, nextShape){ const acts=enumeratePlacements(grid, curShape); if(acts.length===0) return null; let best=acts[0], bestS=-Infinity; const sims=[]; // precompute first-ply sims and scores
            for(const a of acts){ const sim=simulateAfterPlacement(grid, curShape, a.rot, a.col); if(!sim) continue; const baseFeats = featuresFromGrid(sim.grid, sim.lines); const s1 = scoreFeats(weights, baseFeats); sims.push({a, sim, s1}); }
            if(sims.length===0) return null;
            // Beam: consider lookahead only for top-K first-ply moves
            sims.sort((u,v)=>v.s1 - u.s1);
            const K = Math.min(LOOKAHEAD_BEAM, sims.length);
            for(let i=0;i<sims.length;i++){
              let s = sims[i].s1;
              if(nextShape && i < K){ const acts2=enumeratePlacements(sims[i].sim.grid, nextShape); if(acts2.length>0){ let best2=-Infinity; for(const a2 of acts2){ const ff2=featuresForPlacement(sims[i].sim.grid, nextShape, a2.rot, a2.col); if(!ff2) continue; const s2=scoreFeats(weights, ff2.feats); if(s2>best2) best2=s2; } if(isFinite(best2)) s += LOOKAHEAD_LAMBDA*best2; }
              }
              if(s>bestS){ bestS=s; best=sims[i].a; }
            }
            return best; }

          function planForCurrentPiece(){ if(!state.active) return null; const w = train.currentWeightsOverride || train.candWeights[train.candIndex] || train.mean; const a=choosePlacement2(w, state.grid, state.active.shape, state.next); if(!a){ return null; } const len=SHAPES[state.active.shape].length; const cur=state.active.rot % len; const needRot=(a.rot - cur + len) % len; return { targetRot:a.rot, targetCol:a.col, rotLeft:needRot, stage:'rotate' }; }

          // Scatter plot of raw score per game (all candidates)
          function updateScorePlot(){
            const canvas = document.getElementById('score-plot');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            ctx.clearRect(0,0,W,H);
            const padL=22, padB=16, padR=6, padT=6;
            // axes
            ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padL, H-padB); ctx.lineTo(W-padR, H-padB);
            ctx.moveTo(padL, H-padB); ctx.lineTo(padL, padT);
            ctx.stroke();
            const scores = (window.__train && window.__train.gameScores) ? window.__train.gameScores : [];
            const types  = (window.__train && window.__train.gameModelTypes) ? window.__train.gameModelTypes : [];
            if(!scores || scores.length===0) return;
            const maxY = Math.max(1000, Math.max(...scores));
            const xw = (W - padL - padR), yh = (H - padT - padB);
            ctx.fillStyle = '#666'; ctx.font = '10px sans-serif';
            ctx.fillText('0', 4, H-padB+10);
            ctx.fillText(String(maxY), 2, padT+8);
            const COLORS = { linear: '#1f77b4', mlp: '#ff7f0e' };
            for(let i=0;i<scores.length;i++){
              const x = padL + (scores.length<=1?0:(i/(scores.length-1)))*xw;
              const y = H - padB - (scores[i]/maxY)*yh;
              const t = types[i] || 'linear';
              ctx.fillStyle = COLORS[t] || '#1f77b4';
              ctx.fillRect(Math.round(x)-1, Math.round(y)-1, 3, 3);
            }
          }

          function aiStep(dt){
            train.ai.acc += dt;
            if(!state.active){ return; }
            // Safety: if spawn is blocked or piece overlaps, end episode
            if(!canMove(state.grid, state.active, 0, 0)) { log('AI: spawn blocked -> game over'); onGameOver(); return; }

            // Execute as many micro-steps as fit into accumulated time
            let __aiSteps = 0;
            while (train.ai.acc >= AI_STEP_MS && __aiSteps < MAX_AI_STEPS_PER_FRAME) {
              train.ai.acc -= AI_STEP_MS;
              __aiSteps += 1;

              // Watchdog: if the active piece hasn't changed state for a while, force a drop
              const sig = `${state.active.shape}:${state.active.rot}:${state.active.row}:${state.active.col}:${state.score}`;
              if(train.ai.lastSig === sig){ train.ai.staleMs = (train.ai.staleMs || 0) + AI_STEP_MS; } else { train.ai.staleMs = 0; train.ai.lastSig = sig; }
              if(train.ai.staleMs > 1000){
                log('AI: watchdog forced drop');
                while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                lock(state.grid, state.active);
                state.pieces++;
                if(state.pieces % 20 === 0){ state.level++; state.gravity = gravityForLevel(state.level); updateLevel(); }
                const cleared = clearRows(state.grid);
                if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                if(state.grid[0].some(v => v !== 0)) { onGameOver(); train.ai.plan = null; train.ai.staleMs = 0; return; }
                spawn(); train.ai.plan = null; train.ai.staleMs = 0; if(!canMove(state.grid, state.active, 0, 0)) onGameOver(); return;
              }

              if(!train.ai.plan){ train.ai.plan = planForCurrentPiece(); if(!train.ai.plan){ // force drop to end episode
                  while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                  lock(state.grid, state.active);
                  state.pieces++;
                  if(state.pieces % 20 === 0){
                    state.level++;
                    state.gravity = gravityForLevel(state.level);
                    updateLevel();
                  }
                const cleared = clearRows(state.grid);
                if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                if(state.grid[0].some(v => v !== 0)) { log('AI: top-out after forced drop'); onGameOver(); return; }
                spawn(); if(!canMove(state.grid, state.active, 0, 0)) onGameOver(); return; }
              }
              const plan = train.ai.plan; if(!plan) continue;
              if(plan.stage==='rotate'){
                if(plan.rotLeft>0){
                  state.active.rotate();
                  if(!canMove(state.grid, state.active, 0, 0)){
                    // Rotation blocked: abandon this plan to avoid stalling
                    state.active.rotate(-1);
                    train.ai.plan = null; log('AI: rotation blocked, abandoning plan');
                  } else {
                    plan.rotLeft -= 1;
                  }
                  continue;
                }
                plan.stage='move'; continue;
              }
              if(plan.stage==='move'){
                if(state.active.col < plan.targetCol){ if(canMove(state.grid, state.active, 1, 0)) state.active.move(1,0); else plan.stage='drop'; continue; }
                if(state.active.col > plan.targetCol){ if(canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0); else plan.stage='drop'; continue; }
                plan.stage='drop'; continue;
              }
              if(plan.stage==='drop'){
                if(canMove(state.grid, state.active, 0, 1)){ state.active.move(0,1); continue; }
                  lock(state.grid, state.active);
                  state.pieces++;
                  if(state.pieces % 20 === 0){
                    state.level++;
                    state.gravity = gravityForLevel(state.level);
                    updateLevel();
                  }
                  const cleared = clearRows(state.grid);
                  if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                if(state.grid[0].some(v => v !== 0)) { log('AI: top-out after drop'); onGameOver(); train.ai.plan = null; return; }
                spawn(); train.ai.plan = null; if(!canMove(state.grid, state.active, 0, 0)) onGameOver(); return;
              }
            }
          }
          window.__aiStep = aiStep;

          // Hook up training buttons
          const trainBtn = document.getElementById('train');
          if(trainBtn){ trainBtn.addEventListener('click', () => { if(train.enabled) stopTraining(); else startTraining(); }); }
          const trainResetBtn = document.getElementById('train-reset');
          if(trainResetBtn){ trainResetBtn.addEventListener('click', resetTraining); }
          const modelSel = document.getElementById('model-select');
          function setModelType(mt){
            if(mt !== 'linear' && mt !== 'mlp') return;
            const wasRunning = train.enabled;
            if(wasRunning) stopTraining();
            train.modelType = mt;
            // Re-init mean/std to the appropriate initial values for this model
            train.mean = initialMean(mt);
            train.std  = initialStd(mt);
            updateTrainStatus();
            // Reset training state
            resetTraining();
            if(wasRunning) startTraining();
          }
          if(modelSel){ modelSel.addEventListener('change', (e) => setModelType(modelSel.value)); }
          updateTrainStatus();
        })();
      })();
    </script>
  </body>
</html>

