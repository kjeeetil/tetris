<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://pyscript.net https://cdn.jsdelivr.net data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://pyscript.net https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://pyscript.net; connect-src 'self' https://pyscript.net https://cdn.jsdelivr.net data: blob:; img-src 'self' data:;" />
    <title>Tetris</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
    
    <style>
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        padding: 0;
      }
      #canvas {
        margin: 0;
        border: 2px solid #000;
        display: block;
      }
      .game {
        margin: 24px auto 0 auto;
        display: flex;
        gap: 16px;
        justify-content: center;
        align-items: flex-start;
        max-width: 560px;
      }
      .sidebar {
        width: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }
      .panel {
        width: 160px;
        padding: 8px;
        border: 1px solid #ccc;
        background: #fdfdfd;
      }
      .panel-title {
        font-size: 12px;
        color: #555;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        margin-bottom: 6px;
      }
      #preview {
        display: block;
        width: 160px;
        height: 160px;
        border: 1px solid #eee;
        background: #fff;
      }
      #score {
        font-family: Georgia, "Times New Roman", "Palatino Linotype", "Book Antiqua", serif;
        font-size: 22px;
        line-height: 1.2;
        color: #222;
      }
      .controls {
        margin: 12px auto;
        display: flex;
        gap: 12px;
        justify-content: center;
        align-items: center;
      }
      .icon-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: 1px solid #bbb;
        background: #fff;
        font-size: 20px;
        line-height: 44px;
        cursor: pointer;
        box-shadow: 0 1px 2px rgba(0,0,0,0.08);
      }
      .icon-btn:active { transform: translateY(1px); }
      #network-viz {
        width: 320px;
        height: 220px;
        margin: 12px auto 0 auto;
      }
      #network-viz svg {
        width: 100%;
        height: 100%;
        border: 1px solid #eee;
        background: #fff;
      }
      #network-viz text {
        font-size: 10px;
        fill: #444;
        pointer-events: none;
      }
      #diagnostics {
        width: 320px;
        height: 140px;
        margin: 12px auto 24px auto;
        padding: 8px;
        border: 1px solid #ccc;
        background: #fafafa;
        text-align: left;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
      }
      @media (max-width: 600px) {
        .game {
          flex-direction: column;
          max-width: 100%;
          align-items: center;
        }
        #canvas {
          width: 90vw;
          height: auto;
          max-width: 300px;
          margin: 0 auto;
        }
        .sidebar {
          width: 100%;
          flex-direction: row;
          justify-content: center;
        }
        .panel {
          width: auto;
        }
        #preview {
          width: 80px;
          height: 80px;
        }
        .controls {
          flex-wrap: wrap;
        }
        .icon-btn {
          width: 56px;
          height: 56px;
          font-size: 24px;
          line-height: 56px;
        }
        #network-viz {
          width: 90vw;
          max-width: 360px;
          height: 220px;
        }
      }
      /* No external runtimes required; pure JS renderer */
    </style>
  </head>
  <body>
    <h1>Tetris</h1>
    <noscript>
      <div style="color:#b00020;margin:12px;">JavaScript is disabled. Enable it to play.</div>
    </noscript>
    <div class="game">
      <canvas id="canvas" width="300" height="600" tabindex="0"></canvas>
      <div class="sidebar">
        <div class="panel">
          <div class="panel-title">Next</div>
          <canvas id="preview" width="160" height="160"></canvas>
        </div>
        <div class="panel">
          <div class="panel-title">Training Progress</div>
          <canvas id="score-plot" width="160" height="120"></canvas>
        </div>
        <div id="level">Level: 0</div>
        <div id="score">Score: 0</div>
      </div>
    </div>
    <div class="controls">
      <button id="toggle" class="icon-btn" title="Play/Pause" aria-label="Play/Pause">▶</button>
      <button id="reset" class="icon-btn" title="Reset" aria-label="Reset">⟲</button>
    </div>
    <div class="controls">
      <button id="train" class="icon-btn" title="Start/Stop Training" aria-label="Start/Stop Training">AI</button>
      <button id="train-reset" class="icon-btn" title="Reset Training" aria-label="Reset Training">♻️</button>
    </div>
    <div class="controls">
      <label for="model-select">Model:</label>
      <select id="model-select">
        <option value="linear" selected>Linear (ES)</option>
        <option value="mlp">MLP (tf.js)</option>
      </select>
      <button id="render-toggle" class="icon-btn" title="Show/Hide Board During Training" aria-label="Show/Hide Board">Hide</button>
    </div>
    <div class="controls">
      <label for="speed" id="speed-label">Speed: <span id="speed-display">1x</span></label>
      <input id="speed" type="range" min="1" max="50" value="1" />
    </div>
    <div id="train-status"></div>
    <div id="weights-display"></div>
    <div id="network-viz" aria-label="Network weight visualization"></div>
    <div id="diagnostics" aria-live="polite"></div>
    <script>
      // --- Minimal Tetris in plain JavaScript (no PyScript) ---
      (function () {
        const canvas = document.getElementById('canvas');
        const preview = document.getElementById('preview');
        const diag = document.getElementById('diagnostics');
        const MAX_LOG_LINES = 200;
        const trainStatus = document.getElementById('train-status');
        const weightsEl = document.getElementById('weights-display');
        const networkVizEl = document.getElementById('network-viz');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const ctx = canvas.getContext('2d');
        const pctx = preview.getContext('2d');
        const CELL = 30, WIDTH = 10, HEIGHT = 20;
        const PREV_CELL = 28; // slightly smaller cell for preview
        // Performance tuning caps
        const MAX_AI_STEPS_PER_FRAME = 64;
        const speedSlider = document.getElementById('speed');
        const speedDisplay = document.getElementById('speed-display');
        let speedMult = 1;
        if (speedSlider) {
          speedSlider.addEventListener('input', () => {
            speedMult = Number(speedSlider.value);
            if (speedDisplay) speedDisplay.textContent = `${speedMult}x`;
            if (state.running) {
              clearTimeout(state.raf);
              scheduleNext();
            }
          });
        }

        const log = (t) => {
          if (!diag) return;
          const d = document.createElement('div');
          const now = new Date().toLocaleTimeString();
          d.textContent = `[${now}] ${t}`;
          diag.prepend(d);
          // Trim log to avoid unbounded DOM growth
          while (diag.childElementCount > MAX_LOG_LINES) {
            diag.removeChild(diag.lastChild);
          }
        };

        const Shapes = {
          I: [[0,0],[0,1],[0,2],[0,3]],
          O: [[0,0],[0,1],[1,0],[1,1]],
          T: [[0,0],[0,1],[0,2],[1,1]],
          S: [[0,1],[0,2],[1,0],[1,1]],
          Z: [[0,0],[0,1],[1,1],[1,2]],
          J: [[0,0],[1,0],[1,1],[1,2]],
          L: [[0,2],[1,0],[1,1],[1,2]],
        };

        const rotate = (state) => {
          const rot = state.map(([r,c]) => [c, -r]);
          let minR = Math.min(...rot.map(([r]) => r));
          let minC = Math.min(...rot.map(([,c]) => c));
          return rot.map(([r,c]) => [r - minR, c - minC]);
        };

        const genRotations = (s) => {
          const r = [s];
          for (let i=0;i<3;i++) r.push(s = rotate(s));
          return r;
        };

        const SHAPES = {};
        for (const k of Object.keys(Shapes)) SHAPES[k] = genRotations(Shapes[k]);

        const emptyGrid = () => Array.from({length: HEIGHT}, () => Array(WIDTH).fill(0));

        // Level speed table roughly matching classic NES Tetris
        const LEVEL_FRAMES = {
          0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6,
          10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2,
          20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1
        };
        const gravityForLevel = (lvl) => {
          const frames = LEVEL_FRAMES[Math.min(lvl,29)];
          return (frames/60)*1000; // convert frames to ms
        };

        class Piece {
          constructor(shape){ this.shape = shape; this.rot = 0; this.row = 0; this.col = Math.floor(WIDTH/2) - 2; }
          blocks(){ const s = SHAPES[this.shape][this.rot]; return s.map(([dr,dc]) => [this.row+dr, this.col+dc]); }
          move(dx,dy){ this.col += dx; this.row += dy; }
          rotate(dir=1){ const states = SHAPES[this.shape]; this.rot = (this.rot + (dir>=0?1:states.length-1)) % states.length; }
        }

        const canMove = (grid, piece, dx, dy) => {
          for(const [r,c] of piece.blocks()){
            const nr = r + dy, nc = c + dx;
            if (nr < 0 || nr >= HEIGHT || nc < 0 || nc >= WIDTH) return false;
            if (grid[nr][nc] !== 0) return false;
          }
          return true;
        };

        const lock = (grid, piece) => { for(const [r,c] of piece.blocks()) grid[r][c] = piece.shape; };

        const clearRows = (grid) => {
          let remaining = grid.filter(row => row.some(v => v===0));
          const cleared = HEIGHT - remaining.length;
          while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0));
          for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r];
          return cleared;
        };

        const SHAPE_COLORS = {
          I: '#00ffff', O: '#ffff00', T: '#800080', S: '#00ff00', Z: '#ff0000', J: '#0000ff', L: '#ffa500'
        };

        function draw(grid, active){
          try {
            if(window.__train && window.__train.enabled && window.__train.visualizeBoard === false){
              return; // skip board rendering in training fast mode
            }
          } catch(_) {}
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,WIDTH*CELL,HEIGHT*CELL);
          // locked
          for(let r=0;r<HEIGHT;r++){
            for(let c=0;c<WIDTH;c++){
              const val = grid[r][c];
              if(val){ ctx.fillStyle = SHAPE_COLORS[val] || '#444'; ctx.fillRect(c*CELL,r*CELL,CELL,CELL); }
              ctx.strokeStyle = '#333'; ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);
            }
          }
          // active
          if(active){ ctx.fillStyle = SHAPE_COLORS[active.shape] || '#6cf'; for(const [r,c] of active.blocks()){ ctx.fillRect(c*CELL,r*CELL,CELL,CELL); ctx.strokeStyle = '#333'; ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);} }
        }

        function drawNext(shape){
          try {
            if(window.__train && window.__train.enabled && window.__train.visualizeBoard === false){
              return; // skip preview rendering in training fast mode
            }
          } catch(_) {}
          const W = preview.width, H = preview.height;
          pctx.fillStyle = '#ffffff'; pctx.fillRect(0,0,W,H);
          pctx.strokeStyle = '#f0f0f0'; pctx.strokeRect(0,0,W,H);
          if(!shape) return;
          const state = SHAPES[shape][0];
          let minR=Infinity, minC=Infinity, maxR=-Infinity, maxC=-Infinity;
          for(const [r,c] of state){ minR=Math.min(minR,r); minC=Math.min(minC,c); maxR=Math.max(maxR,r); maxC=Math.max(maxC,c); }
          const w = (maxC-minC+1)*PREV_CELL; const h = (maxR-minR+1)*PREV_CELL;
          const offX = Math.floor((W - w)/2); const offY = Math.floor((H - h)/2);
          pctx.fillStyle = SHAPE_COLORS[shape] || '#6cf';
          for(const [r,c] of state){
            const x = offX + (c-minC)*PREV_CELL;
            const y = offY + (r-minR)*PREV_CELL;
            pctx.fillRect(x, y, PREV_CELL, PREV_CELL);
            pctx.strokeStyle = '#dddddd';
            pctx.strokeRect(x, y, PREV_CELL, PREV_CELL);
          }
        }

        // Record cleared line counts for training fitness (safe no-op if training is off)
        function recordClear(lines){
          try {
            const tr = window.__train;
            if(tr && tr.enabled){
              if(!tr.clearCounts) tr.clearCounts = {1:0,2:0,3:0,4:0};
              if(lines>=1 && lines<=4){ tr.clearCounts[lines] = (tr.clearCounts[lines]||0) + 1; }
            }
          } catch(_) { /* ignore */ }
        }

        function isHeadlessTrainingActive(){
          try {
            const tr = window.__train;
            return !!(tr && tr.enabled && tr.visualizeBoard === false);
          } catch (_) {
            return false;
          }
        }

        function updateScore(force){
          if(!force && isHeadlessTrainingActive()) return;
          if(scoreEl) scoreEl.textContent = `Score: ${state.score}`;
        }
        function updateLevel(force){
          if(!force && isHeadlessTrainingActive()) return;
          if(levelEl) levelEl.textContent = `Level: ${state.level}`;
        }

        const state = { grid: emptyGrid(), active: null, next: null, score: 0, level:0, pieces:0, running:false, paused:false, last:0, acc:0, gravity:gravityForLevel(0), raf:null, wdAcc:0, lastSig:'', renderEvery:1, renderCounter:0 };

        const shapes = Object.keys(SHAPES);
        function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=arr[i]; arr[i]=arr[j]; arr[j]=t; } return arr; }
        let bag = [];
        const drawFromBag = () => { if(bag.length===0){ bag = shuffle(shapes.slice()); } return bag.pop(); };

        const spawn = () => { const s = state.next || drawFromBag(); state.active = new Piece(s); state.next = drawFromBag(); drawNext(state.next); updateScore(); updateLevel(); };

        // Robust game-over trigger used by outer loop/inputs.
        // Delegates to window.__onGameOver if available; otherwise, performs a minimal safe reset.
        function triggerGameOver(){
          try {
            if (typeof window.__onGameOver === 'function') {
              return window.__onGameOver();
            }
          } catch (_) { /* fall through to fallback */ }
          // Fallback: minimal reset so the loop can continue gracefully
          try {
            log('Game over (fallback). Resetting.');
          } catch(_) {}
          Object.assign(state, { grid: emptyGrid(), active: null, next: null, score: 0, level: 0, pieces: 0 });
          state.gravity = gravityForLevel(0);
          updateLevel();
          updateScore();
          spawn();
        }

        const scheduleNext = () => {
          // Run the main loop at a steady ~60 FPS; speed multiplier is applied
          // inside the loop by scaling the effective delta time.
          let delay = 1000 / 60;
          try {
            const tr = window.__train;
            if (tr && tr.enabled && tr.visualizeBoard === false) {
              delay = 0;
            }
          } catch (_) {}
          state.raf = setTimeout(() => tick(performance.now()), delay);
        };

        function updateRenderDecimation(){
          // Default: draw every frame; this can be expanded later to skip frames
          state.renderEvery = 1;
          state.renderCounter = 0;
        }

        function tick(ts){
          try {
            if(!state.running){ return; }
            if(!state.last) state.last = ts;
            const dt = ts - state.last; state.last = ts;
            let effDt = dt * speedMult;
            try {
              const tr = window.__train;
              if(tr && tr.enabled && tr.visualizeBoard === false){
                effDt = dt;
              }
            } catch(_) {}
            // Watchdog: detect lack of progress for > 2s wall time and reset
            const curSig = state.active ? `${state.active.shape}:${state.active.rot}:${state.active.row}:${state.active.col}:${state.score}:${state.pieces}` : `none:${state.score}:${state.pieces}`;
            if(curSig === state.lastSig){ state.wdAcc += dt; } else { state.wdAcc = 0; state.lastSig = curSig; }
            if(state.wdAcc > 2000 && !state.paused){ log('Watchdog: no progress for 2s -> game over'); triggerGameOver(); state.wdAcc = 0; }
            // Fallback: ensure there is always an active piece when running
            if(!state.paused && !state.active){
              spawn();
              if(!canMove(state.grid, state.active, 0, 0)) { log('Tick: spawned into block -> game over'); triggerGameOver(); return; }
            }
            if(!state.paused && state.active){
              // Global guard: if the active piece cannot exist at its current
              // position (e.g., spawn collision), trigger game over/reset.
              if(!canMove(state.grid, state.active, 0, 0)){
                log('Tick: spawn blocked -> game over');
                triggerGameOver();
                return;
              }
              if(window.__train && window.__train.enabled){
                window.__aiStep(effDt);
              } else {
                state.acc += effDt;
                while(state.acc >= state.gravity){
                  state.acc -= state.gravity;
                  if(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                  else {
                    lock(state.grid, state.active);
                    state.pieces++;
                    if(state.pieces % 20 === 0){
                      state.level++;
                      state.gravity = gravityForLevel(state.level);
                      updateLevel();
                    }
                    const cleared = clearRows(state.grid);
                    if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                    // Top-out guard after lock/clear in manual mode
                    if(state.grid[0].some(v => v !== 0)) { triggerGameOver(); }
                else {
                  spawn();
                      if(!canMove(state.grid, state.active, 0, 0)){ triggerGameOver(); }
                  }
                  }
                }
              }
            }
          } catch (e) {
            try { log(`Tick error: ${e && e.message ? e.message : e}`); } catch(_) {}
            try { triggerGameOver(); } catch(_) {}
          } finally {
            try {
              if(state.renderEvery <= 1){
                draw(state.grid, state.active);
              } else {
                if(state.renderCounter <= 0){
                  draw(state.grid, state.active);
                  state.renderCounter = state.renderEvery - 1;
                } else {
                  state.renderCounter -= 1;
                }
              }
            } catch(_) {}
            scheduleNext();
          }
        }

        function start(){ if(state.running){ log('Already running'); return; } canvas.focus(); state.grid = emptyGrid(); state.score=0; state.level=0; state.pieces=0; state.gravity=gravityForLevel(0); updateScore(); updateLevel(); state.last=0; state.acc=0; state.wdAcc=0; state.lastSig=''; state.running=true; state.paused=false; updateRenderDecimation(); spawn(); draw(state.grid, state.active); scheduleNext(); log('Game started'); renderControls(); }
        function pause(){ if(!state.running){ log('Pause ignored: not running'); return; } state.paused=true; log('Paused'); }
        function resume(){ if(!state.running){ log('Resume ignored: not running'); return; } state.paused=false; log('Resumed'); }
        function stop(){ if(!state.running){ log('Stop ignored: not running'); return; } state.running=false; state.paused=false; if(state.raf) clearTimeout(state.raf); state.raf=null; log('Game stopped'); renderControls(); }

        // Toggle + reset controls
        const toggleBtn = document.getElementById('toggle');
        const resetBtn = document.getElementById('reset');
        function renderControls(){ toggleBtn.textContent = (!state.running || state.paused) ? '▶' : '⏸'; }
        function togglePlayPause(){ if(!state.running){ start(); } else if(state.paused){ resume(); } else { pause(); } renderControls(); }
        function resetGame(){ if(state.running){ stop(); } start(); }

        // keyboard
        const BLOCK_KEYS = new Set(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','PageUp','PageDown','Home','End']);
        document.addEventListener('keydown', (e) => {
          if(!state.running) return;
          if (BLOCK_KEYS.has(e.key)) e.preventDefault();
          if(state.paused || !state.active || (window.__train && window.__train.enabled)) return;
          if(e.key==='ArrowLeft' && canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0);
          else if(e.key==='ArrowRight' && canMove(state.grid, state.active, 1, 0)) state.active.move(1,0);
          else if(e.key==='ArrowUp'){ state.active.rotate(); if(!canMove(state.grid, state.active, 0, 0)) state.active.rotate(-1); }
          else if(e.key==='ArrowDown' && canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
          else if(e.key===' '){
            while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
            lock(state.grid, state.active);
            state.pieces++;
            if(state.pieces % 20 === 0){
              state.level++;
              state.gravity = gravityForLevel(state.level);
              updateLevel();
            }
            const cleared = clearRows(state.grid);
            if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared);} 
            if(state.grid[0].some(v => v !== 0)) { triggerGameOver(); }
            else { spawn(); if(!canMove(state.grid, state.active, 0, 0)) triggerGameOver(); }
          }
          draw(state.grid, state.active);
        });

        // buttons
        toggleBtn.addEventListener('click', togglePlayPause);
        resetBtn.addEventListener('click', resetGame);

        log('Ready. Click Start to run.');
        renderControls();

        // ================= AI Training (placement-level with animation) =================
        // Expose minimal API on window to avoid invasive edits above
        (function(){
          // Features (scaled):
          const FEATURE_NAMES = [
            'Lines',
            'Lines²',
            'Single Clear',
            'Double Clear',
            'Triple Clear',
            'Tetris',
            'Holes',
            'Bumpiness',
            'Max Height',
            'Well Sum',
            'Edge Wells',
            'Contact',
            'Row Transitions',
            'Col Transitions',
            'Aggregate Height',
          ];
          const FEAT_DIM = FEATURE_NAMES.length;
          const AI_STEP_MS = 28; // ms between AI animation steps
          const LOOKAHEAD_LAMBDA = 0.7; // weight for next-piece lookahead score
          const LOOKAHEAD_BEAM = 6; // evaluate next-piece lookahead only for top-K first moves
          const SCORE_WEIGHT = 3.0; // emphasize final score in fitness

          // MLP architecture (when selected)
          const MLP_H1 = 8; // hidden units (small for speed)
          const MLP_PARAM_DIM = FEAT_DIM*MLP_H1 + MLP_H1 + MLP_H1*1 + 1; // W1 + b1 + W2 + b2

          // Numeric dtype for weight arrays
          const HAS_F16 = (typeof Float16Array !== 'undefined');
          const DEFAULT_DTYPE = HAS_F16 ? 'f16' : 'f32';
          function allocWeights(n, dtype){ return (dtype==='f16' && HAS_F16) ? new Float16Array(n) : new Float32Array(n); }
          // Safe default allocator before `train` exists (avoid TDZ issues)
          let newWeightArray = (n) => allocWeights(n, DEFAULT_DTYPE);

          // Initial weights for Linear model (intentionally poor to make the very first attempt worse)
          // Order: [lines, lines2, is1, is2, is3, is4, holes, bumpiness, maxH, wellSum, edgeWell, contact, rowTrans, colTrans, aggH]
          const INITIAL_MEAN_LINEAR_BASE = [0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.4, 0.2, 0.1, 0.1, 0.0, 0.0, 0.1, 0.1, 0.2];
          const INITIAL_STD_LINEAR_BASE  = new Array(FEAT_DIM).fill(0.4);
          const INITIAL_MEAN_MLP_BASE    = new Array(MLP_PARAM_DIM).fill(0.0);
          const INITIAL_STD_MLP_BASE     = new Array(MLP_PARAM_DIM).fill(0.2);

          function paramDim(){ return (train && train.modelType === 'mlp') ? MLP_PARAM_DIM : FEAT_DIM; }
          function makeTyped(vals){ const arr = newWeightArray(vals.length); for(let i=0;i<vals.length;i++) arr[i]=vals[i]; return arr; }
          function initialMean(model){ return model === 'mlp' ? makeTyped(INITIAL_MEAN_MLP_BASE) : makeTyped(INITIAL_MEAN_LINEAR_BASE); }
          function initialStd(model){ return model === 'mlp' ? makeTyped(INITIAL_STD_MLP_BASE) : makeTyped(INITIAL_STD_LINEAR_BASE); }

          function sliceSegment(arr, start, end){
            if(!arr) return null;
            if(typeof arr.subarray === 'function'){
              return arr.subarray(start, end);
            }
            return arr.slice(start, end);
          }

          function inferLayerSizesFromWeights(weights, override){
            const inputDim = FEATURE_NAMES.length;
            if(Array.isArray(override) && override.length >= 2){
              return override.slice();
            }
            if(!weights || !weights.length){
              return [inputDim, 1];
            }
            const total = weights.length;
            const cache = new Map();

            function dfs(offset, prev){
              if(offset === total){
                return [];
              }
              const key = `${offset}|${prev}`;
              if(cache.has(key)) return cache.get(key);
              const remaining = total - offset;

              if(remaining % prev === 0){
                const outSize = remaining / prev;
                const seq = [outSize];
                cache.set(key, seq);
                return seq;
              }

              const maxNext = Math.floor(remaining / (prev + 1));
              for(let next = 1; next <= maxNext; next++){
                const need = prev * next + next;
                if(need > remaining) continue;
                const rest = dfs(offset + need, next);
                if(rest){
                  const seq = [next, ...rest];
                  cache.set(key, seq);
                  return seq;
                }
              }
              cache.set(key, null);
              return null;
            }

            const seq = dfs(0, inputDim);
            if(seq){
              return [inputDim, ...seq];
            }
            if(total === inputDim){
              return [inputDim, 1];
            }
            if(total === inputDim + 1){
              return [inputDim, 1];
            }
            return [inputDim, 1];
          }

          function sliceWeightMatrices(weights, layerSizes){
            const slices = [];
            if(!weights || !layerSizes || layerSizes.length < 2) return slices;
            let offset = 0;
            const totalLen = weights.length || 0;
            for(let layer = 1; layer < layerSizes.length; layer++){
              const prev = layerSizes[layer - 1];
              const curr = layerSizes[layer];
              const weightCount = prev * curr;
              const matrix = sliceSegment(weights, offset, offset + weightCount);
              offset += weightCount;
              let bias = null;
              if(offset + curr <= totalLen){
                bias = sliceSegment(weights, offset, offset + curr);
                offset += curr;
              }
              slices.push({ weights: matrix, bias });
            }
            return slices;
          }

          function renderNetworkD3(weights, overrideLayerSizes){
            if(!networkVizEl || typeof d3 === 'undefined'){
              return;
            }
            const width = networkVizEl.clientWidth || 320;
            const height = networkVizEl.clientHeight || 220;
            const marginX = 52;
            const marginY = 28;

            let svg = d3.select(networkVizEl).select('svg');
            if(svg.empty()){
              svg = d3.select(networkVizEl)
                .append('svg')
                .attr('role', 'img')
                .attr('aria-label', 'Visualization of model weights')
                .attr('preserveAspectRatio', 'xMidYMid meet');
            }
            svg
              .attr('width', width)
              .attr('height', height)
              .attr('viewBox', `0 0 ${width} ${height}`);
            svg.selectAll('*').remove();

            if(!weights || !weights.length){
              svg.append('text')
                .attr('x', width / 2)
                .attr('y', height / 2)
                .attr('text-anchor', 'middle')
                .attr('fill', '#888')
                .text('Weights unavailable');
              return;
            }

            const layerSizes = inferLayerSizesFromWeights(weights, overrideLayerSizes);
            const slices = sliceWeightMatrices(weights, layerSizes);
            const totalLayers = layerSizes.length;
            const innerWidth = Math.max(width - 2 * marginX, 10);
            const innerHeight = Math.max(height - 2 * marginY, 10);

            const nodes = [];
            const nodeLookup = new Map();
            for(let layerIdx = 0; layerIdx < totalLayers; layerIdx++){
              const layerSize = layerSizes[layerIdx];
              const x = totalLayers === 1 ? width / 2 : marginX + (innerWidth * layerIdx) / Math.max(1, totalLayers - 1);
              const step = layerSize > 1 ? innerHeight / (layerSize - 1) : 0;
              const biasSlice = layerIdx > 0 && slices[layerIdx - 1] ? slices[layerIdx - 1].bias : null;
              for(let i = 0; i < layerSize; i++){
                const y = layerSize > 1 ? marginY + step * i : height / 2;
                const id = `${layerIdx}-${i}`;
                const label = layerIdx === 0
                  ? (FEATURE_NAMES[i] || `x${i + 1}`)
                  : (layerIdx === totalLayers - 1
                    ? (layerSize === 1 ? 'Output' : `y${i + 1}`)
                    : `h${layerIdx}-${i + 1}`);
                const biasVal = (biasSlice && biasSlice.length > i) ? biasSlice[i] : null;
                const node = { id, layer: layerIdx, index: i, x, y, label, bias: biasVal };
                nodes.push(node);
                nodeLookup.set(id, node);
              }
            }

            const edges = [];
            for(let layerIdx = 1; layerIdx < layerSizes.length; layerIdx++){
              const prev = layerSizes[layerIdx - 1];
              const curr = layerSizes[layerIdx];
              const slice = slices[layerIdx - 1];
              const matrix = slice && slice.weights ? slice.weights : null;
              for(let i = 0; i < prev; i++){
                for(let j = 0; j < curr; j++){
                  const wIdx = matrix ? (i * curr + j) : null;
                  const weightValue = (matrix && wIdx !== null && wIdx < matrix.length) ? matrix[wIdx] : 0;
                  edges.push({
                    source: nodeLookup.get(`${layerIdx - 1}-${i}`),
                    target: nodeLookup.get(`${layerIdx}-${j}`),
                    weight: weightValue,
                  });
                }
              }
            }

            const maxAbs = edges.length ? d3.max(edges, (d) => Math.abs(d.weight)) : 0;
            const denom = (maxAbs && Number.isFinite(maxAbs) && maxAbs > 0) ? maxAbs : 1;

            const edgeGroup = svg.append('g').attr('class', 'edges');
            const edgeSel = edgeGroup.selectAll('line')
              .data(edges)
              .enter()
              .append('line')
              .attr('x1', (d) => d.source ? d.source.x : 0)
              .attr('y1', (d) => d.source ? d.source.y : 0)
              .attr('x2', (d) => d.target ? d.target.x : 0)
              .attr('y2', (d) => d.target ? d.target.y : 0)
              .attr('stroke', (d) => (d.weight >= 0 ? '#2b8cbe' : '#d7301f'))
              .attr('stroke-width', (d) => {
                const norm = Math.min(1, Math.abs(d.weight) / denom);
                return 0.6 + norm * 3.4;
              })
              .attr('stroke-opacity', (d) => {
                const norm = Math.min(1, Math.abs(d.weight) / denom);
                return 0.2 + norm * 0.8;
              });
            edgeSel.append('title').text((d) => `w=${d.weight.toFixed(3)}`);

            const nodeGroup = svg.append('g').attr('class', 'nodes');
            const nodeSel = nodeGroup.selectAll('g')
              .data(nodes)
              .enter()
              .append('g')
              .attr('transform', (d) => `translate(${d.x}, ${d.y})`);

            nodeSel.append('circle')
              .attr('r', 10)
              .attr('fill', '#fff')
              .attr('stroke', '#555')
              .attr('stroke-width', 1.2);

            nodeSel.append('text')
              .attr('text-anchor', (d) => {
                if(d.layer === 0) return 'end';
                if(d.layer === totalLayers - 1) return 'start';
                return 'middle';
              })
              .attr('x', (d) => {
                if(d.layer === 0) return -14;
                if(d.layer === totalLayers - 1) return 14;
                return 0;
              })
              .attr('dy', 4)
              .text((d) => d.label);

            nodeSel.append('title').text((d) => {
              if(d.layer === 0){
                return d.label;
              }
              if(typeof d.bias === 'number' && Number.isFinite(d.bias)){
                return `${d.label} (bias ${d.bias.toFixed(3)})`;
              }
              return d.label;
            });
          }

          const train = {
            enabled: false,
            gen: 0,
            popSize: 16,
            eliteFrac: 0.25,
            modelType: 'linear',
            dtype: DEFAULT_DTYPE,
            mean: initialMean('linear'),
            std: initialStd('linear'),
            minStd: 0.05,
            maxStd: 3.0,
            candWeights: [],
            candScores: [],
            candIndex: -1,
            phase: 'eval',
            reevalRuns: 3,
            reevalDone: 0,
            reevalAccum: 0,
            reevalTarget: -1,
            // Visualization + speed controls for training
            visualizeBoard: true,      // if false: skip board/preview rendering
            fastStepsPerFrame: 2048,   // cap for AI steps per frame when visualizeBoard=false
            currentWeightsOverride: null,
            ai: { plan: null, acc: 0 },
            clearCounts: {1:0,2:0,3:0,4:0},
            gameScores: [],
            gameModelTypes: [],
            bestFitness: -Infinity,
            bestEverFitness: -Infinity,
            bestEverWeights: null,
            genNoImprove: 0,
            // exploration config
            heavyTailFrac: 0.25,
            heavyTailScale: 3.0,
            plateauGens: 8,
            stdBoost: 1.8,
            maxPlotPoints: 4000,
          };
          window.__train = train;
          // After `train` exists, honor train.dtype for future allocations
          newWeightArray = (n) => allocWeights(n, (train && train.dtype) ? train.dtype : DEFAULT_DTYPE);

          function formatWeights(arr){ const MAX_SHOW = 24; const vals = Array.from(arr).slice(0, MAX_SHOW).map(v=>Number.isFinite(v)?v.toFixed(2):String(v)); const suffix = arr.length>MAX_SHOW? ' …' : ''; return vals.join(', ') + suffix; }
          function updateTrainStatus(){
            if(trainStatus){
              if(train.enabled){
                trainStatus.textContent = `Gen ${train.gen+1}, Candidate ${train.candIndex+1}/${train.popSize} — Model: ${train.modelType.toUpperCase()}`;
              } else {
                trainStatus.textContent = `Training stopped — Model: ${train.modelType.toUpperCase()}`;
              }
            }
            let currentWeights = null;
            if(train.currentWeightsOverride){
              currentWeights = train.currentWeightsOverride;
            } else if(train.enabled && train.candIndex >= 0 && train.candIndex < train.candWeights.length){
              currentWeights = train.candWeights[train.candIndex];
            } else if(train.mean){
              currentWeights = train.mean;
            }
            if(weightsEl){
              weightsEl.textContent = currentWeights ? `Weights: ${formatWeights(currentWeights)}` : '';
            }
            try {
              renderNetworkD3(currentWeights);
            } catch (_) {
              /* ignore render failures */
            }
          }

          function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
          function samplePopulation(){
            const dim = paramDim();
            train.candWeights = [];
            const heavyPairs = Math.floor((train.heavyTailFrac * train.popSize)/2);
            const half = Math.floor(train.popSize/2);
            const baseNoises = new Array(half);
            for(let j=0;j<half;j++){
              const eps = new Float32Array(dim);
              for(let d=0; d<dim; d++) eps[d] = randn();
              baseNoises[j] = eps;
            }
            for(let i=0;i<train.popSize;i++){
              const pair = (i<half) ? i : (i-half);
              const sign = (i<half) ? 1.0 : -1.0;
              const w = newWeightArray(dim);
              const pairScale = (pair < heavyPairs) ? train.heavyTailScale : 1.0;
              for(let d=0; d<dim; d++){
                const stdv = (train.std[d] || train.minStd) * pairScale;
                w[d] = train.mean[d] + sign * stdv * baseNoises[pair][d];
              }
              train.candWeights.push(w);
            }
            // Ensure the very first attempt (gen 0, cand 0) uses the mean weights (intentionally poor)
            if(train.gen === 0 && train.candWeights.length > 0){
              const dim0 = train.mean.length; const m = newWeightArray(dim0); for(let d=0; d<dim0; d++) m[d]=train.mean[d];
              train.candWeights[0] = m;
            }
            train.candScores = new Array(train.popSize).fill(0);
            train.candIndex = 0;
            train.clearCounts = {1:0,2:0,3:0,4:0};
          }

          function startTraining(){
            if(!state.running){ start(); }
            train.enabled = true; train.gen = 0; train.ai.plan = null; train.ai.acc = 0; samplePopulation();
            train.gameScores = [];
            train.phase = 'eval'; train.currentWeightsOverride = null; train.reevalDone = 0; train.reevalAccum = 0; train.reevalTarget = -1;
            updateTrainStatus();
            const btn = document.getElementById('train'); if(btn) btn.textContent = '⏹';
            log('Training started');
          }
          function stopTraining(){ train.enabled = false; train.ai.plan = null; const btn = document.getElementById('train'); if(btn) btn.textContent = 'AI'; log('Training stopped'); updateTrainStatus(); }
          function resetTraining(){
            stopTraining();
            // Reset mean/std based on selected model
            train.mean = initialMean(train.modelType);
            train.std = initialStd(train.modelType);
            train.gen = 0;
            train.candWeights = [];
            train.candScores = [];
            train.candIndex = -1;
            train.ai.plan = null;
            train.ai.acc = 0;
            train.clearCounts = {1:0,2:0,3:0,4:0};
            train.gameScores = [];
            train.phase = 'eval'; train.currentWeightsOverride = null; train.reevalDone = 0; train.reevalAccum = 0; train.reevalTarget = -1; train.bestFitness = -Infinity; train.bestEverFitness = -Infinity; train.bestEverWeights = null;
            updateScorePlot();
            updateTrainStatus();
            log('Training parameters reset');
          }
          window.startTraining = startTraining; window.stopTraining = stopTraining; window.resetTraining = resetTraining;

          function onGameOver(){
            log('Game over. Resetting.');
            if(train.enabled){
              // Shaped fitness: prefer multi-line clears and discourage singles
              const c = train.clearCounts || {1:0,2:0,3:0,4:0};
              const c1 = c[1] || 0, c2 = c[2] || 0, c3 = c[3] || 0, c4 = c[4] || 0;
              const fitness = SCORE_WEIGHT*state.score + 100*(4*c4 + 2*c3 + 1*c2) - 100*c1;
              if(train.candIndex >= 0) train.candScores[train.candIndex] = fitness;
              // Append raw score for progress plot and mark model type
              train.gameScores.push(state.score);
              train.gameModelTypes.push(train.modelType);
              // Cap data arrays to bound memory
              const cap = train.maxPlotPoints;
              if (train.gameScores.length > cap) {
                train.gameScores.splice(0, train.gameScores.length - cap);
                train.gameModelTypes.splice(0, train.gameModelTypes.length - cap);
              }
              updateScorePlot();
              // Re-evaluation phase handling
              if(train.phase === 'reeval'){
                train.reevalAccum += fitness; train.reevalDone += 1;
                if(train.reevalDone < train.reevalRuns){
                  Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                  state.gravity = gravityForLevel(0);
                  updateLevel(); updateScore();
                  spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                  updateTrainStatus();
                  return;
                } else {
                  const avgFit = train.reevalAccum / train.reevalRuns;
                  if(train.reevalTarget >= 0) train.candScores[train.reevalTarget] = avgFit;
                  train.currentWeightsOverride = null; train.phase = 'eval';
                  // Complete generation update after re-eval with rank-weighted elites
                  const idx = [...train.candScores.keys()].sort((a,b)=>train.candScores[b]-train.candScores[a]);
                  const eliteCount = Math.max(1, Math.floor(train.eliteFrac * train.popSize));
                  const elites = idx.slice(0, eliteCount);
                  const dim = paramDim();
                  const wsum = eliteCount*(eliteCount+1)/2;
                  const eliteMean = newWeightArray(dim);
                  for(let r=0;r<elites.length;r++){
                    const ei = elites[r]; const wCand = train.candWeights[ei]; const wRank = (eliteCount - r)/wsum;
                    for(let d=0; d<dim; d++) eliteMean[d] += wRank * wCand[d];
                  }
                  const mu = 0.3; const bestW = train.candWeights[idx[0]];
                  const newMean = newWeightArray(dim);
                  for(let d=0; d<dim; d++) newMean[d] = (1-mu)*eliteMean[d] + mu*bestW[d];
                  const newStd = newWeightArray(dim);
                  for(let r=0;r<elites.length;r++){
                    const ei = elites[r]; const wCand = train.candWeights[ei]; const wRank = (eliteCount - r)/wsum;
                    for(let d=0; d<dim; d++){ const diff=wCand[d]-eliteMean[d]; newStd[d]+= wRank*diff*diff; }
                  }
                  for(let d=0; d<dim; d++) newStd[d] = Math.max(train.minStd, Math.min(train.maxStd, Math.sqrt(newStd[d])));
                  const bestThisGen = train.candScores[idx[0]];
                  if(bestThisGen > (train.bestEverFitness ?? -Infinity)){
                    train.bestEverFitness = bestThisGen; train.bestEverWeights = new Float64Array(train.candWeights[idx[0]]);
                  }
                  if(bestThisGen > train.bestFitness){ for(let d=0; d<newStd.length; d++) newStd[d] = Math.max(train.minStd, newStd[d] * 0.85); train.bestFitness = bestThisGen; train.genNoImprove = 0; }
                  else { train.genNoImprove += 1; if(train.genNoImprove >= train.plateauGens){ for(let d=0; d<newStd.length; d++) newStd[d] = Math.min(train.maxStd, newStd[d] * train.stdBoost); train.genNoImprove = 0; log('Plateau detected: boosted exploration std'); } }
                  train.mean = newMean; train.std = newStd; train.gen += 1; log(`Gen ${train.gen} complete. Best fitness: ${bestThisGen}`);
                  samplePopulation();
                  // Elitist carryover
                  if(train.candWeights.length>0){ const copy0 = newWeightArray(bestW.length); for(let d=0; d<bestW.length; d++) copy0[d]=bestW[d]; train.candWeights[0] = copy0; }
                  if(train.bestEverWeights && train.candWeights.length>1){ const be = train.bestEverWeights; const copy1=newWeightArray(be.length); for(let d=0; d<be.length; d++) copy1[d]=be[d]; train.candWeights[1] = copy1; }
                  Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                  state.gravity = gravityForLevel(0);
                  updateLevel(); updateScore();
                  spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                  updateScorePlot();
                  log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                  updateTrainStatus();
                  return;
                }
              }
              if(train.candIndex + 1 < train.popSize){
                train.candIndex += 1;
                Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
                state.gravity = gravityForLevel(0);
                updateLevel(); updateScore();
                spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
                log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                updateTrainStatus();
              } else {
              // Start re-evaluation of best-of-gen before updating population
              const idx = [...train.candScores.keys()].sort((a,b)=>train.candScores[b]-train.candScores[a]);
              const bestIdx = idx[0];
              train.phase = 'reeval'; train.reevalTarget = bestIdx; train.reevalDone = 0; train.reevalAccum = 0; train.currentWeightsOverride = new Float64Array(train.candWeights[bestIdx]);
              Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
              state.gravity = gravityForLevel(0);
              updateLevel(); updateScore();
              spawn(); train.ai.plan = null; train.ai.acc = 0; train.clearCounts = {1:0,2:0,3:0,4:0};
              updateTrainStatus();
              return;
              }
            } else {
              Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0, level:0, pieces:0});
              state.gravity = gravityForLevel(0);
              updateLevel(); updateScore();
              spawn();
            }
          }
          window.__onGameOver = onGameOver;

          function uniqueRotIdx(shape){ const states = SHAPES[shape]; const seen = new Set(); const out=[]; for(let i=0;i<states.length;i++){ const key = JSON.stringify(states[i].slice().sort()); if(!seen.has(key)){ seen.add(key); out.push(i); } } return out; }
          function stateWidth(state){ let maxC=0; for(const [,c] of state) if(c>maxC) maxC=c; return maxC+1; }
          function copyGrid(g){ return g.map(r=>r.slice()); }
          function dropRowSim(grid, piece){ if(!canMove(grid,piece,0,0)) return null; while(canMove(grid,piece,0,1)) piece.move(0,1); return piece.row; }

          // Approximate delay between horizontal moves in ms, used to estimate
          // how many sideways shifts are possible before a gravity drop.
          const HORIZONTAL_MOVE_INTERVAL_MS = 100;

          // Return true if a piece can reach (rot, col) from spawn under gravity.
          function pathClear(grid, shape, rot, col, level){
            // Start from spawn
            const spawnCol = Math.floor(WIDTH/2) - 2;
            const piece = new Piece(shape);
            piece.row = 0; piece.col = spawnCol; piece.rot = 0;

            // Try rotate-at-spawn step-by-step
            const statesLen = SHAPES[shape].length;
            const rotSteps = (rot - piece.rot + statesLen) % statesLen;
            for(let i=0; i<rotSteps; i++){
              piece.rotate();
              if(!canMove(grid, piece, 0, 0)) return false;
            }

            // Compute the final resting row from the target column/rotation
            const target = new Piece(shape);
            target.row = 0; target.col = col; target.rot = rot;
            const finalRow = dropRowSim(grid, target);
            if(finalRow === null) return false;

            // If already in the right column, ensure vertical path is clear
            if(col === piece.col){
              while(piece.row < finalRow){
                if(!canMove(grid, piece, 0, 1)) return false;
                piece.move(0, 1);
              }
              return true;
            }

            // Level 29: treat as instant drop (no horizontal movement)
            if(level >= 29) return false;

            // Estimate how many horizontal moves fit per gravity tick
            const gravity = gravityForLevel(level);
            const movesPerRow = Math.max(1, Math.floor(gravity / HORIZONTAL_MOVE_INTERVAL_MS));

            // Translate toward target column under gravity
            while(piece.col !== col){
              // Gravity first
              if(!canMove(grid, piece, 0, 1)) return false;
              piece.move(0, 1);

              const dir = (col > piece.col) ? 1 : -1;
              const steps = Math.min(movesPerRow, Math.abs(col - piece.col));
              for(let s=0; s<steps; s++){
                if(!canMove(grid, piece, dir, 0)) return false;
                piece.move(dir, 0);
              }
            }

            // Finish dropping to the final row
            while(piece.row < finalRow){
              if(!canMove(grid, piece, 0, 1)) return false;
              piece.move(0, 1);
            }
            return true;
          }

          function enumeratePlacements(grid, shape){
            const actions=[]; const rotIdx=uniqueRotIdx(shape);
            for(const rot of rotIdx){
              const width=stateWidth(SHAPES[shape][rot]);
              for(let col=0; col<=WIDTH-width; col++){
                const p=new Piece(shape); p.rot=rot; p.row=0; p.col=col;
                const fr=dropRowSim(grid,p);
                if(fr!==null && pathClear(grid, shape, rot, col, state.level)) actions.push({rot,col});
              }
            }
            return actions;
          }
          function lockSim(grid, piece){ for(const [r,c] of piece.blocks()) grid[r][c]=1; }
          function clearRowsSim(grid){ let remaining = grid.filter(row => row.some(v => v===0)); const cleared = HEIGHT - remaining.length; while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0)); for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r]; return cleared; }
          function columnHeights(grid){ const h=Array(WIDTH).fill(0); for(let c=0;c<WIDTH;c++){ let r=0; while(r<HEIGHT && grid[r][c]===0) r++; h[c]=HEIGHT-r; } return h; }
          function countHoles(grid){ let holes=0; for(let c=0;c<WIDTH;c++){ let seen=false; for(let r=0;r<HEIGHT;r++){ const v=grid[r][c]; if(v){ seen=true; } else if(seen){ holes++; } } } return holes; }
          function bumpiness(heights){ let b=0; for(let c=0;c<WIDTH-1;c++) b+=Math.abs(heights[c]-heights[c+1]); return b; }
          function wellMetrics(heights){ let wellSum=0; let edgeWell=0; for(let c=0;c<WIDTH;c++){ let left = (c>0)?heights[c-1]:Infinity; let right = (c<WIDTH-1)?heights[c+1]:Infinity; let minNbr = Math.min(left,right); let depth = minNbr - heights[c]; if(depth>0) wellSum += depth; if(c===0) edgeWell = Math.max(edgeWell, right - heights[0]); if(c===WIDTH-1) edgeWell = Math.max(edgeWell, left - heights[WIDTH-1]); } return {wellSum, edgeWell: Math.max(0, edgeWell)}; }
          function contactArea(g){ let contact=0; for(let r=0;r<HEIGHT;r++){ for(let c=0;c<WIDTH;c++){ if(!g[r][c]) continue; // bottom
                if(r===HEIGHT-1 || g[r+1][c]) contact++; // left
                if(c>0 && g[r][c-1]) contact++; // right
                if(c<WIDTH-1 && g[r][c+1]) contact++; } } return contact; }
          function rowTransitions(g){ let t=0; for(let r=0;r<HEIGHT;r++){ let prev=0; for(let c=0;c<WIDTH;c++){ const cur = g[r][c]?1:0; if(cur!==prev) t++; prev=cur; } if(prev!==0) t++; } return t; }
          function colTransitions(g){ let t=0; for(let c=0;c<WIDTH;c++){ let prev=0; for(let r=0;r<HEIGHT;r++){ const cur = g[r][c]?1:0; if(cur!==prev) t++; prev=cur; } if(prev!==0) t++; } return t; }
          function simulateAfterPlacement(grid, shape, rot, col){ const g=copyGrid(grid); const p=new Piece(shape); p.rot=rot; p.row=0; p.col=col; const fr=dropRowSim(g,p); if(fr===null) return null; p.row=fr; lockSim(g,p); const lines=clearRowsSim(g); return {grid:g, lines}; }
          function featuresFromGrid(g, lines){ const h=columnHeights(g); const Holes=countHoles(g); const Bump=bumpiness(h); const maxH=Math.max(...h); const {wellSum, edgeWell}=wellMetrics(h); const Contact=contactArea(g); const rT=rowTransitions(g); const cT=colTransitions(g); const aggH=h.reduce((a,b)=>a+b,0);
            // Scaling
            const sLines = lines/4; const sLines2=(lines*lines)/16; const sHoles=Holes/(WIDTH*HEIGHT); const sBump=Bump/((WIDTH-1)*HEIGHT); const sMaxH=maxH/HEIGHT; const sWell=wellSum/(WIDTH*HEIGHT); const sEdge=edgeWell/HEIGHT; const sContact=Contact/(WIDTH*HEIGHT*2); const sRT=rT/(WIDTH*HEIGHT); const sCT=cT/(WIDTH*HEIGHT); const sAgg=aggH/(WIDTH*HEIGHT);
            const is1=lines===1?1:0, is2=lines===2?1:0, is3=lines===3?1:0, is4=lines===4?1:0;
            return [sLines, sLines2, is1, is2, is3, is4, sHoles, sBump, sMaxH, sWell, sEdge, sContact, sRT, sCT, sAgg]; }
          function featuresForPlacement(grid, shape, rot, col){ const sim=simulateAfterPlacement(grid, shape, rot, col); if(!sim) return null; const feats = featuresFromGrid(sim.grid, sim.lines); return { feats, lines: sim.lines, grid: sim.grid } }
          function dot(weights, feats){ let s=0; for(let d=0; d<FEAT_DIM; d++) s+=weights[d]*feats[d]; return s; }
          function scorePlacement(weights, grid, shape, act){ const ff=featuresForPlacement(grid, shape, act.rot, act.col); if(!ff) return -Infinity; return dot(weights, ff.feats); }
          function choosePlacement(weights, grid, shape){ const acts=enumeratePlacements(grid, shape); if(acts.length===0) return null; let best=acts[0], bestS=-Infinity; for(const a of acts){ const s=scorePlacement(weights, grid, shape, a); if(s>bestS){ bestS=s; best=a; } } return best; }
          function mlpScore(weights, feats){
            // weights layout: [W1 (FEAT_DIM*H1), b1 (H1), W2 (H1), b2 (1)]
            const H = MLP_H1;
            const W1 = weights.subarray(0, FEAT_DIM*H);
            const b1 = weights.subarray(FEAT_DIM*H, FEAT_DIM*H + H);
            const W2 = weights.subarray(FEAT_DIM*H + H, FEAT_DIM*H + H + H);
            const b2 = weights[FEAT_DIM*H + H + H];
            // Manual forward (faster than tf.js per-placement)
            const h = new Float64Array(H);
            for(let j=0;j<H;j++){
              let sum = b1[j];
              for(let i=0;i<FEAT_DIM;i++) sum += feats[i] * W1[i*H + j];
              h[j] = sum > 0 ? sum : 0;
            }
            let y = b2;
            for(let j=0;j<H;j++) y += h[j] * W2[j];
            return y;
          }
          function scoreFeats(weights, feats){ return (train.modelType === 'mlp') ? mlpScore(weights, feats) : dot(weights, feats); }
          function choosePlacement2(weights, grid, curShape, nextShape){ const acts=enumeratePlacements(grid, curShape); if(acts.length===0) return null; let best=acts[0], bestS=-Infinity; const sims=[]; // precompute first-ply sims and scores
            for(const a of acts){ const sim=simulateAfterPlacement(grid, curShape, a.rot, a.col); if(!sim) continue; const baseFeats = featuresFromGrid(sim.grid, sim.lines); const s1 = scoreFeats(weights, baseFeats); sims.push({a, sim, s1}); }
            if(sims.length===0) return null;
            // Beam: consider lookahead only for top-K first-ply moves
            sims.sort((u,v)=>v.s1 - u.s1);
            const K = Math.min(LOOKAHEAD_BEAM, sims.length);
            const acts2Cache = new WeakMap();
            for(let i=0;i<sims.length;i++){
              let s = sims[i].s1;
              if(nextShape && i < K){ let acts2 = acts2Cache.get(sims[i].sim.grid); if(!acts2){ acts2 = enumeratePlacements(sims[i].sim.grid, nextShape); acts2Cache.set(sims[i].sim.grid, acts2); } if(acts2.length>0){ let best2=-Infinity; for(const a2 of acts2){ const ff2=featuresForPlacement(sims[i].sim.grid, nextShape, a2.rot, a2.col); if(!ff2) continue; const s2=scoreFeats(weights, ff2.feats); if(s2>best2) best2=s2; } if(isFinite(best2)) s += LOOKAHEAD_LAMBDA*best2; }
              }
              if(s>bestS){ bestS=s; best=sims[i].a; }
            }
            return best; }

          function planForCurrentPiece(){ if(!state.active) return null; const w = train.currentWeightsOverride || train.candWeights[train.candIndex] || train.mean; const a=choosePlacement2(w, state.grid, state.active.shape, state.next); if(!a){ return null; } const len=SHAPES[state.active.shape].length; const cur=state.active.rot % len; const needRot=(a.rot - cur + len) % len; return { targetRot:a.rot, targetCol:a.col, rotLeft:needRot, stage:'rotate' }; }

          // Scatter plot of raw score per game (all candidates)
          function updateScorePlot(){
            const canvas = document.getElementById('score-plot');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            ctx.clearRect(0,0,W,H);
            const padL=22, padB=16, padR=6, padT=6;
            // axes
            ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padL, H-padB); ctx.lineTo(W-padR, H-padB);
            ctx.moveTo(padL, H-padB); ctx.lineTo(padL, padT);
            ctx.stroke();
            const scores = (window.__train && window.__train.gameScores) ? window.__train.gameScores : [];
            const types  = (window.__train && window.__train.gameModelTypes) ? window.__train.gameModelTypes : [];
            if(!scores || scores.length===0) return;
            const maxY = Math.max(1000, Math.max(...scores));
            const xw = (W - padL - padR), yh = (H - padT - padB);
            ctx.fillStyle = '#666'; ctx.font = '10px sans-serif';
            ctx.fillText('0', 4, H-padB+10);
            ctx.fillText(String(maxY), 2, padT+8);
            const COLORS = { linear: '#1f77b4', mlp: '#ff7f0e' };
            for(let i=0;i<scores.length;i++){
              const x = padL + (scores.length<=1?0:(i/(scores.length-1)))*xw;
              const y = H - padB - (scores[i]/maxY)*yh;
              const t = types[i] || 'linear';
              ctx.fillStyle = COLORS[t] || '#1f77b4';
              ctx.fillRect(Math.round(x)-1, Math.round(y)-1, 3, 3);
            }
          }

          function runAiMicroStep(){
            if(!state.active){ return false; }

            // Watchdog: if the active piece hasn't changed state for a while, force a drop
            const sig = `${state.active.shape}:${state.active.rot}:${state.active.row}:${state.active.col}:${state.score}`;
            if(train.ai.lastSig === sig){ train.ai.staleMs = (train.ai.staleMs || 0) + AI_STEP_MS; } else { train.ai.staleMs = 0; train.ai.lastSig = sig; }
            if(train.ai.staleMs > 1000){
              log('AI: watchdog forced drop');
              while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
              lock(state.grid, state.active);
              state.pieces++;
              if(state.pieces % 20 === 0){ state.level++; state.gravity = gravityForLevel(state.level); updateLevel(); }
              const cleared = clearRows(state.grid);
              if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
              if(state.grid[0].some(v => v !== 0)) {
                onGameOver();
                train.ai.plan = null;
                train.ai.staleMs = 0;
                return false;
              }
              spawn();
              train.ai.plan = null;
              train.ai.staleMs = 0;
              if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
              return false;
            }

            if(!train.ai.plan){
              train.ai.plan = planForCurrentPiece();
              if(!train.ai.plan){
                // force drop to end episode
                while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                lock(state.grid, state.active);
                state.pieces++;
                if(state.pieces % 20 === 0){
                  state.level++;
                  state.gravity = gravityForLevel(state.level);
                  updateLevel();
                }
                const cleared = clearRows(state.grid);
                if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
                if(state.grid[0].some(v => v !== 0)) {
                  log('AI: top-out after forced drop');
                  onGameOver();
                  return false;
                }
                spawn();
                if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
                return false;
              }
            }
            const plan = train.ai.plan; if(!plan) return true;
            if(plan.stage==='rotate'){
              if(plan.rotLeft>0){
                state.active.rotate();
                if(!canMove(state.grid, state.active, 0, 0)){
                  // Rotation blocked: abandon this plan to avoid stalling
                  state.active.rotate(-1);
                  train.ai.plan = null; log('AI: rotation blocked, abandoning plan');
                } else {
                  plan.rotLeft -= 1;
                }
                return true;
              }
              plan.stage='move'; return true;
            }
            if(plan.stage==='move'){
              if(state.active.col < plan.targetCol){ if(canMove(state.grid, state.active, 1, 0)) state.active.move(1,0); else plan.stage='drop'; return true; }
              if(state.active.col > plan.targetCol){ if(canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0); else plan.stage='drop'; return true; }
              plan.stage='drop'; return true;
            }
            if(plan.stage==='drop'){
              if(canMove(state.grid, state.active, 0, 1)){ state.active.move(0,1); return true; }
              lock(state.grid, state.active);
              state.pieces++;
              if(state.pieces % 20 === 0){
                state.level++;
                state.gravity = gravityForLevel(state.level);
                updateLevel();
              }
              const cleared = clearRows(state.grid);
              if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); recordClear(cleared); }
              if(state.grid[0].some(v => v !== 0)) {
                log('AI: top-out after drop');
                onGameOver();
                train.ai.plan = null;
                return false;
              }
              spawn();
              train.ai.plan = null;
              if(!canMove(state.grid, state.active, 0, 0)) onGameOver();
              return false;
            }
            return true;
          }

          function aiStep(dt){
            if(!state.active){ return; }
            if(!canMove(state.grid, state.active, 0, 0)) { log('AI: spawn blocked -> game over'); onGameOver(); return; }

            const fastMode = train && train.enabled && train.visualizeBoard === false;
            const __limit = fastMode ? train.fastStepsPerFrame : MAX_AI_STEPS_PER_FRAME;
            let __aiSteps = 0;

            if(fastMode){
              train.ai.acc = 0;
              while(__aiSteps < __limit){
                __aiSteps += 1;
                if(!runAiMicroStep()){
                  return;
                }
              }
              return;
            }

            train.ai.acc += dt;
            while (train.ai.acc >= AI_STEP_MS && __aiSteps < __limit) {
              train.ai.acc -= AI_STEP_MS;
              __aiSteps += 1;
              if(!runAiMicroStep()){
                return;
              }
            }
          }
          window.__aiStep = aiStep;

          // Hook up training buttons
          const trainBtn = document.getElementById('train');
          if(trainBtn){ trainBtn.addEventListener('click', () => { if(train.enabled) stopTraining(); else startTraining(); }); }
          const trainResetBtn = document.getElementById('train-reset');
          if(trainResetBtn){ trainResetBtn.addEventListener('click', resetTraining); }
          const renderToggleBtn = document.getElementById('render-toggle');
          function updateRenderToggleBtn(){ if(renderToggleBtn) renderToggleBtn.textContent = (train.visualizeBoard ? 'Hide' : 'Show'); }
          if(renderToggleBtn){
            renderToggleBtn.addEventListener('click', () => {
              train.visualizeBoard = !train.visualizeBoard;
              updateRenderToggleBtn();
              // When re-enabling visualization, draw current state immediately
              if(train.visualizeBoard){
                try { draw(state.grid, state.active); drawNext(state.next); } catch(_) {}
                updateScore(true); updateLevel(true);
              }
            });
          }
          updateRenderToggleBtn();
          const modelSel = document.getElementById('model-select');
          function setModelType(mt){
            if(mt !== 'linear' && mt !== 'mlp') return;
            const wasRunning = train.enabled;
            if(wasRunning) stopTraining();
            train.modelType = mt;
            // Prefer f16 for MLP if available, else f32
            train.dtype = (mt==='mlp' && HAS_F16) ? 'f16' : 'f32';
            // Re-init mean/std to the appropriate initial values for this model
            train.mean = initialMean(mt);
            train.std  = initialStd(mt);
            updateTrainStatus();
            // Reset training state
            resetTraining();
            if(wasRunning) startTraining();
          }
          if(modelSel){ modelSel.addEventListener('change', (e) => setModelType(modelSel.value)); }
          updateTrainStatus();
        })();
      })();
    </script>
  </body>
</html>

