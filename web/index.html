<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://pyscript.net https://cdn.jsdelivr.net data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://pyscript.net https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://pyscript.net; connect-src 'self' https://pyscript.net https://cdn.jsdelivr.net data: blob:; img-src 'self' data:;" />
    <title>Tetris</title>
    
    <style>
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        padding: 0;
      }
      #canvas {
        margin: 0;
        border: 2px solid #000;
        display: block;
      }
      .game {
        margin: 24px auto 0 auto;
        display: flex;
        gap: 16px;
        justify-content: center;
        align-items: flex-start;
        max-width: 560px;
      }
      .sidebar {
        width: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }
      .panel {
        width: 160px;
        padding: 8px;
        border: 1px solid #ccc;
        background: #fdfdfd;
      }
      .panel-title {
        font-size: 12px;
        color: #555;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        margin-bottom: 6px;
      }
      #preview {
        display: block;
        width: 160px;
        height: 160px;
        border: 1px solid #eee;
        background: #fff;
      }
      #score {
        font-family: Georgia, "Times New Roman", "Palatino Linotype", "Book Antiqua", serif;
        font-size: 22px;
        line-height: 1.2;
        color: #222;
      }
      .controls {
        margin: 12px auto;
        display: flex;
        gap: 12px;
        justify-content: center;
        align-items: center;
      }
      .icon-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: 1px solid #bbb;
        background: #fff;
        font-size: 20px;
        line-height: 44px;
        cursor: pointer;
        box-shadow: 0 1px 2px rgba(0,0,0,0.08);
      }
      .icon-btn:active { transform: translateY(1px); }
      #diagnostics {
        width: 320px;
        height: 140px;
        margin: 12px auto 24px auto;
        padding: 8px;
        border: 1px solid #ccc;
        background: #fafafa;
        text-align: left;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
      }
      @media (max-width: 600px) {
        .game {
          flex-direction: column;
          max-width: 100%;
          align-items: center;
        }
        #canvas {
          width: 90vw;
          height: auto;
          max-width: 300px;
          margin: 0 auto;
        }
        .sidebar {
          width: 100%;
          flex-direction: row;
          justify-content: center;
        }
        .panel {
          width: auto;
        }
        #preview {
          width: 80px;
          height: 80px;
        }
        .controls {
          flex-wrap: wrap;
        }
        .icon-btn {
          width: 56px;
          height: 56px;
          font-size: 24px;
          line-height: 56px;
        }
      }
      /* No external runtimes required; pure JS renderer */
    </style>
  </head>
  <body>
    <h1>Tetris</h1>
    <noscript>
      <div style="color:#b00020;margin:12px;">JavaScript is disabled. Enable it to play.</div>
    </noscript>
    <div class="game">
      <canvas id="canvas" width="300" height="600" tabindex="0"></canvas>
      <div class="sidebar">
        <div class="panel">
          <div class="panel-title">Next</div>
          <canvas id="preview" width="160" height="160"></canvas>
        </div>
        <div id="level">Level: 0</div>
        <div id="score">Score: 0</div>
      </div>
    </div>
    <div class="controls">
      <button id="toggle" class="icon-btn" title="Play/Pause" aria-label="Play/Pause">▶</button>
      <button id="reset" class="icon-btn" title="Reset" aria-label="Reset">⟲</button>
    </div>
    <div class="controls">
      <button id="train" class="icon-btn" title="Start/Stop Training" aria-label="Start/Stop Training">AI</button>
      <button id="train-reset" class="icon-btn" title="Reset Training" aria-label="Reset Training">♻️</button>
    </div>
    <div class="controls">
      <label for="speed" id="speed-label">Speed: <span id="speed-display">1x</span></label>
      <input id="speed" type="range" min="1" max="50" value="1" />
    </div>
    <div id="train-status"></div>
    <div id="weights-display"></div>
    <div id="diagnostics" aria-live="polite"></div>
    <script>
      // --- Minimal Tetris in plain JavaScript (no PyScript) ---
      (function () {
        const canvas = document.getElementById('canvas');
        const preview = document.getElementById('preview');
        const diag = document.getElementById('diagnostics');
        const trainStatus = document.getElementById('train-status');
        const weightsEl = document.getElementById('weights-display');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const ctx = canvas.getContext('2d');
        const pctx = preview.getContext('2d');
        const CELL = 30, WIDTH = 10, HEIGHT = 20;
        const PREV_CELL = 28; // slightly smaller cell for preview
        const speedSlider = document.getElementById('speed');
        const speedDisplay = document.getElementById('speed-display');
        let speedMult = 1;
        if (speedSlider) {
          speedSlider.addEventListener('input', () => {
            speedMult = Number(speedSlider.value);
            if (speedDisplay) speedDisplay.textContent = `${speedMult}x`;
            if (state.running) {
              clearTimeout(state.raf);
              scheduleNext();
            }
          });
        }

        const log = (t) => {
          if (!diag) return;
          const d = document.createElement('div');
          const now = new Date().toLocaleTimeString();
          d.textContent = `[${now}] ${t}`;
          diag.prepend(d);
        };

        const Shapes = {
          I: [[0,0],[0,1],[0,2],[0,3]],
          O: [[0,0],[0,1],[1,0],[1,1]],
          T: [[0,0],[0,1],[0,2],[1,1]],
          S: [[0,1],[0,2],[1,0],[1,1]],
          Z: [[0,0],[0,1],[1,1],[1,2]],
          J: [[0,0],[1,0],[1,1],[1,2]],
          L: [[0,2],[1,0],[1,1],[1,2]],
        };

        const rotate = (state) => {
          const rot = state.map(([r,c]) => [c, -r]);
          let minR = Math.min(...rot.map(([r]) => r));
          let minC = Math.min(...rot.map(([,c]) => c));
          return rot.map(([r,c]) => [r - minR, c - minC]);
        };

        const genRotations = (s) => {
          const r = [s];
          for (let i=0;i<3;i++) r.push(s = rotate(s));
          return r;
        };

        const SHAPES = {};
        for (const k of Object.keys(Shapes)) SHAPES[k] = genRotations(Shapes[k]);

        const emptyGrid = () => Array.from({length: HEIGHT}, () => Array(WIDTH).fill(0));

        // Level speed table roughly matching classic NES Tetris
        const LEVEL_FRAMES = {
          0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6,
          10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2,
          20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1
        };
        const gravityForLevel = (lvl) => {
          const frames = LEVEL_FRAMES[Math.min(lvl,29)];
          return (frames/60)*1000; // convert frames to ms
        };

        class Piece {
          constructor(shape){ this.shape = shape; this.rot = 0; this.row = 0; this.col = Math.floor(WIDTH/2) - 2; }
          blocks(){ const s = SHAPES[this.shape][this.rot]; return s.map(([dr,dc]) => [this.row+dr, this.col+dc]); }
          move(dx,dy){ this.col += dx; this.row += dy; }
          rotate(dir=1){ const states = SHAPES[this.shape]; this.rot = (this.rot + (dir>=0?1:states.length-1)) % states.length; }
        }

        const canMove = (grid, piece, dx, dy) => {
          for(const [r,c] of piece.blocks()){
            const nr = r + dy, nc = c + dx;
            if (nr < 0 || nr >= HEIGHT || nc < 0 || nc >= WIDTH) return false;
            if (grid[nr][nc] !== 0) return false;
          }
          return true;
        };

        const lock = (grid, piece) => { for(const [r,c] of piece.blocks()) grid[r][c] = piece.shape; };

        const clearRows = (grid) => {
          let remaining = grid.filter(row => row.some(v => v===0));
          const cleared = HEIGHT - remaining.length;
          while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0));
          for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r];
          return cleared;
        };

        const SHAPE_COLORS = {
          I: '#00ffff', O: '#ffff00', T: '#800080', S: '#00ff00', Z: '#ff0000', J: '#0000ff', L: '#ffa500'
        };

        function draw(grid, active){
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,WIDTH*CELL,HEIGHT*CELL);
          // locked
          for(let r=0;r<HEIGHT;r++){
            for(let c=0;c<WIDTH;c++){
              const val = grid[r][c];
              if(val){ ctx.fillStyle = SHAPE_COLORS[val] || '#444'; ctx.fillRect(c*CELL,r*CELL,CELL,CELL); }
              ctx.strokeStyle = '#333'; ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);
            }
          }
          // active
          if(active){ ctx.fillStyle = SHAPE_COLORS[active.shape] || '#6cf'; for(const [r,c] of active.blocks()){ ctx.fillRect(c*CELL,r*CELL,CELL,CELL); ctx.strokeStyle = '#333'; ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);} }
        }

        function drawNext(shape){
          const W = preview.width, H = preview.height;
          pctx.fillStyle = '#ffffff'; pctx.fillRect(0,0,W,H);
          pctx.strokeStyle = '#f0f0f0'; pctx.strokeRect(0,0,W,H);
          if(!shape) return;
          const state = SHAPES[shape][0];
          let minR=Infinity, minC=Infinity, maxR=-Infinity, maxC=-Infinity;
          for(const [r,c] of state){ minR=Math.min(minR,r); minC=Math.min(minC,c); maxR=Math.max(maxR,r); maxC=Math.max(maxC,c); }
          const w = (maxC-minC+1)*PREV_CELL; const h = (maxR-minR+1)*PREV_CELL;
          const offX = Math.floor((W - w)/2); const offY = Math.floor((H - h)/2);
          pctx.fillStyle = SHAPE_COLORS[shape] || '#6cf';
          for(const [r,c] of state){
            const x = offX + (c-minC)*PREV_CELL;
            const y = offY + (r-minR)*PREV_CELL;
            pctx.fillRect(x, y, PREV_CELL, PREV_CELL);
            pctx.strokeStyle = '#dddddd';
            pctx.strokeRect(x, y, PREV_CELL, PREV_CELL);
          }
        }

        function updateScore(){ if(scoreEl) scoreEl.textContent = `Score: ${state.score}`; }
        function updateLevel(){ if(levelEl) levelEl.textContent = `Level: ${state.level}`; }

        const state = { grid: emptyGrid(), active: null, next: null, score: 0, level:0, pieces:0, running:false, paused:false, last:0, acc:0, gravity:gravityForLevel(0), raf:null };

        const shapes = Object.keys(SHAPES);
        const randShape = () => shapes[Math.floor(Math.random()*shapes.length)];

        const spawn = () => { const s = state.next || randShape(); state.active = new Piece(s); state.next = randShape(); drawNext(state.next); updateScore(); updateLevel(); };

        const scheduleNext = () => {
          const delay = 1000 / (60 * speedMult);
          state.raf = setTimeout(() => tick(performance.now()), delay);
        };

        function tick(ts){
          if(!state.running){ return; }
          if(!state.last) state.last = ts;
          const dt = ts - state.last; state.last = ts;
          const effDt = dt * speedMult;
          if(!state.paused && state.active){
            // Global guard: if the active piece cannot exist at its current
            // position (e.g., spawn collision), trigger game over/reset.
            if(!canMove(state.grid, state.active, 0, 0)){
              window.__onGameOver();
              draw(state.grid, state.active);
              scheduleNext();
              return;
            }
            if(window.__train && window.__train.enabled){
              window.__aiStep(effDt);
            } else {
              state.acc += effDt;
              while(state.acc >= state.gravity){
                state.acc -= state.gravity;
                if(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                else {
                  lock(state.grid, state.active);
                  state.pieces++;
                  if(state.pieces % 20 === 0){
                    state.level++;
                    state.gravity = gravityForLevel(state.level);
                    updateLevel();
                  }
                  const cleared = clearRows(state.grid);
                  if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); log(`Cleared ${cleared} row(s). Score: ${state.score}`); }
                  // Top-out guard after lock/clear in manual mode
                  if(state.grid[0].some(v => v !== 0)) { window.__onGameOver(); }
                  else {
                    spawn();
                    if(!canMove(state.grid, state.active, 0, 0)){ window.__onGameOver(); }
                  }
                }
              }
            }
          }
          draw(state.grid, state.active);
          scheduleNext();
        }

        function start(){ if(state.running){ log('Already running'); return; } canvas.focus(); state.grid = emptyGrid(); state.score=0; state.level=0; state.pieces=0; state.gravity=gravityForLevel(0); updateScore(); updateLevel(); state.last=0; state.acc=0; state.running=true; state.paused=false; spawn(); draw(state.grid, state.active); scheduleNext(); log('Game started'); renderControls(); }
        function pause(){ if(!state.running){ log('Pause ignored: not running'); return; } state.paused=true; log('Paused'); }
        function resume(){ if(!state.running){ log('Resume ignored: not running'); return; } state.paused=false; log('Resumed'); }
        function stop(){ if(!state.running){ log('Stop ignored: not running'); return; } state.running=false; state.paused=false; if(state.raf) clearTimeout(state.raf); log('Game stopped'); renderControls(); }

        // Toggle + reset controls
        const toggleBtn = document.getElementById('toggle');
        const resetBtn = document.getElementById('reset');
        function renderControls(){ toggleBtn.textContent = (!state.running || state.paused) ? '▶' : '⏸'; }
        function togglePlayPause(){ if(!state.running){ start(); } else if(state.paused){ resume(); } else { pause(); } renderControls(); }
        function resetGame(){ if(state.running){ stop(); } start(); }

        // keyboard
        const BLOCK_KEYS = new Set(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','PageUp','PageDown','Home','End']);
        document.addEventListener('keydown', (e) => {
          if(!state.running) return;
          if (BLOCK_KEYS.has(e.key)) e.preventDefault();
          if(state.paused || !state.active || (window.__train && window.__train.enabled)) return;
          if(e.key==='ArrowLeft' && canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0);
          else if(e.key==='ArrowRight' && canMove(state.grid, state.active, 1, 0)) state.active.move(1,0);
          else if(e.key==='ArrowUp'){ state.active.rotate(); if(!canMove(state.grid, state.active, 0, 0)) state.active.rotate(-1); }
          else if(e.key==='ArrowDown' && canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
          else if(e.key===' '){
            while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
            lock(state.grid, state.active);
            state.pieces++;
            if(state.pieces % 20 === 0){
              state.level++;
              state.gravity = gravityForLevel(state.level);
              updateLevel();
            }
            const cleared = clearRows(state.grid);
            if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); log(`Cleared ${cleared} row(s). Score: ${state.score}`);} 
            if(state.grid[0].some(v => v !== 0)) { onGameOver(); }
            else { spawn(); if(!canMove(state.grid, state.active, 0, 0)) onGameOver(); }
          }
          draw(state.grid, state.active);
        });

        // buttons
        toggleBtn.addEventListener('click', togglePlayPause);
        resetBtn.addEventListener('click', resetGame);

        log('Ready. Click Start to run.');
        renderControls();

        // ================= AI Training (placement-level with animation) =================
        // Expose minimal API on window to avoid invasive edits above
        (function(){
          const FEAT_DIM = 5;
          const AI_STEP_MS = 28; // ms between AI animation steps

          const INITIAL_MEAN = new Float64Array([1.0, -0.5, -0.8, -0.3, -0.2]);
          const INITIAL_STD = new Float64Array([0.5, 0.5, 0.5, 0.5, 0.5]);
          const train = {
            enabled: false,
            gen: 0,
            popSize: 8,
            eliteFrac: 0.25,
            mean: new Float64Array(INITIAL_MEAN),
            std: new Float64Array(INITIAL_STD),
            minStd: 0.05,
            candWeights: [],
            candScores: [],
            candIndex: -1,
            ai: { plan: null, acc: 0 },
          };
          window.__train = train;

          function formatWeights(arr){ return Array.from(arr).map(v=>v.toFixed(2)).join(', '); }
          function updateTrainStatus(){
            if(trainStatus){
              if(train.enabled){
                trainStatus.textContent = `Gen ${train.gen+1}, Candidate ${train.candIndex+1}/${train.popSize}`;
              } else {
                trainStatus.textContent = 'Training stopped';
              }
            }
            if(weightsEl){
              const w = train.enabled ? train.candWeights[train.candIndex] : train.mean;
              weightsEl.textContent = w ? `Weights: ${formatWeights(w)}` : '';
            }
          }

          function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
          function samplePopulation(){
            train.candWeights = [];
            for(let i=0;i<train.popSize;i++){
              const w = new Float64Array(FEAT_DIM);
              for(let d=0; d<FEAT_DIM; d++) w[d] = train.mean[d] + train.std[d]*randn();
              train.candWeights.push(w);
            }
            train.candScores = new Array(train.popSize).fill(0);
            train.candIndex = 0;
          }

          function startTraining(){
            if(!state.running){ start(); }
            train.enabled = true; train.gen = 0; train.ai.plan = null; train.ai.acc = 0; samplePopulation();
            updateTrainStatus();
            const btn = document.getElementById('train'); if(btn) btn.textContent = '⏹';
            log('Training started');
          }
          function stopTraining(){ train.enabled = false; train.ai.plan = null; const btn = document.getElementById('train'); if(btn) btn.textContent = 'AI'; log('Training stopped'); updateTrainStatus(); }
          function resetTraining(){
            stopTraining();
            train.mean = new Float64Array(INITIAL_MEAN);
            train.std = new Float64Array(INITIAL_STD);
            train.gen = 0;
            train.candWeights = [];
            train.candScores = [];
            train.candIndex = -1;
            train.ai.plan = null;
            train.ai.acc = 0;
            updateTrainStatus();
            log('Training parameters reset');
          }
          window.startTraining = startTraining; window.stopTraining = stopTraining; window.resetTraining = resetTraining;

          function onGameOver(){
            log('Game over. Resetting.');
            if(train.enabled){
              if(train.candIndex >= 0) train.candScores[train.candIndex] = state.score;
              if(train.candIndex + 1 < train.popSize){
                train.candIndex += 1;
                Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0});
                spawn(); train.ai.plan = null; train.ai.acc = 0;
                log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                updateTrainStatus();
              } else {
                const idx = [...train.candScores.keys()].sort((a,b)=>train.candScores[b]-train.candScores[a]);
                const eliteCount = Math.max(1, Math.floor(train.eliteFrac * train.popSize));
                const elites = idx.slice(0, eliteCount);
                const newMean = new Float64Array(FEAT_DIM);
                for(const ei of elites){ const w = train.candWeights[ei]; for(let d=0; d<FEAT_DIM; d++) newMean[d]+=w[d]; }
                for(let d=0; d<FEAT_DIM; d++) newMean[d] /= eliteCount;
                const newStd = new Float64Array(FEAT_DIM);
                for(const ei of elites){ const w = train.candWeights[ei]; for(let d=0; d<FEAT_DIM; d++){ const diff=w[d]-newMean[d]; newStd[d]+=diff*diff; } }
                for(let d=0; d<FEAT_DIM; d++) newStd[d] = Math.max(train.minStd, Math.sqrt(newStd[d]/eliteCount));
                train.mean = newMean; train.std = newStd; train.gen += 1;
                log(`Gen ${train.gen} complete. Best score: ${train.candScores[idx[0]]}`);
                samplePopulation();
                Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0});
                spawn(); train.ai.plan = null; train.ai.acc = 0;
                log(`Candidate ${train.candIndex+1}/${train.popSize} (gen ${train.gen+1})`);
                updateTrainStatus();
              }
            } else {
              Object.assign(state,{grid:emptyGrid(),active:null,next:null,score:0});
              spawn();
            }
          }
          window.__onGameOver = onGameOver;

          function uniqueRotIdx(shape){ const states = SHAPES[shape]; const seen = new Set(); const out=[]; for(let i=0;i<states.length;i++){ const key = JSON.stringify(states[i].slice().sort()); if(!seen.has(key)){ seen.add(key); out.push(i); } } return out; }
          function stateWidth(state){ let maxC=0; for(const [,c] of state) if(c>maxC) maxC=c; return maxC+1; }
          function copyGrid(g){ return g.map(r=>r.slice()); }
          function dropRowSim(grid, piece){ if(!canMove(grid,piece,0,0)) return null; while(canMove(grid,piece,0,1)) piece.move(0,1); return piece.row; }

          // Approximate delay between horizontal moves in ms, used to estimate
          // how many sideways shifts are possible before a gravity drop.
          const HORIZONTAL_MOVE_INTERVAL_MS = 100;

          // Return true if a piece can reach (rot, col) from spawn under gravity.
          function pathClear(grid, shape, rot, col, level){
            // Start from spawn
            const spawnCol = Math.floor(WIDTH/2) - 2;
            const piece = new Piece(shape);
            piece.row = 0; piece.col = spawnCol; piece.rot = 0;

            // Try rotate-at-spawn step-by-step
            const statesLen = SHAPES[shape].length;
            const rotSteps = (rot - piece.rot + statesLen) % statesLen;
            for(let i=0; i<rotSteps; i++){
              piece.rotate();
              if(!canMove(grid, piece, 0, 0)) return false;
            }

            // Compute the final resting row from the target column/rotation
            const target = new Piece(shape);
            target.row = 0; target.col = col; target.rot = rot;
            const finalRow = dropRowSim(grid, target);
            if(finalRow === null) return false;

            // If already in the right column, ensure vertical path is clear
            if(col === piece.col){
              while(piece.row < finalRow){
                if(!canMove(grid, piece, 0, 1)) return false;
                piece.move(0, 1);
              }
              return true;
            }

            // Level 29: treat as instant drop (no horizontal movement)
            if(level >= 29) return false;

            // Estimate how many horizontal moves fit per gravity tick
            const gravity = gravityForLevel(level);
            const movesPerRow = Math.max(1, Math.floor(gravity / HORIZONTAL_MOVE_INTERVAL_MS));

            // Translate toward target column under gravity
            while(piece.col !== col){
              // Gravity first
              if(!canMove(grid, piece, 0, 1)) return false;
              piece.move(0, 1);

              const dir = (col > piece.col) ? 1 : -1;
              const steps = Math.min(movesPerRow, Math.abs(col - piece.col));
              for(let s=0; s<steps; s++){
                if(!canMove(grid, piece, dir, 0)) return false;
                piece.move(dir, 0);
              }
            }

            // Finish dropping to the final row
            while(piece.row < finalRow){
              if(!canMove(grid, piece, 0, 1)) return false;
              piece.move(0, 1);
            }
            return true;
          }

          function enumeratePlacements(grid, shape){
            const actions=[]; const rotIdx=uniqueRotIdx(shape);
            for(const rot of rotIdx){
              const width=stateWidth(SHAPES[shape][rot]);
              for(let col=0; col<=WIDTH-width; col++){
                const p=new Piece(shape); p.rot=rot; p.row=0; p.col=col;
                const fr=dropRowSim(grid,p);
                if(fr!==null && pathClear(grid, shape, rot, col, state.level)) actions.push({rot,col});
              }
            }
            return actions;
          }
          function lockSim(grid, piece){ for(const [r,c] of piece.blocks()) grid[r][c]=1; }
          function clearRowsSim(grid){ let remaining = grid.filter(row => row.some(v => v===0)); const cleared = HEIGHT - remaining.length; while(remaining.length < HEIGHT) remaining.unshift(Array(WIDTH).fill(0)); for(let r=0;r<HEIGHT;r++) grid[r]=remaining[r]; return cleared; }
          function columnHeights(grid){ const h=Array(WIDTH).fill(0); for(let c=0;c<WIDTH;c++){ let r=0; while(r<HEIGHT && grid[r][c]===0) r++; h[c]=HEIGHT-r; } return h; }
          function countHoles(grid){ let holes=0; for(let c=0;c<WIDTH;c++){ let seen=false; for(let r=0;r<HEIGHT;r++){ const v=grid[r][c]; if(v){ seen=true; } else if(seen){ holes++; } } } return holes; }
          function bumpiness(heights){ let b=0; for(let c=0;c<WIDTH-1;c++) b+=Math.abs(heights[c]-heights[c+1]); return b; }
          function featuresForPlacement(grid, shape, rot, col){ const g=copyGrid(grid); const p=new Piece(shape); p.rot=rot; p.row=0; p.col=col; const fr=dropRowSim(g,p); if(fr===null) return null; p.row=fr; lockSim(g,p); const lines=clearRowsSim(g); const h=columnHeights(g); const aggH=h.reduce((a,b)=>a+b,0); const Holes=countHoles(g); const Bump=bumpiness(h); const maxH=Math.max(...h); return { feats:new Float64Array([lines, aggH, Holes, Bump, maxH]), lines } }
          function scorePlacement(weights, grid, shape, act){ const ff=featuresForPlacement(grid, shape, act.rot, act.col); if(!ff) return -Infinity; const f=ff.feats; let s=0; for(let d=0; d<FEAT_DIM; d++) s+=weights[d]*f[d]; return s; }
          function choosePlacement(weights, grid, shape){ const acts=enumeratePlacements(grid, shape); if(acts.length===0) return null; let best=acts[0], bestS=-Infinity; for(const a of acts){ const s=scorePlacement(weights, grid, shape, a); if(s>bestS){ bestS=s; best=a; } } return best; }

          function planForCurrentPiece(){ if(!state.active) return null; const w=train.candWeights[train.candIndex] || train.mean; const a=choosePlacement(w, state.grid, state.active.shape); if(!a){ return null; } const len=SHAPES[state.active.shape].length; const cur=state.active.rot % len; const needRot=(a.rot - cur + len) % len; return { targetRot:a.rot, targetCol:a.col, rotLeft:needRot, stage:'rotate' }; }

          function aiStep(dt){
            train.ai.acc += dt; if(train.ai.acc < AI_STEP_MS) return; train.ai.acc = 0;
            if(!state.active){ return; }
            // Safety: if spawn is blocked or piece overlaps, end episode
            if(!canMove(state.grid, state.active, 0, 0)) { onGameOver(); return; }
            if(!train.ai.plan){ train.ai.plan = planForCurrentPiece(); if(!train.ai.plan){ // force drop to end episode
                while(canMove(state.grid, state.active, 0, 1)) state.active.move(0,1);
                lock(state.grid, state.active);
                state.pieces++;
                if(state.pieces % 20 === 0){
                  state.level++;
                  state.gravity = gravityForLevel(state.level);
                  updateLevel();
                }
                const cleared = clearRows(state.grid);
                if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); log(`Cleared ${cleared} row(s). Score: ${state.score}`); }
                if(state.grid[0].some(v => v !== 0)) { onGameOver(); return; }
                spawn(); if(!canMove(state.grid, state.active, 0, 0)) onGameOver(); return; }
            }
            const plan = train.ai.plan; if(!plan) return;
            if(plan.stage==='rotate'){
              if(plan.rotLeft>0){
                state.active.rotate();
                if(!canMove(state.grid, state.active, 0, 0)){
                  // Rotation blocked: abandon this plan to avoid stalling
                  state.active.rotate(-1);
                  train.ai.plan = null;
                } else {
                  plan.rotLeft -= 1;
                }
                return;
              }
              plan.stage='move'; return;
            }
            if(plan.stage==='move'){
              if(state.active.col < plan.targetCol){ if(canMove(state.grid, state.active, 1, 0)) state.active.move(1,0); else plan.stage='drop'; return; }
              if(state.active.col > plan.targetCol){ if(canMove(state.grid, state.active, -1, 0)) state.active.move(-1,0); else plan.stage='drop'; return; }
              plan.stage='drop'; return;
            }
            if(plan.stage==='drop'){
              if(canMove(state.grid, state.active, 0, 1)){ state.active.move(0,1); return; }
                lock(state.grid, state.active);
                state.pieces++;
                if(state.pieces % 20 === 0){
                  state.level++;
                  state.gravity = gravityForLevel(state.level);
                  updateLevel();
                }
                const cleared = clearRows(state.grid);
                if(cleared){ state.score += cleared*100*(cleared>1?cleared:1); updateScore(); log(`Cleared ${cleared} row(s). Score: ${state.score}`); }
              if(state.grid[0].some(v => v !== 0)) { onGameOver(); train.ai.plan = null; return; }
              spawn(); train.ai.plan = null; if(!canMove(state.grid, state.active, 0, 0)) onGameOver(); return;
            }
          }
          window.__aiStep = aiStep;

          // Hook up training buttons
          const trainBtn = document.getElementById('train');
          if(trainBtn){ trainBtn.addEventListener('click', () => { if(train.enabled) stopTraining(); else startTraining(); }); }
          const trainResetBtn = document.getElementById('train-reset');
          if(trainResetBtn){ trainResetBtn.addEventListener('click', resetTraining); }
          updateTrainStatus();
        })();
      })();
    </script>
  </body>
</html>

